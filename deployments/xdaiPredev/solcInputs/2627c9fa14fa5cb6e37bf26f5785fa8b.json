{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)`  `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/banners/BannerParts.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/// @title Default Banner parts nft\r\n/// @notice Acts as ERC1155 Nft token for banner parts\r\ncontract BannerParts is ERC1155, Ownable {\r\n    /// @notice Collection name\r\n    /// @dev Immutable, initialized on creation\r\n    string public name;\r\n\r\n    /// @notice Collection symbol\r\n    /// @dev Immutable, initialized on creation\r\n    string public symbol;\r\n\r\n    /// @notice Mapping containing if specified token id free or not\r\n    /// @dev Updated when #setFreeParts is called\r\n    /* @dev\r\n     * Id represents banner elements.\r\n     * 1 - 9999999999: first part\r\n     * 10000000000 - 19999999999: second part\r\n     * 20000000000 - 29999999999: third part\r\n     * 30000000000 - 39999999999: fourth part\r\n     * 40000000000 - 49999999999: fifth part\r\n     * 50000000000 - 59999999999: sixth part\r\n     * etc\r\n     */\r\n    mapping(uint256 => bool) public isFreePart;\r\n\r\n    /// @notice Trusted addresses map which can transfer without approve (For example: Opensea contract can be trusted so user can list its parts without approve)\r\n    /// @dev Updated when #setSafeApprovedAddress\r\n    mapping(address => bool) public isSafeApprovedAddress;\r\n\r\n    /// @notice Thrown when attempting to query balance of zero address\r\n    error UnableToQueryBalanceOfZeroAddress();\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory uri_\r\n    ) public ERC1155(uri_) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    /// @notice Marks provided address as trusted for transfers without approve\r\n    /// @dev Even though function is opened, it can only by contract owner\r\n    /// @param _address An address which will be marked as trusted or not\r\n    /// @param _status Is address trusted or not\r\n    function setSafeApprovedAddress(address _address, bool _status) public onlyOwner {\r\n        isSafeApprovedAddress[_address] = _status;\r\n    }\r\n\r\n    /// @notice Updates base token uri\r\n    /// @dev Only owner can modify base token uri\r\n    function updateURI(string memory uri_) public onlyOwner {\r\n        _setURI(uri_);\r\n    }\r\n\r\n    /// @notice Sets specified ids as free parts or not free parts\r\n    /// @dev Only owner can modify free parts\r\n    /// @param ids Token ids\r\n    /// @param statuses Is free parts or not\r\n    function setFreeParts(uint256[] calldata ids, bool[] calldata statuses) public onlyOwner {\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            isFreePart[ids[i]] = statuses[i];\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IERC1155\r\n    function isApprovedForAll(address _owner, address _operator) public view override returns (bool isOperator) {\r\n        if (isSafeApprovedAddress[_operator]) {\r\n            return true;\r\n        }\r\n\r\n        return ERC1155.isApprovedForAll(_owner, _operator);\r\n    }\r\n\r\n    /// @notice Mints specified ids with specified amounts to specified address\r\n    /// @dev Only owner can mint new parts\r\n    /// @param account An address which will receive new parts\r\n    /// @param id New part id\r\n    /// @param amount Amount of nft that will be minted\r\n    /// @param data Custom data\r\n    function mint(\r\n        address account,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public onlyOwner {\r\n        if (!isFreePart[id]) {\r\n            _mint(account, id, amount, data);\r\n        }\r\n    }\r\n\r\n    /// @notice Mints batch amount of ids with specified amounts to specified address\r\n    /// @dev Only owner can mint new parts\r\n    /// @param to An address which will receive new parts\r\n    /// @param ids New part ids\r\n    /// @param amounts Amounts of nfts that will be minted\r\n    /// @param data Custom data\r\n    function mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public onlyOwner {\r\n        uint256 count;\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            if (!isFreePart[ids[i]]) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        uint256[] memory idsTrue = new uint256[](count);\r\n        uint256[] memory amountsTrue = new uint256[](count);\r\n\r\n        uint256 index;\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            if (!isFreePart[ids[i]]) {\r\n                idsTrue[index] = ids[i];\r\n                amountsTrue[index] = amounts[i];\r\n                index++;\r\n            }\r\n        }\r\n        _mintBatch(to, idsTrue, amountsTrue, data);\r\n    }\r\n\r\n    /// @notice Burns specified id with specified amount from specified address\r\n    /// @dev Only owner can burn parts\r\n    /// @param from An address from which tokens will be burned\r\n    /// @param id Token id\r\n    /// @param amount Amount of nft that will be burned\r\n    function burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        if (!isFreePart[id]) {\r\n            _burn(from, id, amount);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IERC1155\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public override {\r\n        if (!isFreePart[id]) {\r\n            super.safeTransferFrom(from, to, id, amount, data);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IERC1155\r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        if (account == address(0)) revert UnableToQueryBalanceOfZeroAddress();\r\n        if (isFreePart[id]) {\r\n            return 1e6;\r\n        }\r\n\r\n        return super.balanceOf(account, id);\r\n    }\r\n}\r\n"
    },
    "contracts/banners/Banners.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\r\n\r\n/// @title Banners Nft\r\n/// @notice Acts as ERC721 Nft token, which supports ERC721 and ERC1155 parts as properties of every banner nft\r\ncontract Banners is ERC721Enumerable, Ownable, ERC1155Receiver {\r\n    struct Part {\r\n        address addr;\r\n        uint256 id;\r\n    }\r\n\r\n    struct BannerData {\r\n        string name;\r\n        Part[16] parts;\r\n        bytes data;\r\n    }\r\n\r\n    /// @notice Mapping containing banner data by provided token id\r\n    /// @dev Updated when #updateBanner or #mint is called\r\n    mapping(uint256 => BannerData) public bannerData;\r\n\r\n    /// @notice Base URI for computing token uri\r\n    /// @dev Updated on creation or when #updateURI is called\r\n    string public baseURI;\r\n\r\n    /// @notice Last created token id\r\n    /// @dev Updated when #mint is called\r\n    uint256 public lastTokenId = 0;\r\n\r\n    /// @notice Maximum amount of banners each address can mint\r\n    /// @dev Immutable, initialized in constructor\r\n    uint256 public maxAmountOfMintedBannersPerAddress;\r\n\r\n    /// @notice Mapping containing amount of minted banners by address\r\n    /// @dev Updated when #mint is called\r\n    mapping(address => uint256) public mintedBannersByAddress;\r\n\r\n    /// @notice Emitted when #mint is called\r\n    /// @param tokenId Newly created token id\r\n    /// @param bannerName Banner name\r\n    /// @param bannerParts Banner parts\r\n    /// @param data Banner custom parameters\r\n    event BannerCreated(uint256 tokenId, string bannerName, Part[16] bannerParts, bytes data);\r\n\r\n    /// @notice Emitted when #updateBanner is called\r\n    /// @param tokenId Token id which was updated\r\n    /// @param newBannerName New banner name\r\n    /// @param newBannerParts New parts struct\r\n    /// @param data Banner custom parameters\r\n    event BannerUpdated(uint256 tokenId, string newBannerName, Part[16] newBannerParts, bytes data);\r\n\r\n    /// @notice Thrown when attempting to mint banner while reached maximum amount of banners able to be minted by address\r\n    error CannotMintMoreThanMaximumAllowedAmountToMintForThisMsgSender();\r\n\r\n    /// @notice Thrown when attempting to update banner while not being the owner of it\r\n    error UnableToUpdateBannerDueToTokenIdDoesNotBelongToCaller();\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        string memory uri_,\r\n        uint256 maxAmountOfMintedBannersPerAddress_\r\n    ) ERC721(name_, symbol_) {\r\n        baseURI = uri_;\r\n        maxAmountOfMintedBannersPerAddress = maxAmountOfMintedBannersPerAddress_;\r\n    }\r\n\r\n    /// @inheritdoc IERC165\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC721Enumerable, ERC1155Receiver)\r\n        returns (bool)\r\n    {\r\n        return ERC721Enumerable.supportsInterface(interfaceId) || ERC1155Receiver.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /// @dev Overridden value from ERC721\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return baseURI;\r\n    }\r\n\r\n    /// @inheritdoc IERC1155Receiver\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        return IERC1155Receiver.onERC1155Received.selector;\r\n    }\r\n\r\n    /// @inheritdoc IERC1155Receiver\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    /// @notice Returns banner data with parts\r\n    /// @dev Default mapping read method does not return all data\r\n    /// @param tokenIndex Token index\r\n    /// @return name Banner name\r\n    /// @return parts Banner parts\r\n    /// @return data Banner data\r\n    function getBannerData(uint256 tokenIndex)\r\n        public\r\n        view\r\n        returns (\r\n            string memory name,\r\n            Part[16] memory parts,\r\n            bytes memory data\r\n        )\r\n    {\r\n        return (bannerData[tokenIndex].name, bannerData[tokenIndex].parts, bannerData[tokenIndex].data);\r\n    }\r\n\r\n    /// @notice Returns all token ids for specified holder address\r\n    /// @dev Used to query all token ids without asking them one by one (may not work for holder with very large amount of nfts)\r\n    /// @param holderAddress Holder address\r\n    /// @return tokenIds Token ids holder owns\r\n    function getTokenIdsByAddress(address holderAddress) public view returns (uint256[] memory tokenIds) {\r\n        uint256 userBalance = balanceOf(holderAddress);\r\n        tokenIds = new uint256[](userBalance);\r\n\r\n        for (uint256 i = 0; i < userBalance; i++) {\r\n            tokenIds[i] = tokenOfOwnerByIndex(holderAddress, i);\r\n        }\r\n    }\r\n\r\n    /// @notice Returns all banners data for specified token ids\r\n    /// @dev Used to query all banner data without asking them one by one (may not work for holder with very large amount of token ids)\r\n    /// @param tokenIds Token ids\r\n    /// @return bannersData Banner data for every token id\r\n    function getBannersDataByTokenIds(uint256[] memory tokenIds)\r\n        public\r\n        view\r\n        returns (BannerData[] memory bannersData)\r\n    {\r\n        bannersData = new BannerData[](tokenIds.length);\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            bannersData[i] = bannerData[tokenIds[i]];\r\n        }\r\n    }\r\n\r\n    /// @notice Updates base token uri\r\n    /// @dev Only owner can modify base token uri\r\n    function updateURI(string memory _uri) public onlyOwner {\r\n        baseURI = _uri;\r\n    }\r\n\r\n    /// @notice Mints banner with specified parameters\r\n    /// @dev Specified banner parts will be taken from msg.sender\r\n    /// @param name Banner name\r\n    /// @param parts Banner parts\r\n    /// @param data Banner custom parameters\r\n    function mint(\r\n        string calldata name,\r\n        Part[16] memory parts,\r\n        bytes memory data\r\n    ) public {\r\n        uint256 amountOfBannersMintedByMsgSender = mintedBannersByAddress[msg.sender];\r\n        if (amountOfBannersMintedByMsgSender >= maxAmountOfMintedBannersPerAddress) {\r\n            revert CannotMintMoreThanMaximumAllowedAmountToMintForThisMsgSender();\r\n        }\r\n\r\n        lastTokenId++;\r\n\r\n        bannerData[lastTokenId].name = name;\r\n        bannerData[lastTokenId].data = data;\r\n        _addParts(lastTokenId, parts);\r\n\r\n        _safeMint(msg.sender, lastTokenId, data);\r\n\r\n        mintedBannersByAddress[msg.sender] = amountOfBannersMintedByMsgSender + 1;\r\n\r\n        emit BannerCreated(lastTokenId, name, parts, data);\r\n    }\r\n\r\n    /// @notice Updates banner with specified parameters\r\n    /// @param tokenId banner token id which will be updated, old banner parts, if replaced, will be refunded to the owner\r\n    /// @param name New banner name\r\n    /// @param parts New banner parts\r\n    /// @param data Banner custom parameters\r\n    function updateBanner(\r\n        uint256 tokenId,\r\n        string calldata name,\r\n        Part[16] memory parts,\r\n        bytes memory data\r\n    ) public {\r\n        if (msg.sender != ownerOf(tokenId)) revert UnableToUpdateBannerDueToTokenIdDoesNotBelongToCaller();\r\n\r\n        for (uint256 i = 0; i < parts.length; i++) {\r\n            if (parts[i].addr == bannerData[tokenId].parts[i].addr && parts[i].id == bannerData[tokenId].parts[i].id) {\r\n                continue;\r\n            }\r\n\r\n            // We support parts ERC1155 as well as ERC712\r\n            // This means we are trying to get both standards, if first call fails -> we try second, otherwise call reverts\r\n\r\n            // Firstly we transfer new parts to this contract\r\n            if (parts[i].addr != address(0)) {\r\n                try IERC1155(parts[i].addr).safeTransferFrom(msg.sender, address(this), parts[i].id, 1, \"0x\") {} catch (\r\n                    bytes memory\r\n                ) {\r\n                    IERC721(parts[i].addr).safeTransferFrom(msg.sender, address(this), parts[i].id);\r\n                }\r\n            }\r\n\r\n            // Secondly we return old parts to the owner\r\n            if (bannerData[tokenId].parts[i].addr != address(0)) {\r\n                try\r\n                    IERC1155(bannerData[tokenId].parts[i].addr).safeTransferFrom(\r\n                        address(this),\r\n                        msg.sender,\r\n                        bannerData[tokenId].parts[i].id,\r\n                        1,\r\n                        \"0x\"\r\n                    )\r\n                {} catch (\r\n                    bytes memory\r\n                ) {\r\n                    IERC721(bannerData[tokenId].parts[i].addr).safeTransferFrom(\r\n                        address(this),\r\n                        msg.sender,\r\n                        bannerData[tokenId].parts[i].id\r\n                    );\r\n                }\r\n            }\r\n\r\n            bannerData[tokenId].parts[i] = parts[i];\r\n        }\r\n\r\n        bannerData[tokenId].name = name;\r\n        bannerData[tokenId].data = data;\r\n        emit BannerUpdated(tokenId, name, parts, data);\r\n    }\r\n\r\n    /// @dev Transfers specified banner parts from msg.sender to this contract\r\n    function _addParts(uint256 tokenId, Part[16] memory parts) internal {\r\n        for (uint256 i = 0; i < parts.length; i++) {\r\n            if (parts[i].addr == address(0)) {\r\n                continue;\r\n            }\r\n\r\n            // We support parts ERC1155 as well as ERC712\r\n            // This means we are trying to get both standards, if first call fails -> we try second, otherwise call reverts\r\n            try IERC1155(parts[i].addr).safeTransferFrom(msg.sender, address(this), parts[i].id, 1, \"0x\") {} catch (\r\n                bytes memory\r\n            ) {\r\n                IERC721(parts[i].addr).safeTransferFrom(msg.sender, address(this), parts[i].id);\r\n            }\r\n\r\n            bannerData[tokenId].parts[i] = parts[i];\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/const/GameAssetTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n// Group types\r\nbytes32 constant ARMY_GROUP_TYPE_ID = keccak256(bytes((\"army\")));\r\nbytes32 constant ERA_GROUP_TYPE_ID = keccak256(bytes((\"era\")));\r\nbytes32 constant WORKERS_POOL_GROUP_TYPE_ID = keccak256(bytes(\"workersPool\"));\r\nbytes32 constant UNITS_POOL_GROUP_TYPE_ID = keccak256(bytes(\"unitsPool\"));\r\nbytes32 constant SETTLEMENT_MARKET_GROUP_TYPE_ID = keccak256(bytes(\"settlementsMarket\"));\r\nbytes32 constant BATTLE_GROUP_TYPE_ID = keccak256(bytes(\"battle\"));\r\nbytes32 constant REGION_GROUP_TYPE_ID = keccak256(bytes(\"region\"));\r\nbytes32 constant SETTLEMENT_GROUP_TYPE_ID = keccak256(bytes(\"settlement\"));\r\nbytes32 constant TILE_CAPTURING_SYSTEM_GROUP_TYPE_ID = keccak256(bytes(\"tileCapturingSystem\"));\r\nbytes32 constant PROSPERITY_GROUP_TYPE_ID = keccak256(bytes(\"prosperity\"));\r\nbytes32 constant WORKERS_GROUP_TYPE_ID = keccak256(bytes(\"workers\"));\r\nbytes32 constant RESOURCE_GROUP_TYPE_ID = keccak256(bytes(\"resource\"));\r\nbytes32 constant UNITS_GROUP_TYPE_ID = keccak256(bytes(\"units\"));\r\nbytes32 constant BUILDING_GROUP_TYPE_ID = keccak256(bytes(\"building\"));\r\nbytes32 constant SIEGE_GROUP_TYPE_ID = keccak256(bytes(\"siege\"));\r\n\r\n// Asset types\r\n\r\n// Basic type\r\nbytes32 constant BASIC_TYPE_ID = keccak256(bytes(\"BASIC\"));\r\n\r\n// Settlement type\r\nbytes32 constant CULTISTS_SETTLEMENT_TYPE_ID = keccak256(bytes(\"CULTISTS\"));\r\n\r\n// Unit pool types\r\nbytes32 constant INGOTS_UNIT_POOL_TYPE_ID = keccak256(bytes(\"INGOTS_UNIT_POOL\"));\r\nbytes32 constant WORKERS_UNIT_POOL_TYPE_ID = keccak256(bytes(\"WORKERS_UNIT_POOL\"));\r\n\r\n// Resource types\r\nbytes32 constant FOOD_TYPE_ID = keccak256(bytes(\"FOOD\"));\r\nbytes32 constant WOOD_TYPE_ID = keccak256(bytes(\"WOOD\"));\r\nbytes32 constant ORE_TYPE_ID = keccak256(bytes(\"ORE\"));\r\nbytes32 constant INGOT_TYPE_ID = keccak256(bytes(\"INGOT\"));\r\nbytes32 constant HEALTH_TYPE_ID = keccak256(bytes(\"HEALTH\"));\r\n\r\n// Building types\r\nbytes32 constant FARM_TYPE_ID = keccak256(bytes(\"FARM\"));\r\nbytes32 constant LUMBERMILL_TYPE_ID = keccak256(bytes(\"LUMBERMILL\"));\r\nbytes32 constant MINE_TYPE_ID = keccak256(bytes(\"MINE\"));\r\nbytes32 constant SMITHY_TYPE_ID = keccak256(bytes(\"SMITHY\"));\r\nbytes32 constant FORT_TYPE_ID = keccak256(bytes(\"FORT\"));\r\n\r\n// Unit types\r\nbytes32 constant WARRIOR_TYPE_ID = keccak256(bytes(\"WARRIOR\"));\r\nbytes32 constant ARCHER_TYPE_ID = keccak256(bytes(\"ARCHER\"));\r\nbytes32 constant HORSEMAN_TYPE_ID = keccak256(bytes(\"HORSEMAN\"));\r\n"
    },
    "contracts/core/assets/army/Army.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"./IArmy.sol\";\r\nimport \"../../IWorld.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\nimport \"../battle/IBattle.sol\";\r\nimport \"../era/IEra.sol\";\r\nimport \"../region/IRegion.sol\";\r\nimport \"../siege/ISiege.sol\";\r\nimport \"../../IRegistry.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../building/impl/IFort.sol\";\r\nimport \"../../../const/GameAssetTypes.sol\";\r\n\r\ncontract Army is WorldAsset, IArmy {\r\n    /// @inheritdoc IArmy\r\n    ISettlement public override relatedSettlement;\r\n    /// @inheritdoc IArmy\r\n    uint64 public override currentPosition;\r\n    /// @inheritdoc IArmy\r\n    IBattle public override battle;\r\n    /// @inheritdoc IArmy\r\n    ManeuverInfo public override maneuverInfo;\r\n    /// @inheritdoc IArmy\r\n    StunInfo public override stunInfo;\r\n    /// @inheritdoc IArmy\r\n    mapping(bytes32 => uint256) public override additionalUnitsBattleMultipliers;\r\n\r\n    /// @dev Only ruler or world or world asset from same era modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyRulerOrWorldAssetFromSameEra() {\r\n        _onlyRulerOrWorldAssetFromSameEra();\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        (address settlementAddress) = abi.decode(initParams, (address));\r\n\r\n        relatedSettlement = ISettlement(settlementAddress);\r\n        currentPosition = relatedSettlement.position();\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function updateState() public override {\r\n        IRegistry _registry = registry();\r\n\r\n        if (address(battle) != address(0)) {\r\n            if (!battle.isEndedBattle() && battle.canEndBattle()) {\r\n                battle.endBattle();\r\n            }\r\n\r\n            if (battle.isEndedBattle()) {\r\n                IBattle oldBattle = battle;\r\n\r\n                (bool isArmyWon, uint256[] memory unitsAmounts) = oldBattle.calculateArmyCasualties(address(this));\r\n\r\n                // It is important to call 'setBattle' after 'burnUnits' because\r\n                // burnUnits will trigger region.updateState and region.updateState rely on army.battle in order to properly save its time\r\n                this.burnUnits(_registry.getUnitTypeIds(), unitsAmounts);\r\n                battle = IBattle(address(0));\r\n\r\n                (uint64 battleBeginTime, uint64 battleDuration,) = oldBattle.battleTimeInfo();\r\n                uint64 stunBeginTime = battleBeginTime + battleDuration;\r\n                uint256 battleStunMultiplier = isArmyWon\r\n                    ? _registry.getBattleDurationWinningArmyStunMultiplier()\r\n                    : _registry.getBattleDurationLosingArmyStunMultiplier();\r\n\r\n                uint256 stunDuration = battleDuration * battleStunMultiplier / 1e18;\r\n                _applyStun(stunBeginTime, stunDuration);\r\n\r\n                emit ExitedFromBattle(address(oldBattle));\r\n            }\r\n        }\r\n\r\n        if (_isManeuveringOpenly() && _hasComeToDestinationPosition()) {\r\n            uint64 maneuverDuration = maneuverInfo.endTime - maneuverInfo.beginTime;\r\n            uint64 stunBeginTime = maneuverInfo.endTime;\r\n            uint256 stunDuration = maneuverDuration * _registry.getManeuverDurationStunMultiplier() / 1e18;\r\n\r\n            currentPosition = maneuverInfo.destinationPosition;\r\n\r\n            maneuverInfo = ManeuverInfo({\r\n                beginTime: 0,\r\n                endTime: 0,\r\n                destinationPosition: 0,\r\n                secretDestinationRegionId: 0,\r\n                secretDestinationPosition: bytes32(0)\r\n            });\r\n\r\n            _applyStun(stunBeginTime, stunDuration);\r\n\r\n            emit UpdatedPosition(address(era().settlementByPosition(currentPosition)), currentPosition);\r\n        }\r\n\r\n        if (stunInfo.endTime != 0) {\r\n            uint256 _gameEndTime = world().gameEndTime();\r\n            uint256 currentTimestamp = _gameEndTime == 0 ? block.timestamp : Math.min(block.timestamp, _gameEndTime);\r\n\r\n            if (currentTimestamp >= stunInfo.endTime) {\r\n                stunInfo.beginTime = 0;\r\n                stunInfo.endTime = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function getOwner() public view override returns (address) {\r\n        return relatedSettlement.getSettlementOwner();\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function burnUnits(bytes32[] memory unitTypeIds, uint256[] memory unitsAmounts)\r\n        public\r\n        override\r\n        onlyWorldAssetFromSameEra\r\n    {\r\n        IEra _era = era();\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            if (unitsAmounts[i] == 0) {\r\n                continue;\r\n            }\r\n\r\n            IUnits units = _era.units(unitTypeIds[i]);\r\n            uint256 unitsAmount = units.balanceOf(address(this));\r\n            uint256 amountToBurn = unitsAmounts[i];\r\n            if (amountToBurn > unitsAmount) {\r\n                amountToBurn = unitsAmount;\r\n            }\r\n\r\n            units.burn(amountToBurn);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function liquidateUnits(bytes32[] memory unitTypeIds, uint256[] memory unitsAmounts)\r\n        public\r\n        override\r\n        onlyWorldAssetFromSameEra\r\n    {\r\n        this.burnUnits(unitTypeIds, unitsAmounts);\r\n\r\n        // If liquidation occurs not at cultists position -> we give prosperity (and/or workers) for each liquidated unit to the settlement where army stands\r\n        ISettlement settlementOnPosition = _getSettlementOnCurrentPosition();\r\n        ISettlement cultistsSettlementOnThisRegion = settlementOnPosition.relatedRegion().cultistsSettlement();\r\n        IRegistry _registry = registry();\r\n        IEra _era = era();\r\n\r\n        if (address(cultistsSettlementOnThisRegion) != address(settlementOnPosition)) {\r\n            uint256 prosperityForLiquidatedUnits = 0;\r\n            uint256 workersForLiquidatedUnits = 0;\r\n            for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n                prosperityForLiquidatedUnits += (unitsAmounts[i] / 1e18) * _registry.getProsperityForUnitLiquidation(unitTypeIds[i]);\r\n                workersForLiquidatedUnits += (unitsAmounts[i] / 1e18) * _registry.getWorkersForUnitLiquidation(unitTypeIds[i]);\r\n            }\r\n\r\n            if (prosperityForLiquidatedUnits > 0) {\r\n                settlementOnPosition.extendProsperity(prosperityForLiquidatedUnits);\r\n            }\r\n\r\n            if (workersForLiquidatedUnits > 0) {\r\n                _era.workers().mint(\r\n                    address(settlementOnPosition),\r\n                    MathExtension.roundDownWithPrecision(workersForLiquidatedUnits, 1e18)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function beginOpenManeuver(uint64 position, uint256 foodToSpendOnAcceleration)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyRulerOrWorldAssetFromSameEra\r\n    {\r\n        updateState();\r\n\r\n        if (stunInfo.endTime != 0) revert ArmyIsStunned();\r\n        if (isManeuvering()) revert ArmyIsManeuvering();\r\n        if (address(battle) != address(0)) revert ArmyIsInBattle();\r\n        if (_isBesieging()) revert ArmyIsInSiege();\r\n        if (currentPosition == position) revert ArmyCannotManeuverToSamePosition();\r\n\r\n        address destinationSettlementAddress = address(era().settlementByPosition(position));\r\n        bool hasSettlementOnDestinationPosition = destinationSettlementAddress != address(0);\r\n\r\n        if (!hasSettlementOnDestinationPosition) revert ArmyCannotManeuverToPositionWithoutSettlement();\r\n\r\n        bool isEmptyArmy = _getArmyTotalUnitsAmount(address(this)) == 0;\r\n\r\n        if (isEmptyArmy) {\r\n            bool isDestinationSettlementHomeSettlement = destinationSettlementAddress == address(relatedSettlement);\r\n\r\n            if (!isDestinationSettlementHomeSettlement) revert ArmyWithoutUnitsCannotManeuverToNotHomeSettlement();\r\n            if (foodToSpendOnAcceleration > 0) revert ArmyWithoutUnitsCannotAccelerate();\r\n        }\r\n\r\n        uint64 distanceBetweenPositions = world().geography().getDistanceBetweenPositions(currentPosition, position);\r\n        uint256 defaultManeuverDuration = _calculateDefaultManeuverDuration(distanceBetweenPositions);\r\n\r\n        uint256 maneuverDuration = defaultManeuverDuration;\r\n        if (foodToSpendOnAcceleration > 0) {\r\n            uint256 maxDecreasedManeuverDuration = _calculateMaxDecreasedManeuverDuration(distanceBetweenPositions);\r\n            uint256 maxManeuverDurationReduction = defaultManeuverDuration - maxDecreasedManeuverDuration;\r\n\r\n            uint256 maneuverDurationReduction = _speedUpArmyByBurningTreasuryOnCurrentPosition(\r\n                maxManeuverDurationReduction,\r\n                distanceBetweenPositions,\r\n                foodToSpendOnAcceleration,\r\n                FARM_TYPE_ID\r\n            );\r\n\r\n            maneuverDuration -= maneuverDurationReduction;\r\n        }\r\n\r\n        maneuverInfo = ManeuverInfo({\r\n            beginTime: uint64(block.timestamp),\r\n            endTime: uint64(block.timestamp + maneuverDuration),\r\n            destinationPosition: position,\r\n            secretDestinationRegionId: 0,\r\n            secretDestinationPosition: bytes32(0)\r\n        });\r\n\r\n        emit ManeuveringBegan(\r\n            position,\r\n            0,\r\n            bytes32(0),\r\n            maneuverInfo.beginTime,\r\n            maneuverInfo.endTime,\r\n            foodToSpendOnAcceleration\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function beginSecretManeuver(\r\n        uint64 secretDestinationRegionId,\r\n        bytes32 secretDestinationPosition\r\n    )\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyRulerOrWorldAssetFromSameEra\r\n    {\r\n        updateState();\r\n\r\n        if (stunInfo.endTime != 0) revert ArmyIsStunned();\r\n        if (isManeuvering()) revert ArmyIsManeuvering();\r\n        if (address(battle) != address(0)) revert ArmyIsInBattle();\r\n        if (_isBesieging()) revert ArmyIsInSiege();\r\n        if (_getArmyTotalUnitsAmount(address(this)) == 0) revert ArmyWithoutUnitsCannotBeginSecretManeuver();\r\n\r\n        maneuverInfo.beginTime = uint64(block.timestamp);\r\n        maneuverInfo.secretDestinationRegionId = secretDestinationRegionId;\r\n        maneuverInfo.secretDestinationPosition = secretDestinationPosition;\r\n\r\n        emit ManeuveringBegan(\r\n            0,\r\n            secretDestinationRegionId,\r\n            secretDestinationPosition,\r\n            maneuverInfo.beginTime,\r\n            0,\r\n            0\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function revealSecretManeuver(uint64 destinationPosition, bytes32 revealKey, uint256 woodToSpendOnAcceleration)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n    {\r\n        updateState();\r\n\r\n        if (!_isManeuveringSecretly()) revert ArmyIsNotManeuveringSecretly();\r\n        if (keccak256(abi.encodePacked(destinationPosition, revealKey)) != maneuverInfo.secretDestinationPosition) revert WrongSecretManeuverRevealInfo();\r\n\r\n        uint64 distanceBetweenPositions = world().geography().getDistanceBetweenPositions(currentPosition, destinationPosition);\r\n        uint256 defaultManeuverDuration = _calculateDefaultManeuverDuration(distanceBetweenPositions);\r\n        uint256 maneuverEndTimeWithoutAcceleration = maneuverInfo.beginTime + defaultManeuverDuration;\r\n\r\n        if (woodToSpendOnAcceleration > 0) {\r\n            if (stunInfo.endTime != 0) revert ArmyIsStunned();\r\n            if (address(battle) != address(0)) revert ArmyIsInBattle();\r\n\r\n            uint256 maxDecreasedManeuverDuration = _calculateMaxDecreasedManeuverDuration(distanceBetweenPositions);\r\n\r\n            uint256 minAllowedRevealTime = maneuverInfo.beginTime + maxDecreasedManeuverDuration;\r\n            uint256 maxAllowedRevealTime = maneuverInfo.beginTime + defaultManeuverDuration;\r\n\r\n            if (block.timestamp < minAllowedRevealTime || block.timestamp >= maxAllowedRevealTime) revert SecretManeuverRevealNotPossibleAtThisTime();\r\n        } else {\r\n            if (address(battle) != address(0)) {\r\n                (uint64 battleBeginTime, uint64 battleDuration,) = battle.battleTimeInfo();\r\n                uint256 projectedBattleEndTime = uint256(battleBeginTime + battleDuration);\r\n\r\n                if (projectedBattleEndTime >= maneuverEndTimeWithoutAcceleration) revert SecretManeuverRevealNotPossibleAtThisTime();\r\n\r\n                uint256 minAllowedRevealTime = maneuverInfo.beginTime;\r\n                uint256 maxAllowedRevealTime = maneuverEndTimeWithoutAcceleration;\r\n\r\n                if (block.timestamp < minAllowedRevealTime || block.timestamp >= maxAllowedRevealTime) revert SecretManeuverRevealNotPossibleAtThisTime();\r\n            } else {\r\n                uint256 minAllowedRevealTime = maneuverInfo.beginTime;\r\n                uint256 maxAllowedRevealTime = maneuverEndTimeWithoutAcceleration;\r\n\r\n                if (block.timestamp < minAllowedRevealTime || block.timestamp >= maxAllowedRevealTime) revert SecretManeuverRevealNotPossibleAtThisTime();\r\n            }\r\n        }\r\n\r\n        ISettlement destinationSettlement = era().settlementByPosition(destinationPosition);\r\n        if (address(destinationSettlement) == address(0)) revert ArmyCannotManeuverToPositionWithoutSettlement();\r\n        if (destinationPosition == currentPosition) revert ArmyCannotManeuverToSamePosition();\r\n\r\n        uint64 regionIdOfDestinationPosition = destinationSettlement.relatedRegion().regionId();\r\n        if (maneuverInfo.secretDestinationRegionId != regionIdOfDestinationPosition) revert SecretManeuverRevealNotPossibleToNotSpecifiedRegion();\r\n\r\n        uint256 maneuverDuration = defaultManeuverDuration;\r\n        if (woodToSpendOnAcceleration > 0) {\r\n            uint256 maxManeuverDurationReduction = maneuverEndTimeWithoutAcceleration - block.timestamp;\r\n            uint256 maneuverDurationReduction = _speedUpArmyByBurningTreasuryOnCurrentPosition(\r\n                maxManeuverDurationReduction,\r\n                distanceBetweenPositions,\r\n                woodToSpendOnAcceleration,\r\n                LUMBERMILL_TYPE_ID\r\n            );\r\n\r\n            maneuverDuration -= maneuverDurationReduction;\r\n        }\r\n\r\n        maneuverInfo.endTime = maneuverInfo.beginTime + uint64(maneuverDuration);\r\n\r\n        // Event is emitted before updating maneuverInfo because it is important to know secret maneuver info at the moment of event emission\r\n        emit ManeuveringBegan(\r\n            destinationPosition,\r\n            maneuverInfo.secretDestinationRegionId,\r\n            maneuverInfo.secretDestinationPosition,\r\n            maneuverInfo.beginTime,\r\n            maneuverInfo.endTime,\r\n            woodToSpendOnAcceleration\r\n        );\r\n\r\n        maneuverInfo.destinationPosition = destinationPosition;\r\n        maneuverInfo.secretDestinationRegionId = 0;\r\n        maneuverInfo.secretDestinationPosition = bytes32(0);\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function cancelSecretManeuver()\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyRulerOrWorldAssetFromSameEra\r\n    {\r\n        updateState();\r\n\r\n        if (!_isManeuveringSecretly()) revert ArmyIsNotManeuveringSecretly();\r\n        if (stunInfo.endTime != 0) revert ArmyIsStunned();\r\n        if (address(battle) != address(0)) revert ArmyIsInBattle();\r\n\r\n        IRegistry _registry = registry();\r\n        IEra _era = era();\r\n\r\n        uint256 stunDurationMultiplierOfCancelledSecretManeuver = _registry.getStunDurationMultiplierOfCancelledSecretManeuver();\r\n        uint256 stunDuration = ((block.timestamp - maneuverInfo.beginTime) * stunDurationMultiplierOfCancelledSecretManeuver) / 1e18;\r\n\r\n        _applyStun(uint64(block.timestamp), stunDuration);\r\n\r\n        maneuverInfo.beginTime = 0;\r\n        maneuverInfo.secretDestinationRegionId = 0;\r\n        maneuverInfo.secretDestinationPosition = bytes32(0);\r\n\r\n        bytes32[] memory unitTypeIds = _registry.getUnitTypeIds();\r\n        uint256[] memory unitsAmounts = new uint256[](unitTypeIds.length);\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            unitsAmounts[i] = _era.units(unitTypeIds[i]).balanceOf(address(this));\r\n        }\r\n\r\n        this.liquidateUnits(unitTypeIds, unitsAmounts);\r\n\r\n        emit SecretManeuverCancelled();\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function demilitarize(bytes32[] memory unitTypeIds, uint256[] memory unitsAmounts)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyRulerOrWorldAssetFromSameEra\r\n    {\r\n        updateState();\r\n\r\n        if (stunInfo.endTime != 0) revert ArmyIsStunned();\r\n        if (address(battle) != address(0)) revert ArmyIsInBattle();\r\n\r\n        IEra _era = era();\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            uint256 unitsAmount = unitsAmounts[i];\r\n            if (unitsAmount == 0 || !MathExtension.isIntegerWithPrecision(unitsAmount, 1e18)) revert WrongDemilitarizationInput();\r\n\r\n            uint256 actualUnitsAmount = _era.units(unitTypeIds[i]).balanceOf(address(this));\r\n            if (actualUnitsAmount < unitsAmount) revert NotEnoughUnitsForDemilitarization();\r\n        }\r\n\r\n        this.liquidateUnits(unitTypeIds, unitsAmounts);\r\n\r\n        emit UnitsDemilitarized(unitTypeIds, unitsAmounts);\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function getCurrentPosition() public view override returns (uint64) {\r\n        uint256 _gameEndTime = world().gameEndTime();\r\n        uint256 currentTimestamp = _gameEndTime == 0 ? block.timestamp : Math.min(block.timestamp, _gameEndTime);\r\n\r\n        if (_isManeuveringOpenly() && currentTimestamp >= maneuverInfo.endTime) {\r\n            return maneuverInfo.destinationPosition;\r\n        }\r\n\r\n        return currentPosition;\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function beginBattle(\r\n        address targetArmyAddress,\r\n        bytes32[] calldata maxUnitTypeIdsToAttack,\r\n        uint256[] calldata maxUnitsToAttack\r\n    )\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyRulerOrWorldAssetFromSameEra\r\n    {\r\n        updateState();\r\n        IArmy targetArmy = IArmy(targetArmyAddress);\r\n\r\n        //only target army position is updated because in order to attack, new position is required\r\n        //but in case target army is still in battle then army will exit battle whenever 'joinBattle' is called below\r\n        targetArmy.updateState();\r\n        uint64 targetArmyPosition = targetArmy.getCurrentPosition();\r\n\r\n        if (world().worldAssets(eraNumber(), targetArmyAddress) != ARMY_GROUP_TYPE_ID) revert ArmyCannotAttackNotCurrentEraArmy();\r\n        if (address(this) == targetArmyAddress) revert ArmyCannotAttackItself();\r\n        if (stunInfo.endTime != 0) revert ArmyIsStunned();\r\n        if (isManeuvering()) revert ArmyIsManeuvering();\r\n        if (currentPosition != targetArmyPosition) revert ArmyCannotAttackAnotherArmyIfTheyAreNotOnSamePosition();\r\n\r\n        address newBattleAddress = worldAssetFactory().create(\r\n            address(world()),\r\n            eraNumber(),\r\n            BATTLE_GROUP_TYPE_ID,\r\n            BASIC_TYPE_ID,\r\n            abi.encode(address(this), targetArmyAddress, maxUnitTypeIdsToAttack, maxUnitsToAttack)\r\n        );\r\n\r\n        emit BattleCreated(newBattleAddress, targetArmyAddress);\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function joinBattle(address battleAddress, uint256 side)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyRulerOrWorldAssetFromSameEra\r\n    {\r\n        updateState();\r\n\r\n        if (world().worldAssets(eraNumber(), battleAddress) != BATTLE_GROUP_TYPE_ID) revert ArmyCannotJoinToNotCurrentEraBattle();\r\n\r\n        // If caller not the battle itself -> army cannot join if its maneuvering or stunned\r\n        if (msg.sender != battleAddress) {\r\n            if (isManeuvering()) revert ArmyIsManeuvering();\r\n            if (stunInfo.endTime != 0) revert ArmyIsStunned();\r\n        }\r\n\r\n        if (address(battle) != address(0)) revert ArmyIsInBattle();\r\n        if (_getArmyTotalUnitsAmount(address(this)) == 0) revert ArmyWithoutUnitsCannotJoinBattle();\r\n        if (side != 1 && side != 2) revert WrongJoinSide();\r\n\r\n        IBattle battleToJoinTo = IBattle(battleAddress);\r\n        if (!battleToJoinTo.isLobbyTime()) revert ArmyCannotJoinToBattleNotInLobbyPhase();\r\n        if (battleToJoinTo.position() != currentPosition) revert ArmyCannotJoinToBattleNotAtSamePosition();\r\n\r\n        battle = battleToJoinTo;\r\n\r\n        bool isAttackingSide = side == 1;\r\n        bool isFirstArmyInSide = !_hasUnitsInBattleAtProvidedSide(battleToJoinTo, side);\r\n\r\n        battleToJoinTo.acceptArmyInBattle(address(this), side);\r\n\r\n        IRegistry _registry = registry();\r\n\r\n        if (isAttackingSide && !isFirstArmyInSide) {\r\n            uint256 stunDuration = _registry.getArmyStunDurationByJoiningBattleAtAttackingSide();\r\n            stunDuration /= _registry.getGlobalMultiplier();\r\n            _applyStun(uint64(block.timestamp), stunDuration);\r\n        }\r\n\r\n        emit JoinedBattle(battleAddress, side);\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function modifySiege(\r\n        bytes32[] calldata unitTypeIds,\r\n        bool[] calldata toAddIndication,\r\n        uint256[] calldata unitsAmounts,\r\n        uint256 newRobberyMultiplier\r\n    ) public override onlyActiveGame onlyRulerOrWorldAssetFromSameEra {\r\n        updateState();\r\n\r\n        if (stunInfo.endTime != 0) revert ArmyIsStunned();\r\n        if (isManeuvering()) revert ArmyIsManeuvering();\r\n\r\n        ISettlement settlementOnArmyPosition = _getSettlementOnCurrentPosition();\r\n\r\n        if (address(settlementOnArmyPosition) == address(relatedSettlement)) revert ArmyCannotBesiegeOwnSettlement();\r\n\r\n        bool hasUnitsToModify = false;\r\n\r\n        // Grouped in order to reduce stack size\r\n        {\r\n            bool hasUnitsToAdd = false;\r\n\r\n            for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n                if (unitsAmounts[i] > 0) {\r\n                    if (!hasUnitsToModify) {\r\n                        hasUnitsToModify = true;\r\n                    }\r\n\r\n                    if (toAddIndication[i]) {\r\n                        hasUnitsToAdd = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (hasUnitsToAdd && address(battle) != address(0)) revert ArmyIsInBattle();\r\n        }\r\n\r\n        ISiege siege = settlementOnArmyPosition.siege();\r\n        (uint256 oldRobberyMultiplier, , ) = siege.armyInfo(address(this));\r\n\r\n        IRegistry _registry = registry();\r\n\r\n        uint256 maxAllowedRobberyMultiplier = hasUnitsToModify\r\n            ? _registry.getMaxAllowedRobberyMultiplierIncreaseValue()\r\n            : oldRobberyMultiplier + _registry.getMaxAllowedRobberyMultiplierIncreaseValue();\r\n\r\n        if (newRobberyMultiplier > maxAllowedRobberyMultiplier) revert WrongRobberyMultiplierSpecified();\r\n        if (!hasUnitsToModify && newRobberyMultiplier <= oldRobberyMultiplier) revert WrongRobberyMultiplierSpecified();\r\n\r\n        siege.modifyArmySiege(\r\n            address(this),\r\n            unitTypeIds,\r\n            toAddIndication,\r\n            unitsAmounts,\r\n            newRobberyMultiplier\r\n        );\r\n\r\n        uint256 robberyMultiplierPunishingValue = hasUnitsToModify\r\n            ? newRobberyMultiplier\r\n            : newRobberyMultiplier - oldRobberyMultiplier;\r\n\r\n        uint256 stunDuration = _registry.getArmyStunDurationPerRobberyMultiplier() * robberyMultiplierPunishingValue / 1e18;\r\n        stunDuration /= _registry.getGlobalMultiplier();\r\n        _applyStun(uint64(block.timestamp), stunDuration);\r\n\r\n        if (siege.canLiquidateArmyBesiegingUnits(address(this))) revert ArmyCannotModifySiegeUnitsToLiquidatableState();\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function swapRobberyPointsForResourceFromBuildingTreasury(address buildingAddress, uint256 pointsToSpend)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyRulerOrWorldAssetFromSameEra\r\n    {\r\n        updateState();\r\n\r\n        if (stunInfo.endTime != 0) revert ArmyIsStunned();\r\n\r\n        _getSettlementOnCurrentPosition().siege().swapRobberyPointsForResourceFromBuildingTreasury(buildingAddress, pointsToSpend);\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function getTotalSiegeSupport() public view override returns (uint256) {\r\n        IRegistry _registry = registry();\r\n        IEra _era = era();\r\n\r\n        bytes32[] memory unitTypeIds = _registry.getUnitTypeIds();\r\n        uint256[] memory casualties = new uint256[](unitTypeIds.length);\r\n\r\n        if (address(battle) != address(0) && battle.canEndBattle()) {\r\n            (, casualties) = battle.calculateArmyCasualties(address(this));\r\n        }\r\n\r\n        uint256 totalSiegeSupport = 0;\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n            IRegistry.UnitStats memory unitStats = _registry.getUnitStats(unitTypeId);\r\n\r\n            totalSiegeSupport +=\r\n                ((_era.units(unitTypeId).balanceOf(address(this)) - casualties[i]) * unitStats.siegeSupport) /\r\n                1e18;\r\n        }\r\n\r\n        return totalSiegeSupport;\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function isAtHomePosition() public view override returns (bool) {\r\n        if (_isManeuveringOpenly() && _hasComeToDestinationPosition()) {\r\n            return maneuverInfo.destinationPosition == relatedSettlement.position();\r\n        }\r\n\r\n        return currentPosition == relatedSettlement.position();\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function isManeuvering() public view override returns (bool) {\r\n        if (_isManeuveringOpenly() && !_hasComeToDestinationPosition()) {\r\n            return true;\r\n        }\r\n\r\n        if (_isManeuveringSecretly()) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function increaseUnitBattleMultiplier(bytes32 unitTypeId, uint256 unitBattleMultiplier) public override onlyWorldAssetFromSameEra {\r\n        additionalUnitsBattleMultipliers[unitTypeId] += unitBattleMultiplier;\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function decreaseUnitBattleMultiplier(bytes32 unitTypeId, uint256 unitBattleMultiplier) public override onlyWorldAssetFromSameEra {\r\n        additionalUnitsBattleMultipliers[unitTypeId] -= unitBattleMultiplier;\r\n    }\r\n\r\n    /// @inheritdoc IArmy\r\n    function applySelfStun(uint64 stunDuration)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyRulerOrWorldAssetFromSameEra\r\n    {\r\n        updateState();\r\n\r\n        _applyStun(uint64(block.timestamp), stunDuration);\r\n    }\r\n\r\n    /// @dev Allows caller to be only ruler or any world asset\r\n    function _onlyRulerOrWorldAssetFromSameEra() internal view {\r\n        IWorld _world = world();\r\n\r\n        if (!relatedSettlement.isRuler(msg.sender) &&\r\n        msg.sender != address(_world) &&\r\n        _world.worldAssets(eraNumber(), msg.sender) == bytes32(0)\r\n        ) {\r\n            revert OnlyRulerOrWorldAssetFromSameEra();\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates amount of needed resource per one second of decreased maneuver duration\r\n    function _calculateResourceAmountPer1SecondOfDecreasedManeuverDuration() internal view returns (uint256) {\r\n        IRegistry _registry = registry();\r\n        IEra _era = era();\r\n\r\n        bytes32[] memory unitTypeIds = _registry.getUnitTypeIds();\r\n        uint256 resourceAmountPer1SecondOfDecreasedManeuverDuration = 0;\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            uint256 unitsAmount = _era.units(unitTypeIds[i]).balanceOf(address(this));\r\n\r\n            resourceAmountPer1SecondOfDecreasedManeuverDuration +=\r\n                (unitsAmount / 1e18) * _registry.getUnitResourceUsagePer1SecondOfDecreasedManeuverDuration(unitTypeIds[i]);\r\n        }\r\n\r\n        return resourceAmountPer1SecondOfDecreasedManeuverDuration * _registry.globalMultiplier();\r\n    }\r\n\r\n    /// @dev Calculates total units amount\r\n    function _getArmyTotalUnitsAmount(address armyAddress) internal view returns (uint256) {\r\n        IEra _era = era();\r\n\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n        uint256 totalUnitsAmount = 0;\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            totalUnitsAmount += _era.units(unitTypeIds[i]).balanceOf(armyAddress);\r\n        }\r\n\r\n        return totalUnitsAmount;\r\n    }\r\n\r\n    /// @dev Calculates default maneuver duration\r\n    function _calculateDefaultManeuverDuration(uint64 distanceBetweenPositions) internal view returns (uint256) {\r\n        return (5 hours * distanceBetweenPositions) / registry().getGlobalMultiplier();\r\n    }\r\n\r\n    /// @dev Calculates max default maneuver duration\r\n    function _calculateMaxDecreasedManeuverDuration(uint64 distanceBetweenPositions) internal view returns (uint256) {\r\n        return ((5 hours * MathExtension.sqrt(distanceBetweenPositions * 1e8)) / 1e4) / registry().getGlobalMultiplier();\r\n    }\r\n\r\n    /// @dev Updates building's treasury, burns resource specified for acceleration and returns maneuver duration duration reduction\r\n    function _speedUpArmyByBurningTreasuryOnCurrentPosition(\r\n        uint256 maxManeuverDurationReduction,\r\n        uint64 distanceBetweenPositions,\r\n        uint256 resourceToSpendOnAcceleration,\r\n        bytes32 buildingTypeIdFromWhichBurnResource\r\n    ) internal returns (uint256) {\r\n        uint256 resourceAmountPer1SecondOfDecreasedManeuverDuration = _calculateResourceAmountPer1SecondOfDecreasedManeuverDuration();\r\n\r\n        // Handles case when, for example, provided 123 resource but each second require 10 resource, actual provided value in this case is 120\r\n        // or provided 7 food but each second require 10 resource => 0\r\n        resourceToSpendOnAcceleration = resourceToSpendOnAcceleration - resourceToSpendOnAcceleration % resourceAmountPer1SecondOfDecreasedManeuverDuration;\r\n\r\n        uint256 resourceAmountToMaxManeuverDurationReduction = maxManeuverDurationReduction * resourceAmountPer1SecondOfDecreasedManeuverDuration;\r\n\r\n        if (resourceToSpendOnAcceleration > resourceAmountToMaxManeuverDurationReduction) {\r\n            resourceToSpendOnAcceleration = resourceAmountToMaxManeuverDurationReduction;\r\n        }\r\n\r\n        ISettlement settlementOnPosition = _getSettlementOnCurrentPosition();\r\n        bool isCultistsSettlementOnCurrentPosition = _isCultistsSettlement(settlementOnPosition);\r\n        IArmy armyOfSettlementOnCurrentPosition = settlementOnPosition.army();\r\n\r\n        if (isCultistsSettlementOnCurrentPosition) {\r\n            // If settlement on current position is cultists settlement\r\n            // -> we have to update its state in order to properly calculate whether free acceleration is possible\r\n            armyOfSettlementOnCurrentPosition.updateState();\r\n\r\n            if (_getArmyTotalUnitsAmount(address(armyOfSettlementOnCurrentPosition)) != 0) revert ArmyCannotAccelerateManeuverFromCultistsSettlementWithNonZeroCultistsArmy();\r\n        }\r\n\r\n        if (!isCultistsSettlementOnCurrentPosition) {\r\n            IBuilding building = settlementOnPosition.buildings(buildingTypeIdFromWhichBurnResource);\r\n            building.updateState();\r\n\r\n            uint256 buildingTreasury = Math.min(\r\n                era().resources(building.getProducingResourceTypeId()).stateBalanceOf(address(building)),\r\n                building.getMaxTreasuryByLevel(building.getBuildingLevel())\r\n            );\r\n\r\n            if (buildingTreasury < resourceToSpendOnAcceleration) revert ArmyCannotUseMoreResourcesForAccelerationThanBuildingTreasuryHas();\r\n            building.burnTreasury(resourceToSpendOnAcceleration);\r\n        }\r\n\r\n        return resourceToSpendOnAcceleration / resourceAmountPer1SecondOfDecreasedManeuverDuration;\r\n    }\r\n\r\n    /// @dev Checks if army is maneuvering openly\r\n    function _isManeuveringOpenly() internal view returns (bool) {\r\n        return maneuverInfo.beginTime != 0 && maneuverInfo.endTime != 0;\r\n    }\r\n\r\n    /// @dev Checks if army is maneuvering secretly\r\n    function _isManeuveringSecretly() internal view returns (bool) {\r\n        return maneuverInfo.beginTime != 0 && maneuverInfo.secretDestinationPosition != bytes32(0);\r\n    }\r\n\r\n    /// @dev Checks if army can update position at the moment\r\n    function _hasComeToDestinationPosition() internal view returns (bool) {\r\n        uint256 _gameEndTime = world().gameEndTime();\r\n        uint256 currentTimestamp = _gameEndTime == 0 ? block.timestamp : Math.min(block.timestamp, _gameEndTime);\r\n\r\n        if (maneuverInfo.endTime != 0 && currentTimestamp >= maneuverInfo.endTime) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Applies stun\r\n    function _applyStun(\r\n        uint64 stunBeginTime,\r\n        uint256 stunDuration\r\n    ) internal {\r\n        if (stunDuration == 0) {\r\n            return;\r\n        }\r\n\r\n        uint64 newStunEndTime = stunBeginTime + uint64(stunDuration);\r\n\r\n        // If new stun ends later than old stun -> we overwrite old stun with new stun\r\n        if (newStunEndTime > stunInfo.endTime) {\r\n            stunInfo.endTime = newStunEndTime;\r\n            stunInfo.beginTime = stunBeginTime;\r\n            emit StunApplied(stunBeginTime, newStunEndTime);\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates settlement on current army position\r\n    function _getSettlementOnCurrentPosition() internal view returns (ISettlement) {\r\n        return era().settlementByPosition(getCurrentPosition());\r\n    }\r\n\r\n    /// @dev Calculates if army is currently in siege or not\r\n    function _isBesieging() internal view returns (bool) {\r\n        ISettlement settlementOnCurrentPosition = _getSettlementOnCurrentPosition();\r\n\r\n        // If army is staying on cultists position -> it is not in the siege\r\n        if (IWorldAssetStorageAccessor(address(settlementOnCurrentPosition)).assetTypeId() == CULTISTS_SETTLEMENT_TYPE_ID) {\r\n            return false;\r\n        }\r\n\r\n        uint256[] memory besiegingUnitsAmounts = settlementOnCurrentPosition.siege().getArmyBesiegingUnitsAmounts(address(this));\r\n        for (uint256 i = 0; i < besiegingUnitsAmounts.length; i++) {\r\n            if (besiegingUnitsAmounts[i] > 0) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Calculates if battle has units at provided side\r\n    function _hasUnitsInBattleAtProvidedSide(IBattle battle, uint256 side) internal view returns (bool) {\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n\r\n            if (battle.sideUnitsAmount(side, unitTypeId) > 0) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Calculates whether settlement is cultists settlement\r\n    function _isCultistsSettlement(ISettlement settlement) internal view returns (bool) {\r\n        return IWorldAssetStorageAccessor(address(settlement)).assetTypeId() == CULTISTS_SETTLEMENT_TYPE_ID;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/army/IArmy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../IWorld.sol\";\r\nimport \"../battle/IBattle.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\nimport \"../siege/ISiege.sol\";\r\n\r\n/// @title Army interface\r\n/// @notice Functions to read state/modify state in order to get current army parameters and/or interact with it\r\ninterface IArmy {\r\n    struct ManeuverInfo {\r\n        uint64 beginTime;\r\n        uint64 endTime;\r\n        uint64 destinationPosition;\r\n        uint64 secretDestinationRegionId;\r\n        bytes32 secretDestinationPosition;\r\n    }\r\n\r\n    struct StunInfo {\r\n        uint64 beginTime;\r\n        uint64 endTime;\r\n    }\r\n\r\n    // State variables\r\n\r\n    /// @notice Settlement address to which this army belongs\r\n    /// @dev Immutable, initialized on the army creation\r\n    function relatedSettlement() external view returns (ISettlement);\r\n\r\n    /// @notice Position where army currently stands on\r\n    /// @dev Updated when army updates position. It does not take into account if army is maneuvering\r\n    /// @dev To proper query current position use #getCurrentPosition\r\n    function currentPosition() external view returns (uint64);\r\n\r\n    /// @notice Battle in which army is on\r\n    /// @dev If army is not in battle returns address(0). It does not take into account if battle is ended but army is not left the battle\r\n    function battle() external view returns (IBattle);\r\n\r\n    /// @notice Maneuver info\r\n    /// @dev Updated when army begins maneuvering. It does not take into account if army is ended maneuver by time\r\n    function maneuverInfo() external view returns (\r\n        uint64 beginTime,\r\n        uint64 endTime,\r\n        uint64 destinationPosition,\r\n        uint64 secretDestinationRegionId,\r\n        bytes32 secretDestinationPosition\r\n    );\r\n\r\n    /// @notice Stun info\r\n    /// @dev Updated when army stun is applied\r\n    function stunInfo() external view returns (uint64 beginTime, uint64 endTime);\r\n\r\n    /// @notice Mapping containing additional unit battle multiplier\r\n    /// @dev Updated when #increaseUnitBattleMultiplier or #decreaseUnitBattleMultiplier is called\r\n    function additionalUnitsBattleMultipliers(bytes32 unitTypeId) external view returns (uint256);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when #updatePosition is called (even though event can be emitted only on the next action related to the current army, de-facto army will update position based on 'maneuverInfo.endTime'\r\n    /// @param settlementAddress Address of the settlement where army currently staying on\r\n    /// @param position Position\r\n    event UpdatedPosition(address settlementAddress, uint64 position);\r\n\r\n    /// @notice Emitted when #createBattle is called. Army which attacks another army will emit this event\r\n    /// @param battleAddress Created battle address\r\n    /// @param targetArmyAddress Address of the attacked army\r\n    event BattleCreated(address battleAddress, address targetArmyAddress);\r\n\r\n    /// @notice Emitted when army joins battle. At the battle creation both armies (attacker and attacked) will emit this event. Attacker army will be side A and at attacked army will be sideB\r\n    /// @param battleAddress Address of the battle army joined in\r\n    /// @param side Side to which army joined (sideA = 1, sideB = 2)\r\n    event JoinedBattle(address battleAddress, uint256 side);\r\n\r\n    /// @notice Emitted when #updateState is called (even though event can be emitted only on the next action related to the current army, de-facto army will exit battle when battle is ended)\r\n    /// @param battleAddress Address of the battle army was in\r\n    event ExitedFromBattle(address battleAddress);\r\n\r\n    /// @notice Emitted when #beginOpenManeuver or #beginSecretManeuver or #revealSecretManeuver is called\r\n    /// @param position Position army is maneuvering to (0 if secret maneuver)\r\n    /// @param secretDestinationRegionId Secret destination regionId (not zero if secret maneuver)\r\n    /// @param secretDestinationPosition Secret destination position (not zero if secret maneuver)\r\n    /// @param beginTime Time at which maneuver began\r\n    /// @param endTime Time at which maneuver will end (0 if secret maneuver)\r\n    /// @param tokensToSpendOnAcceleration Amount of tokens to spend on acceleration (Food for open maneuver, Wood for secret maneuver)\r\n    event ManeuveringBegan(\r\n        uint64 position,\r\n        uint64 secretDestinationRegionId,\r\n        bytes32 secretDestinationPosition,\r\n        uint256 beginTime,\r\n        uint256 endTime,\r\n        uint256 tokensToSpendOnAcceleration\r\n    );\r\n\r\n    /// @notice Emitted when #cancelSecretManeuver is called\r\n    event SecretManeuverCancelled();\r\n\r\n    /// @notice Emitted when #_applyStun is called\r\n    /// @param stunBeginTime Stun begin time\r\n    /// @param stunEndTime Stun end time\r\n    event StunApplied(uint64 stunBeginTime, uint64 stunEndTime);\r\n\r\n    /// @notice Emitted when #demilitarize is called\r\n    /// @param unitTypeIds Unit type ids demilitarized\r\n    /// @param unitsAmounts Amount of units demilitarized\r\n    event UnitsDemilitarized(bytes32[] unitTypeIds, uint256[] unitsAmounts);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which only possible to be called by ruler, world or world asset\r\n    error OnlyRulerOrWorldAssetFromSameEra();\r\n\r\n    /// @notice Thrown when attempting to call action which is blocked when army is stunned\r\n    error ArmyIsStunned();\r\n\r\n    /// @notice Thrown when attempting to call action which is blocked when army is maneuvering\r\n    error ArmyIsManeuvering();\r\n\r\n    /// @notice Thrown when attempting to call action which is blocked when army is in battle\r\n    error ArmyIsInBattle();\r\n\r\n    /// @notice Thrown when attempting to call action which is blocked when army is in siege\r\n    error ArmyIsInSiege();\r\n\r\n    /// @notice Thrown when attempting to begin maneuver to same position\r\n    error ArmyCannotManeuverToSamePosition();\r\n\r\n    /// @notice Thrown when attempting to maneuver to position without settlement\r\n    error ArmyCannotManeuverToPositionWithoutSettlement();\r\n\r\n    /// @notice Thrown when attempting to maneuver without units to non-home position\r\n    error ArmyWithoutUnitsCannotManeuverToNotHomeSettlement();\r\n\r\n    /// @notice Thrown when attempting to maneuver without units but with acceleration\r\n    error ArmyWithoutUnitsCannotAccelerate();\r\n\r\n    /// @notice Thrown when attempting to secretly maneuver without units\r\n    error ArmyWithoutUnitsCannotBeginSecretManeuver();\r\n\r\n    /// @notice Thrown when attempting to reveal or cancel secret maneuver\r\n    error ArmyIsNotManeuveringSecretly();\r\n\r\n    /// @notice Thrown when attempting to reveal secret maneuver with invalid reveal info\r\n    error WrongSecretManeuverRevealInfo();\r\n\r\n    /// @notice Thrown when attempting to reveal secret maneuver with valid reveal info but wrong region\r\n    error SecretManeuverRevealNotPossibleToNotSpecifiedRegion();\r\n\r\n    /// @notice Thrown when attempting to reveal secret maneuver at invalid time\r\n    error SecretManeuverRevealNotPossibleAtThisTime();\r\n\r\n    /// @notice Thrown when attempting to demilitarize with invalid input\r\n    error WrongDemilitarizationInput();\r\n\r\n    /// @notice Thrown when attempting to demilitarize more units than army currently have\r\n    error NotEnoughUnitsForDemilitarization();\r\n\r\n    /// @notice Thrown when attempting to start battle by attacking army not on same position as current army\r\n    error ArmyCannotAttackAnotherArmyIfTheyAreNotOnSamePosition();\r\n\r\n    /// @notice Thrown when attempting to start battle by providing army address to attack which is not part of current era\r\n    error ArmyCannotAttackNotCurrentEraArmy();\r\n\r\n    /// @notice Thrown when attempting to start battle by providing army address which is same as current army\r\n    error ArmyCannotAttackItself();\r\n\r\n    /// @notice Thrown when attempting to join battle by providing invalid battle address\r\n    error ArmyCannotJoinToNotCurrentEraBattle();\r\n\r\n    /// @notice Thrown when attempting to join battle with army which has zero units in it\r\n    error ArmyWithoutUnitsCannotJoinBattle();\r\n\r\n    /// @notice Thrown when attempting to join battle by providing invalid side\r\n    error WrongJoinSide();\r\n\r\n    /// @notice Thrown when attempting to join battle while its not in lobby phase\r\n    error ArmyCannotJoinToBattleNotInLobbyPhase();\r\n\r\n    /// @notice Thrown when attempting to join battle which is not at same position as current army\r\n    error ArmyCannotJoinToBattleNotAtSamePosition();\r\n\r\n    /// @notice Thrown when attempting to modify siege of own settlement\r\n    error ArmyCannotBesiegeOwnSettlement();\r\n\r\n    /// @notice Thrown when attempting to modify siege by providing invalid robbery multiplier\r\n    error WrongRobberyMultiplierSpecified();\r\n\r\n    /// @notice Thrown when attempting to modify siege in result of which army will become liquidatable\r\n    error ArmyCannotModifySiegeUnitsToLiquidatableState();\r\n\r\n    /// @notice Thrown when attempting to use more resources for acceleration than related building treasury has\r\n    error ArmyCannotUseMoreResourcesForAccelerationThanBuildingTreasuryHas();\r\n\r\n    /// @notice Thrown when attempting to use accelerate maneuver from cultists settlement with non zero cultists\r\n    error ArmyCannotAccelerateManeuverFromCultistsSettlementWithNonZeroCultistsArmy();\r\n\r\n    // Functions\r\n\r\n    /// @notice Updates army state to the current block\r\n    /// @dev Called on every action which are based on army state and time\r\n    function updateState() external;\r\n\r\n    /// @notice Begins open maneuver to specified position\r\n    /// @dev Even though position can be artificial, army can move only to settlement\r\n    /// @param position Position of settlement to move to\r\n    /// @param foodToSpendOnAcceleration Amount of food army will take from current position settlements FARM in order to decrease total time army will take to get to destination position\r\n    function beginOpenManeuver(uint64 position, uint256 foodToSpendOnAcceleration) external;\r\n\r\n    /// @notice Begins secret maneuver to secret position\r\n    /// @dev Caller must be aware of the rules applied to revealing destination position otherwise army may be punished\r\n    /// @param secretDestinationRegionId Secret destination region id\r\n    /// @param secretDestinationPosition Secret destination position\r\n    function beginSecretManeuver(uint64 secretDestinationRegionId, bytes32 secretDestinationPosition) external;\r\n\r\n    /// @notice Reveals secret maneuver\r\n    /// @dev In order to successfully reveal 'secretDestinationPosition' - 'destination position' and 'revealKey' must be valid\r\n    /// @dev Validity of verified by 'keccak256(abi.encodePacked(destinationPosition, revealKey)) == secretDestinationPosition'\r\n    /// @param destinationPosition Destination position\r\n    /// @param revealKey Reveal key\r\n    /// @param woodToSpendOnAcceleration Wood to spend on acceleration\r\n    function revealSecretManeuver(uint64 destinationPosition, bytes32 revealKey, uint256 woodToSpendOnAcceleration) external;\r\n\r\n    /// @notice Cancels secret maneuver\r\n    /// @dev Can be cancelled by army owner\r\n    function cancelSecretManeuver() external;\r\n\r\n    /// @notice Demilitarizes part of the army. Demilitarization provides prosperity to the settlement army is currently staying on\r\n    /// @dev Even though demilitarization of 0 units may seem reasonable, it is disabled\r\n    /// @param unitTypeIds Unit type ids for demilitarization\r\n    /// @param unitsAmounts Amount of units to demilitarize\r\n    function demilitarize(bytes32[] memory unitTypeIds, uint256[] memory unitsAmounts) external;\r\n\r\n    /// @notice Begins battle with another army if both are not in battle\r\n    /// @dev Creates IBattle and sets both armies in created battle\r\n    /// @param armyAddress Address of the army this army will attack\r\n    /// @param maxUnitTypeIdsToAttack Max unit type ids to attack\r\n    /// @param maxUnitsToAttack Max units to attack\r\n    function beginBattle(\r\n        address armyAddress,\r\n        bytes32[] calldata maxUnitTypeIdsToAttack,\r\n        uint256[] calldata maxUnitsToAttack\r\n    ) external;\r\n\r\n    /// @notice Joins current army in battle to the provided side\r\n    /// @dev Maneuvering army is able to join battle only if caller is another army (drags it into battle)\r\n    /// @param battleAddress Battle address army will join\r\n    /// @param side Side of the battle army will join (sideA = 1, sideB = 2)\r\n    function joinBattle(address battleAddress, uint256 side) external;\r\n\r\n    /// @notice Burns units from the army\r\n    /// @dev Can only be called by world or world asset\r\n    /// @param unitTypeIds Unit type ids for burning\r\n    /// @param unitsAmounts Amount of units for burning for every unit type\r\n    function burnUnits(bytes32[] memory unitTypeIds, uint256[] memory unitsAmounts) external;\r\n\r\n    /// @notice Liquidates units from the army\r\n    /// @dev Can only be called by world or world asset\r\n    /// @param unitTypeIds Unit type ids for liquidation\r\n    /// @param unitsAmounts Amount of units for liquidation\r\n    function liquidateUnits(bytes32[] memory unitTypeIds, uint256[] memory unitsAmounts) external;\r\n\r\n    /// @notice Calculates current position taking to the account #maneuverInfo\r\n    /// @dev This method should be used to determine real army position\r\n    /// @return position Position\r\n    function getCurrentPosition() external view returns (uint64 position);\r\n\r\n    /// @notice Modifies army siege params\r\n    /// @dev Provides ability to atomically setup/re-setup siege\r\n    /// @param unitTypeIds Unit type ids\r\n    /// @param toAddIndication Indication array whether to add units or to withdraw (add = true, withdraw = false)\r\n    /// @param unitsAmounts Amounts of units to add/withdraw\r\n    /// @param newRobberyMultiplier New robbery multiplier\r\n    function modifySiege(\r\n        bytes32[] calldata unitTypeIds,\r\n        bool[] calldata toAddIndication,\r\n        uint256[] calldata unitsAmounts,\r\n        uint256 newRobberyMultiplier\r\n    ) external;\r\n\r\n    /// @notice Swaps accumulated robbery points in siege for resource from building treasury\r\n    /// @dev Amount of points will be taken may be lesser if building does not have resources in its treasury\r\n    /// @param buildingAddress Address of the building treasury of which will be robbed\r\n    /// @param pointsToSpend Amount of points to spend for resources\r\n    function swapRobberyPointsForResourceFromBuildingTreasury(address buildingAddress, uint256 pointsToSpend) external;\r\n\r\n    /// @notice Calculates total siege support of the army\r\n    /// @dev For every unit type placed in siege calculates sum of all of them\r\n    /// @return totalSiegeSupport Total siege support of the army\r\n    function getTotalSiegeSupport() external view returns (uint256 totalSiegeSupport);\r\n\r\n    /// @notice Return owner of the army\r\n    /// @dev Same as owner of the settlement to which this army belongs\r\n    /// @return ownerAddress Address of the owner of the army\r\n    function getOwner() external view returns (address ownerAddress);\r\n\r\n    /// @notice Calculates is army at home position\r\n    /// @dev Takes into account if army maneuver is ended (by time)\r\n    /// @return isAtHomePosition Is army at home position\r\n    function isAtHomePosition() external view returns (bool isAtHomePosition);\r\n\r\n    /// @notice Calculates is army maneuvering (openly or secretly)\r\n    /// @dev Takes into account if army maneuver is ended (by time)\r\n    /// @return isManeuvering Is maneuvering\r\n    function isManeuvering() external view returns (bool isManeuvering);\r\n\r\n    /// @notice Increases unit battle multiplier\r\n    /// @dev Can only be called by world or world asset\r\n    /// @param unitTypeId Unit type id\r\n    /// @param unitBattleMultiplier Unit battle multiplier\r\n    function increaseUnitBattleMultiplier(bytes32 unitTypeId, uint256 unitBattleMultiplier) external;\r\n\r\n    /// @notice Decreases unit battle multiplier\r\n    /// @dev Can only be called by world or world asset\r\n    /// @param unitTypeId Unit type id\r\n    /// @param unitBattleMultiplier Unit battle multiplier\r\n    function decreaseUnitBattleMultiplier(bytes32 unitTypeId, uint256 unitBattleMultiplier) external;\r\n\r\n    /// @notice Applies army stun by settlement ruler\r\n    /// @dev Provides ability to self stun owned army\r\n    /// @param stunDuration Stun duration\r\n    function applySelfStun(uint64 stunDuration) external;\r\n}\r\n"
    },
    "contracts/core/assets/battle/Battle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"./IBattle.sol\";\r\nimport \"../army/IArmy.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../../IRegistry.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../../../const/GameAssetTypes.sol\";\r\n\r\ncontract Battle is WorldAsset, IBattle {\r\n    struct BattleWithCultistsInitiationInfo {\r\n        bytes32[] maxUnitTypeIdsToAttack;\r\n        uint256[] maxUnitsToAttack;\r\n    }\r\n\r\n    /// @dev Specifies amount of cultists to draw into the battle if battle is initiated by attacking them\r\n    BattleWithCultistsInitiationInfo private battleWithCultistsInitiationInfo;\r\n\r\n    /// @inheritdoc IBattle\r\n    uint64 public override position;\r\n    /// @inheritdoc IBattle\r\n    mapping(uint256 => mapping(bytes32 => uint256)) public override sideUnitsAmount;\r\n    /// @inheritdoc IBattle\r\n    mapping(address => mapping(bytes32 => uint256)) public override armyUnitsAmount;\r\n    /// @inheritdoc IBattle\r\n    mapping(address => mapping(bytes32 => uint256)) public override armyUnitsAdditionalMultipliers;\r\n    /// @inheritdoc IBattle\r\n    mapping(uint256 => mapping(bytes32 => uint256)) public override casualties;\r\n    /// @inheritdoc IBattle\r\n    mapping(address => uint256) public override armySide;\r\n    /// @inheritdoc IBattle\r\n    BattleTimeInfo public override battleTimeInfo;\r\n    /// @inheritdoc IBattle\r\n    uint256 public override winningSide;\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        (\r\n            address attackerArmyAddress,\r\n            address attackedArmyAddress,\r\n            bytes32[] memory maxUnitTypeIdsToAttack,\r\n            uint256[] memory maxUnitsToAttack\r\n        ) = abi.decode(initParams, (address, address, bytes32[], uint256[]));\r\n\r\n        IArmy attackerArmy = IArmy(attackerArmyAddress);\r\n        IArmy attackedArmy = IArmy(attackedArmyAddress);\r\n\r\n        position = attackerArmy.getCurrentPosition();\r\n\r\n        battleTimeInfo.beginTime = uint64(block.timestamp);\r\n\r\n        bool isCultistsAttacked = _isCultistsArmy(attackedArmyAddress);\r\n\r\n        if (!isCultistsAttacked) {\r\n            if (_isArmyUnitsExceeds(attackedArmyAddress, maxUnitTypeIdsToAttack, maxUnitsToAttack)) revert BattleCannotBeCreatedWhenArmyUnitsExceedDesiredAmountToAttack();\r\n        } else {\r\n            uint256 totalUnitsToAttack = 0;\r\n\r\n            for (uint256 i = 0; i < maxUnitTypeIdsToAttack.length; i++) {\r\n                bytes32 unitTypeId = maxUnitTypeIdsToAttack[i];\r\n                uint256 maxUnitAmountToAttack = maxUnitsToAttack[i];\r\n\r\n                battleWithCultistsInitiationInfo.maxUnitTypeIdsToAttack.push(maxUnitTypeIdsToAttack[i]);\r\n                battleWithCultistsInitiationInfo.maxUnitsToAttack.push(maxUnitsToAttack[i]);\r\n\r\n                totalUnitsToAttack += maxUnitAmountToAttack;\r\n            }\r\n\r\n            if (totalUnitsToAttack == 0) revert BattleCannotBeCreatedByDesiringToAttackCultistsArmyWithoutUnits();\r\n        }\r\n\r\n        (, uint64 attackedArmyManeuverEndTime,,,) = attackedArmy.maneuverInfo();\r\n\r\n        uint256 maxBattleDuration = 0;\r\n        // If attackedArmy maneuvering openly (has endTime and its bigger than battle begin time) -> battle duration is reduced\r\n        if (attackedArmyManeuverEndTime > battleTimeInfo.beginTime) {\r\n            maxBattleDuration = attackedArmyManeuverEndTime - battleTimeInfo.beginTime;\r\n\r\n            // However it cannot be reduced lower than minimum battle duration\r\n            if (maxBattleDuration < registry().getMinimumBattleDuration()) revert BattleCannotBeCreatedWhenAttackedArmyIsAlmostOnAnotherPosition();\r\n        }\r\n\r\n        battleTimeInfo.duration = getBattleDuration(\r\n            isCultistsAttacked,\r\n            maxBattleDuration,\r\n            _calculateUnitsAmount(attackerArmyAddress),\r\n            _calculateUnitsAmount(attackedArmyAddress)\r\n        );\r\n\r\n        attackerArmy.joinBattle(address(this), 1);\r\n        attackedArmy.joinBattle(address(this), 2);\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function isLobbyTime() public view override returns (bool) {\r\n        uint256 _gameEndTime = world().gameEndTime();\r\n        uint256 currentTimestamp = _gameEndTime == 0 ? block.timestamp : Math.min(block.timestamp, _gameEndTime);\r\n\r\n        uint256 lobbyEndTime = battleTimeInfo.beginTime + battleTimeInfo.duration;\r\n        return currentTimestamp >= battleTimeInfo.beginTime && currentTimestamp < lobbyEndTime;\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function acceptArmyInBattle(\r\n        address armyAddress,\r\n        uint256 side\r\n    ) public override onlyWorldAssetFromSameEra {\r\n        bytes32[] memory allUnitTypeIds = registry().getUnitTypeIds();\r\n\r\n        // 1. Add units to battle based on army type\r\n        // If cultists -> add selected amount\r\n        // Else -> Add all\r\n        bool isCultistsArmy = _isCultistsArmy(armyAddress);\r\n        bytes32[] memory unitTypeIds = isCultistsArmy\r\n            ? battleWithCultistsInitiationInfo.maxUnitTypeIdsToAttack\r\n            : allUnitTypeIds;\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n\r\n            uint256 actualUnitsAmount = era().units(unitTypeId).balanceOf(armyAddress);\r\n            uint256 amountOfUnitsToJoinBattle = actualUnitsAmount;\r\n\r\n            if (isCultistsArmy) {\r\n                uint256 desiredUnitsAmount = battleWithCultistsInitiationInfo.maxUnitsToAttack[i];\r\n                if (actualUnitsAmount < desiredUnitsAmount) revert BattleCannotAcceptCultistsArmyWhenCultistsAmountChangedToLowerValueThanDesired();\r\n\r\n                amountOfUnitsToJoinBattle = desiredUnitsAmount;\r\n            }\r\n\r\n            uint256 additionalUnitMultiplier = IArmy(armyAddress).additionalUnitsBattleMultipliers(unitTypeId);\r\n            uint256 multipliedUnitsAmount = amountOfUnitsToJoinBattle * (1e18 + additionalUnitMultiplier) / 1e18;\r\n\r\n            sideUnitsAmount[side][unitTypeId] += multipliedUnitsAmount;\r\n            armyUnitsAmount[armyAddress][unitTypeId] = multipliedUnitsAmount;\r\n            armyUnitsAdditionalMultipliers[armyAddress][unitTypeId] = additionalUnitMultiplier;\r\n        }\r\n\r\n        // 2. Check if opposite side has units in order to launch battle casualties calculation\r\n        bool hasUnitsInOppositeSide = false;\r\n        uint256 oppositeSide = side == 1 ? 2 : 1;\r\n        for (uint256 i = 0; i < allUnitTypeIds.length; i++) {\r\n            if (sideUnitsAmount[oppositeSide][allUnitTypeIds[i]] > 0) {\r\n                hasUnitsInOppositeSide = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        armySide[armyAddress] = side;\r\n\r\n        if (hasUnitsInOppositeSide) {\r\n            _calculateAndSaveCasualties();\r\n        }\r\n\r\n        emit ArmyJoined(armyAddress, side);\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function canEndBattle() public view override returns (bool) {\r\n        uint256 _gameEndTime = world().gameEndTime();\r\n        uint256 currentTimestamp = _gameEndTime == 0 ? block.timestamp : Math.min(block.timestamp, _gameEndTime);\r\n\r\n        return battleTimeInfo.beginTime > 0 && currentTimestamp >= battleTimeInfo.beginTime + battleTimeInfo.duration;\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function isEndedBattle() public view override returns (bool) {\r\n        return battleTimeInfo.endTime != 0;\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function calculateArmyCasualties(address armyAddress)\r\n        public\r\n        view\r\n        override\r\n        returns (bool, uint256[] memory)\r\n    {\r\n        uint256 side = armySide[armyAddress];\r\n\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n\r\n        uint256[] memory result = new uint256[](unitTypeIds.length);\r\n\r\n        bool isArmyWon = side == winningSide;\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n\r\n            uint256 _sideUnitsAmount = sideUnitsAmount[side][unitTypeId];\r\n            uint256 _armyUnitsAmount = armyUnitsAmount[armyAddress][unitTypeId];\r\n\r\n            if (_sideUnitsAmount == 0 || _armyUnitsAmount == 0) {\r\n                continue;\r\n            }\r\n\r\n            uint256 percent = (_armyUnitsAmount * 1e18) / _sideUnitsAmount;\r\n            uint256 sideUnitsCasualties = casualties[side][unitTypeId];\r\n            uint256 armyUnitMultiplier = 1e18 + armyUnitsAdditionalMultipliers[armyAddress][unitTypeId];\r\n\r\n            uint256 armyCasualties = (sideUnitsCasualties * percent) / armyUnitMultiplier;\r\n\r\n            if (armyCasualties == 0) {\r\n                continue;\r\n            }\r\n\r\n            uint256 integerArmyCasualties = MathExtension.roundDownWithPrecision(armyCasualties, 1e18);\r\n            if (!isArmyWon) {\r\n                uint256 roundedUpIntegerArmyCasualties = MathExtension.roundUpWithPrecision(armyCasualties, 1e18);\r\n                integerArmyCasualties = _armyUnitsAmount >= roundedUpIntegerArmyCasualties\r\n                    ? roundedUpIntegerArmyCasualties\r\n                    : integerArmyCasualties;\r\n            }\r\n\r\n            result[i] = integerArmyCasualties;\r\n        }\r\n\r\n        return (isArmyWon, result);\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function calculateBattleDuration(\r\n        uint256 globalMultiplier,\r\n        uint256 baseBattleDuration,\r\n        uint256 minimumBattleDuration,\r\n        bool isCultistsAttacked,\r\n        uint256 side1UnitsAmount,\r\n        uint256 side2UnitsAmount,\r\n        uint256 maxBattleDuration\r\n    ) public view override returns (uint64) {\r\n        if (side1UnitsAmount == 0 || side2UnitsAmount == 0) revert BattleCannotBeCreatedWithArmiesHavingZeroUnits();\r\n\r\n        uint64 battleDuration = uint64(baseBattleDuration / globalMultiplier);\r\n        if (!isCultistsAttacked) {\r\n            if (side1UnitsAmount >= side2UnitsAmount && side1UnitsAmount / side2UnitsAmount > 1) {\r\n                battleDuration = uint64(battleDuration * 2 * side2UnitsAmount / side1UnitsAmount);\r\n            }\r\n\r\n            if (side2UnitsAmount > side1UnitsAmount && side2UnitsAmount / side1UnitsAmount > 1) {\r\n                battleDuration = uint64(battleDuration * 2 * side1UnitsAmount / side2UnitsAmount);\r\n            }\r\n        }\r\n\r\n        if (maxBattleDuration != 0 && maxBattleDuration < battleDuration) {\r\n            battleDuration = uint64(maxBattleDuration);\r\n        }\r\n\r\n        if (battleDuration < minimumBattleDuration) {\r\n            battleDuration = uint64(minimumBattleDuration);\r\n        }\r\n\r\n        return battleDuration;\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function getBattleDuration(\r\n        bool isCultistsAttacked,\r\n        uint256 maxBattleDuration,\r\n        uint256 side1UnitsAmount,\r\n        uint256 side2UnitsAmount\r\n    ) public view override returns (uint64) {\r\n        uint256 globalMultiplier = registry().getGlobalMultiplier();\r\n        uint256 baseBattleDuration = registry().getBaseBattleDuration();\r\n        uint256 minimumBattleDuration = registry().getMinimumBattleDuration();\r\n\r\n        return calculateBattleDuration(\r\n            globalMultiplier,\r\n            baseBattleDuration,\r\n            minimumBattleDuration,\r\n            isCultistsAttacked,\r\n            side1UnitsAmount,\r\n            side2UnitsAmount,\r\n            maxBattleDuration\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function endBattle() public override {\r\n        if (!canEndBattle()) revert BattleCannotBeFinishedAtThisTime();\r\n        if (isEndedBattle()) revert BattleCannotBeFinishedMoreThanOnce();\r\n\r\n        battleTimeInfo.endTime = uint64(battleTimeInfo.beginTime + battleTimeInfo.duration);\r\n\r\n        emit BattleEnded(battleTimeInfo.endTime);\r\n\r\n        // In case if battle is ended on cultists position & cultists are in this battle\r\n        // => update cultists army state (aka remove them from ended battle)\r\n        ISettlement settlementOnThisPosition = era().settlementByPosition(position);\r\n        bytes32 settlementAssetTypeId = IWorldAssetStorageAccessor(address(settlementOnThisPosition)).assetTypeId();\r\n\r\n        if (settlementAssetTypeId == CULTISTS_SETTLEMENT_TYPE_ID) {\r\n            IArmy cultistsArmy = settlementOnThisPosition.army();\r\n            if (address(cultistsArmy.battle()) == address(this)) {\r\n                cultistsArmy.updateState();\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function calculateStage1Casualties()\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint256[] memory _side1Casualties,\r\n            uint256[] memory _side2Casualties,\r\n            bytes memory stageParams\r\n        )\r\n    {\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n\r\n        _side1Casualties = new uint256[](unitTypeIds.length);\r\n        _side2Casualties = new uint256[](unitTypeIds.length);\r\n\r\n        uint256 side1Offense;\r\n        uint256 side2Offense;\r\n\r\n        uint256 side1Defence;\r\n        uint256 side2Defence;\r\n\r\n        // 1st stage\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n\r\n            IRegistry.UnitStats memory unitStats = registry().getUnitStats(unitTypeId);\r\n\r\n            side1Offense += sideUnitsAmount[1][unitTypeId] * unitStats.offenseStage1 * 1e18;\r\n            side2Offense += sideUnitsAmount[2][unitTypeId] * unitStats.offenseStage1 * 1e18;\r\n\r\n            side1Defence += sideUnitsAmount[1][unitTypeId] * unitStats.defenceStage1 * 1e18;\r\n            side2Defence += sideUnitsAmount[2][unitTypeId] * unitStats.defenceStage1 * 1e18;\r\n        }\r\n\r\n        stageParams = abi.encode(side1Offense, side2Offense, side1Defence, side2Defence);\r\n\r\n        uint256 side1LossPercentageAfterStage1 = _calculateSideLossPercentage(\r\n            side2Offense,\r\n            side1Defence,\r\n            battleTimeInfo.duration,\r\n            registry().getBaseBattleDuration() / registry().getGlobalMultiplier()\r\n        );\r\n\r\n        uint256 side2LossPercentageAfterStage1 = _calculateSideLossPercentage(\r\n            side1Offense,\r\n            side2Defence,\r\n            battleTimeInfo.duration,\r\n            registry().getBaseBattleDuration() / registry().getGlobalMultiplier()\r\n        );\r\n\r\n        // 2nd stage\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n\r\n            uint256 side1UnitsLost = (sideUnitsAmount[1][unitTypeId] * side1LossPercentageAfterStage1) / 1e18;\r\n            if (side1UnitsLost > sideUnitsAmount[1][unitTypeId]) {\r\n                _side1Casualties[i] = sideUnitsAmount[1][unitTypeId];\r\n            } else {\r\n                _side1Casualties[i] = side1UnitsLost;\r\n            }\r\n\r\n            uint256 side2UnitsLost = (sideUnitsAmount[2][unitTypeId] * side2LossPercentageAfterStage1) / 1e18;\r\n            if (side2UnitsLost > sideUnitsAmount[2][unitTypeId]) {\r\n                _side2Casualties[i] = sideUnitsAmount[2][unitTypeId];\r\n            } else {\r\n                _side2Casualties[i] = side2UnitsLost;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function calculateStage2Casualties(\r\n        uint256[] memory stage1Side1Casualties,\r\n        uint256[] memory stage1Side2Casualties\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint256[] memory _side1Casualties,\r\n            uint256[] memory _side2Casualties,\r\n            bytes memory stageParams\r\n        )\r\n    {\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n\r\n        _side1Casualties = new uint256[](unitTypeIds.length);\r\n        _side2Casualties = new uint256[](unitTypeIds.length);\r\n\r\n        uint256 side1Offense;\r\n        uint256 side2Offense;\r\n\r\n        uint256 side1Defence;\r\n        uint256 side2Defence;\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n\r\n            IRegistry.UnitStats memory unitStats = registry().getUnitStats(unitTypeId);\r\n\r\n            uint256 unitsARemaining = sideUnitsAmount[1][unitTypeId] - stage1Side1Casualties[i];\r\n            uint256 unitsBRemaining = sideUnitsAmount[2][unitTypeId] - stage1Side2Casualties[i];\r\n\r\n            side1Offense += unitsARemaining * unitStats.offenseStage2 * 1e18;\r\n            side2Offense += unitsBRemaining * unitStats.offenseStage2 * 1e18;\r\n\r\n            side1Defence += unitsARemaining * unitStats.defenceStage2 * 1e18;\r\n            side2Defence += unitsBRemaining * unitStats.defenceStage2 * 1e18;\r\n        }\r\n\r\n        stageParams = abi.encode(side1Offense, side2Offense, side1Defence, side2Defence);\r\n\r\n        // In case if no units left in either side -> no stage 2 casualties\r\n        if (side1Defence == 0 || side2Defence == 0) {\r\n            return (\r\n                _side1Casualties,\r\n                _side2Casualties,\r\n                stageParams\r\n            );\r\n        }\r\n\r\n        uint256 side1LossPercentageAfterStage2 = _calculateSideLossPercentage(\r\n            side2Offense,\r\n            side1Defence,\r\n            battleTimeInfo.duration,\r\n            registry().getBaseBattleDuration() / registry().getGlobalMultiplier()\r\n        );\r\n\r\n        uint256 side2LossPercentageAfterStage2 = _calculateSideLossPercentage(\r\n            side1Offense,\r\n            side2Defence,\r\n            battleTimeInfo.duration,\r\n            registry().getBaseBattleDuration() / registry().getGlobalMultiplier()\r\n        );\r\n\r\n       // result\r\n       for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n           bytes32 unitTypeId = unitTypeIds[i];\r\n\r\n           {\r\n               uint256 side1Units = sideUnitsAmount[1][unitTypeId] - stage1Side1Casualties[i];\r\n               uint256 side1UnitsLost = (side1Units * side1LossPercentageAfterStage2) / 1e18;\r\n               if (side1UnitsLost >= side1Units) {\r\n                   _side1Casualties[i] = side1Units;\r\n               } else {\r\n                   _side1Casualties[i] = side1UnitsLost;\r\n               }\r\n           }\r\n\r\n           {\r\n               uint256 side2Units = sideUnitsAmount[2][unitTypeId] - stage1Side2Casualties[i];\r\n               uint256 side2UnitsLost = (side2Units * side2LossPercentageAfterStage2) / 1e18;\r\n               if (side2UnitsLost >= side2Units) {\r\n                   _side2Casualties[i] = side2Units;\r\n               } else {\r\n                   _side2Casualties[i] = side2UnitsLost;\r\n               }\r\n           }\r\n       }\r\n    }\r\n\r\n    /// @inheritdoc IBattle\r\n    function calculateAllCasualties()\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256 //Winning side (0 - both sides lost, 1 - side A Won, 2 - side B Won\r\n        )\r\n    {\r\n        //calculate stage1 casualties (based on initial sides)\r\n        (\r\n            uint256[] memory stage1Side1Casualties,\r\n            uint256[] memory stage1Side2Casualties,\r\n            bytes memory stage1Params\r\n        ) = calculateStage1Casualties();\r\n\r\n        //calculate stage2 casualties (based on (initial-stage1Losses))\r\n        (\r\n            uint256[] memory stage2Side1Casualties,\r\n            uint256[] memory stage2Side2Casualties,\r\n            bytes memory stage2Params\r\n        ) = calculateStage2Casualties(\r\n            stage1Side1Casualties,\r\n            stage1Side2Casualties\r\n        );\r\n\r\n        uint256 calculatedWinningSide = _calculateWinningSide(\r\n            stage1Params,\r\n            stage2Params\r\n        );\r\n\r\n        uint256[] memory side1Casualties = new uint256[](stage1Side1Casualties.length);\r\n        uint256[] memory side2Casualties = new uint256[](stage1Side2Casualties.length);\r\n\r\n        for (uint256 i = 0; i < stage1Side1Casualties.length; i++) {\r\n            side1Casualties[i] = stage1Side1Casualties[i] + stage2Side1Casualties[i];\r\n            side2Casualties[i] = stage1Side2Casualties[i] + stage2Side2Casualties[i];\r\n        }\r\n\r\n        return (side1Casualties, side2Casualties, calculatedWinningSide);\r\n    }\r\n\r\n    /// @dev Calculate side loss percentage (in 1e18 precision)\r\n    function _calculateSideLossPercentage(\r\n        uint256 sideOffence,\r\n        uint256 sideDefence,\r\n        uint256 battleDuration,\r\n        uint256 baseBattleDuration\r\n    ) internal pure returns (uint256) {\r\n        uint256 loweredByBattleTimeOffence = (sideOffence * battleDuration) / baseBattleDuration;\r\n        return (loweredByBattleTimeOffence * 1e18) / sideDefence;\r\n    }\r\n\r\n    /// @dev Calculates total amount of units of specified army\r\n    function _calculateUnitsAmount(address armyAddress) internal view returns (uint256) {\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n\r\n        uint256 unitsAmount = 0;\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n            unitsAmount += era().units(unitTypeId).balanceOf(armyAddress);\r\n        }\r\n\r\n        return unitsAmount;\r\n    }\r\n\r\n    /// @dev Calculates and saves casualties\r\n    function _calculateAndSaveCasualties() internal {\r\n        (\r\n            uint256[] memory _side1Casualties,\r\n            uint256[] memory _side2Casualties,\r\n            uint256 _winningSide\r\n        ) = calculateAllCasualties();\r\n\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n\r\n            casualties[1][unitTypeId] = _side1Casualties[i];\r\n            casualties[2][unitTypeId] = _side2Casualties[i];\r\n        }\r\n\r\n        winningSide = _winningSide;\r\n    }\r\n\r\n    /// @dev Calculates winning side by side-stage params\r\n    function _calculateWinningSide(\r\n        bytes memory stage1Params,\r\n        bytes memory stage2Params\r\n    ) internal view returns (uint256) {\r\n        (\r\n            uint256 stage1Side1Offence,\r\n            uint256 stage1Side2Offence,\r\n            uint256 stage1Side1Defence,\r\n            uint256 stage1Side2Defence\r\n        ) = abi.decode(stage1Params, (uint256, uint256, uint256, uint256));\r\n\r\n        (\r\n            uint256 stage2Side1Offence,\r\n            uint256 stage2Side2Offence,\r\n            uint256 stage2Side1Defence,\r\n            uint256 stage2Side2Defence\r\n        ) = abi.decode(stage2Params, (uint256, uint256, uint256, uint256));\r\n\r\n        uint256 calculatedWinningSide = 0;\r\n\r\n        // Loss coefficient split in 2 because, for example, in 1st stage there could be no units left in either side\r\n        // And this means -> no second stage\r\n        uint256 side1LossCoefficient = stage1Side2Offence * 1e18 / stage1Side1Defence;\r\n        uint256 side2LossCoefficient = stage1Side1Offence * 1e18 / stage1Side2Defence;\r\n\r\n        if (stage2Side1Defence > 0 && stage2Side2Defence > 0) {\r\n            side1LossCoefficient += stage2Side2Offence * 1e18 / stage2Side1Defence;\r\n            side2LossCoefficient += stage2Side1Offence * 1e18 / stage2Side2Defence;\r\n        }\r\n\r\n        if (side1LossCoefficient > side2LossCoefficient) {\r\n            calculatedWinningSide = 2;\r\n        }\r\n\r\n        if (side1LossCoefficient < side2LossCoefficient) {\r\n            calculatedWinningSide = 1;\r\n        }\r\n\r\n        return calculatedWinningSide;\r\n    }\r\n\r\n    /// @dev Checks if provided army address belongs to cultists settlement or not\r\n    function _isCultistsArmy(address armyAddress) internal view returns (bool) {\r\n        address armiesSettlementAddress = address(IArmy(armyAddress).relatedSettlement());\r\n        return IWorldAssetStorageAccessor(armiesSettlementAddress).assetTypeId() == CULTISTS_SETTLEMENT_TYPE_ID;\r\n    }\r\n\r\n    /// @dev Calculates if provided army has more than specified units\r\n    function _isArmyUnitsExceeds(\r\n        address armyAddress,\r\n        bytes32[] memory unitTypeIds,\r\n        uint256[] memory maxUnits\r\n    ) internal view returns (bool) {\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            uint256 balance = era().units(unitTypeIds[i]).balanceOf(armyAddress);\r\n            if (balance > maxUnits[i]) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/battle/IBattle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../IWorld.sol\";\r\n\r\n/// @title Battle interface\r\n/// @notice Functions to read state/modify state in order to get current battle parameters and/or interact with it\r\ninterface IBattle {\r\n    struct BattleTimeInfo {\r\n        uint64 beginTime;\r\n        uint64 duration;\r\n        uint64 endTime;\r\n    }\r\n\r\n    // State variables\r\n\r\n    /// @notice Position at which battle is being held\r\n    /// @dev Immutable, initialized on the battle creation\r\n    function position() external view returns (uint64);\r\n\r\n    /// @notice Mapping that contains units amount by side and unit type\r\n    /// @dev Updated when army joins side\r\n    /// @param side Side of which query units amount (sideA = 1, sideB = 2)\r\n    /// @param unitTypeId Unit type id\r\n    /// @return unitsAmount Amount of units by specified side and unit type\r\n    function sideUnitsAmount(uint256 side, bytes32 unitTypeId) external view returns (uint256 unitsAmount);\r\n\r\n    /// @notice Mapping that contains amount of units by army address and unit type\r\n    /// @dev Updated when army joins battle\r\n    /// @param armyAddress Army address\r\n    /// @param unitTypeId Unit type id\r\n    /// @return unitsAmount Amount of units by army address and unit type\r\n    function armyUnitsAmount(address armyAddress, bytes32 unitTypeId) external view returns (uint256 unitsAmount);\r\n\r\n    /// @notice Mapping that contains unit multiplier by army address and unit type\r\n    /// @dev Updated when army joins battle\r\n    /// @param armyAddress Army address\r\n    /// @param unitTypeId Unit type id\r\n    /// @return unitAmountMultiplier Unit amount multiplier\r\n    function armyUnitsAdditionalMultipliers(address armyAddress, bytes32 unitTypeId) external view returns (uint256 unitAmountMultiplier);\r\n\r\n    /// @notice Mapping that contains amount of casualties\r\n    /// @dev Updated when #acceptArmyInBattle is called\r\n    /// @param side Side of which query casualties amount (sideA = 1, sideB = 2)\r\n    /// @param unitTypeId Unit type id\r\n    /// @return casualtiesCount Amount of casualties by side and unit type\r\n    function casualties(uint256 side, bytes32 unitTypeId) external view returns (uint256 casualtiesCount);\r\n\r\n    /// @notice Mapping that contains side at which joined army is on\r\n    /// @dev Updated when #acceptArmyInBattle is called\r\n    /// @param armyAddress Army address\r\n    /// @return armySide Side of specified army (sideA = 1, sideB = 2)\r\n    function armySide(address armyAddress) external view returns (uint256 armySide);\r\n\r\n    /// @notice Battle time info\r\n    /// @dev Updated when battle initialized, first armies joined and ended (#initBattle, #acceptArmyInBattle, #endBattle)\r\n    /// @return beginTime Time when battle is began\r\n    /// @return duration Battle duration, initialized when first two armies joined\r\n    /// @return endTime Time when battle is ended\r\n    function battleTimeInfo()\r\n        external\r\n        view\r\n        returns (\r\n            uint64 beginTime,\r\n            uint64 duration,\r\n            uint64 endTime\r\n        );\r\n\r\n    /// @notice Winning side\r\n    /// @dev Updated when #endBattle is called\r\n    /// @return winningSide Winning side (no winner = 0, sideA = 1, sideB = 2)\r\n    function winningSide() external view returns (uint256 winningSide);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when army joined battle\r\n    /// @param armyAddress Address of the joined army\r\n    /// @param side Side to which army is joined (sideA = 1, sideB = 2)\r\n    event ArmyJoined(address armyAddress, uint256 side);\r\n\r\n    /// @notice Emitted when #endBattle is called\r\n    /// @param endTime Time at which battle is ended\r\n    event BattleEnded(uint256 endTime);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to begin battle by attacking army with MAX amount of units to attack, but their value increased to more than MAX\r\n    error BattleCannotBeCreatedWhenArmyUnitsExceedDesiredAmountToAttack();\r\n\r\n    /// @notice Thrown when attempting to begin battle by attacking cultists army with desire to draw zero units to the battle\r\n    error BattleCannotBeCreatedByDesiringToAttackCultistsArmyWithoutUnits();\r\n\r\n    /// @notice Thrown when attempting to begin battle with armies either of which has zero units\r\n    error BattleCannotBeCreatedWithArmiesHavingZeroUnits();\r\n\r\n    /// @notice Thrown when attempting to start battle by attacking army when maneuver duration left less than minimum battle duration\r\n    error BattleCannotBeCreatedWhenAttackedArmyIsAlmostOnAnotherPosition();\r\n\r\n    /// @notice Thrown when attempting to accept cultists army to the battle but their amount got smaller than desired to attack\r\n    error BattleCannotAcceptCultistsArmyWhenCultistsAmountChangedToLowerValueThanDesired();\r\n\r\n    /// @notice Thrown when attempting to finish battle while time for it has not yet come\r\n    error BattleCannotBeFinishedAtThisTime();\r\n\r\n    /// @notice Thrown when attempting to finish battle when it is already finished\r\n    error BattleCannotBeFinishedMoreThanOnce();\r\n\r\n    // Functions\r\n\r\n    /// @notice Accepts army in battle\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param armyAddress Army address\r\n    /// @param side Side to which army will join\r\n    function acceptArmyInBattle(address armyAddress, uint256 side) external;\r\n\r\n    /// @notice Ends battle\r\n    /// @dev Sets end time\r\n    function endBattle() external;\r\n\r\n    /// @notice Calculates casualties for first battle stage\r\n    /// @dev Uses values from battles' sideUnitsAmount in order to calculate casualties (can be executed while battle is still not fully formed)\r\n    /// @return sideACasualties Side A casualties\r\n    /// @return sideBCasualties Side B casualties\r\n    /// @return stageParams Stage params (encoded abi.encode(sideAOffense, sideBOffense, sideADefence, sideBDefence))\r\n    function calculateStage1Casualties()\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory sideACasualties,\r\n            uint256[] memory sideBCasualties,\r\n            bytes memory stageParams\r\n        );\r\n\r\n    /// @notice Calculates casualties for second battle stage (based on casualties from first battle stage)\r\n    /// @dev Uses values from battles' sideUnitsAmount in order to calculate casualties (can be executed while battle is still not fully formed)\r\n    /// @param stage1SideACasualties Stage 1 side A casualties\r\n    /// @param stage1SideBCasualties Stage 1 side B casualties\r\n    /// @return sideACasualties Side A casualties\r\n    /// @return sideBCasualties Side B casualties\r\n    /// @return stageParams Stage params (encoded abi.encode(sideAOffense, sideBOffense, sideADefence, sideBDefence))\r\n    function calculateStage2Casualties(\r\n        uint256[] memory stage1SideACasualties,\r\n        uint256[] memory stage1SideBCasualties\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory sideACasualties,\r\n            uint256[] memory sideBCasualties,\r\n            bytes memory stageParams\r\n        );\r\n\r\n    /// @notice Calculates casualties for all battle stages\r\n    /// @dev Uses values from battles' sideUnitsAmount in order to calculate casualties (can be executed while battle is still not fully formed)\r\n    /// @return sideACasualties Side A casualties\r\n    /// @return sideBCasualties Side A casualties\r\n    /// @return winningSide Winning side (0 - both sides lost, 1 - side A Won, 2 - side B Won\r\n    function calculateAllCasualties()\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory sideACasualties,\r\n            uint256[] memory sideBCasualties,\r\n            uint256 winningSide\r\n        );\r\n\r\n    /// @notice Calculates battle duration\r\n    /// @dev Returns same value as #calculateBattlesDuration but without the need to provide all parameters\r\n    /// @param isCultistsAttacked Is cultists attacked\r\n    /// @param maxBattleDuration Max allowed battle duration\r\n    /// @param sideAUnitsAmount Side A units amount\r\n    /// @param sideBUnitsAmount Side B units amount\r\n    /// @return battleDuration Battle duration\r\n    function getBattleDuration(\r\n        bool isCultistsAttacked,\r\n        uint256 maxBattleDuration,\r\n        uint256 sideAUnitsAmount,\r\n        uint256 sideBUnitsAmount\r\n    ) external view returns (uint64 battleDuration);\r\n\r\n    /// @notice Calculates if battle can be ended\r\n    /// @dev Checks if endTime is set and current block.timestamp > beginTime + duration\r\n    /// @return canEndBattle Can battle be ended\r\n    function canEndBattle() external view returns (bool canEndBattle);\r\n\r\n    /// @notice Calculates if battle is ended\r\n    /// @dev Checks if endTime is not zero\r\n    /// @return isEndedBattle Is ended battle\r\n    function isEndedBattle() external view returns (bool isEndedBattle);\r\n\r\n    /// @notice Calculates casualties for specified army\r\n    /// @dev Provides valid results only for ended battle\r\n    /// @param armyAddress Address of army presented in battle\r\n    /// @return isArmyWon Is army won\r\n    /// @return unitsAmounts Amount of casualties for related unit types\r\n    function calculateArmyCasualties(address armyAddress)\r\n        external\r\n        view\r\n        returns (\r\n            bool isArmyWon,\r\n            uint256[] memory unitsAmounts\r\n        );\r\n\r\n    /// @notice Calculates if lobby is opened\r\n    /// @dev Calculates if lobby is opened\r\n    /// @return isLobbyTime Is lobby is opened\r\n    function isLobbyTime() external view returns (bool isLobbyTime);\r\n\r\n    /// @notice Calculates battle duration based on specified parameters\r\n    /// @dev globalMultiplier, baseBattleDuration parameters from registry\r\n    /// @param globalMultiplier Global multiplier (from registry)\r\n    /// @param baseBattleDuration Base battle duration (from registry)\r\n    /// @param minBattleDuration Minimum battle duration (from registry)\r\n    /// @param isCultistsAttacked Is cultists attacked\r\n    /// @param units1 Amount of units from attacker army\r\n    /// @param units2 Amount of units from attacked army\r\n    /// @param maxBattleDuration Max allowed battle duration\r\n    /// @return battleDuration Battle duration\r\n    function calculateBattleDuration(\r\n        uint256 globalMultiplier,\r\n        uint256 baseBattleDuration,\r\n        uint256 minBattleDuration,\r\n        bool isCultistsAttacked,\r\n        uint256 units1,\r\n        uint256 units2,\r\n        uint256 maxBattleDuration\r\n    ) external view returns (uint64 battleDuration);\r\n}\r\n"
    },
    "contracts/core/assets/building/Building.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"./IBuilding.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../../../const/GameAssetTypes.sol\";\r\n\r\nabstract contract Building is WorldAsset, ERC1155Receiver, IBuilding {\r\n    /// @inheritdoc IBuilding\r\n    ISettlement public override relatedSettlement;\r\n    /// @inheritdoc IBuilding\r\n    bytes32 public override buildingTypeId;\r\n    /// @inheritdoc IBuilding\r\n    BasicProduction public override basicProduction;\r\n    /// @inheritdoc IBuilding\r\n    AdvancedProduction public override advancedProduction;\r\n    /// @inheritdoc IBuilding\r\n    uint256 public override upgradeCooldownEndTime;\r\n    /// @inheritdoc IBuilding\r\n    uint256 public override givenProsperityAmount;\r\n    /// @inheritdoc IBuilding\r\n    ProductionInfo public override productionInfo;\r\n    /// @inheritdoc IBuilding\r\n    uint256 public override distributionId;\r\n    /// @inheritdoc IBuilding\r\n    mapping(address => uint256) public override producedResourceDebt;\r\n\r\n    /// @dev Only distributions contract modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyDistributions() {\r\n        _onlyDistributions();\r\n        _;\r\n    }\r\n\r\n    /// @dev Only settlement owner modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlySettlementOwner() {\r\n        _onlySettlementOwner();\r\n        _;\r\n    }\r\n\r\n    /// @dev Only ruler or world asset from same era modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyRulerOrWorldAssetFromSameEra() {\r\n        _onlyRulerOrWorldAssetFromSameEra();\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public virtual override initializer {\r\n        (\r\n            address settlementAddress,\r\n            bytes32 currentBuildingTypeId\r\n        ) = abi.decode(initParams, (address, bytes32));\r\n\r\n        relatedSettlement = ISettlement(settlementAddress);\r\n        buildingTypeId = currentBuildingTypeId;\r\n\r\n        basicProduction.level = 1;\r\n        basicProduction.coefficient = 1;\r\n\r\n        advancedProduction.level = 1;\r\n        advancedProduction.coefficient = 1;\r\n\r\n        _updateProductionInfo(\r\n            block.timestamp,\r\n            relatedSettlement.relatedRegion().getRegionTime(block.timestamp),\r\n            0,\r\n            0\r\n        );\r\n\r\n        _createDefaultDistribution();\r\n    }\r\n\r\n    /// @inheritdoc IERC1155Receiver\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        return IERC1155Receiver.onERC1155Received.selector;\r\n    }\r\n\r\n    /// @inheritdoc IERC1155Receiver\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function handleProductionResourcesChanged() public virtual override {\r\n        _updateProsperity();\r\n        advancedProduction.toBeProducedTicks = _calculateProductionTicksAmount();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function updateState() public virtual override {\r\n        relatedSettlement.relatedRegion().updateState();\r\n\r\n        uint256 currentTime = _getCurrentTime();\r\n        if (productionInfo.lastUpdateStateTime == currentTime) {\r\n            return;\r\n        }\r\n\r\n        ProductionResultItem[] memory productionResult = getProductionResult(currentTime);\r\n\r\n        _updateProductionInfo(\r\n            currentTime,\r\n            relatedSettlement.relatedRegion().getRegionTime(currentTime),\r\n            productionInfo.readyToBeDistributed,\r\n            productionInfo.totalDebt\r\n        );\r\n\r\n        for (uint256 i = 0; i < productionResult.length; i++) {\r\n            if (productionResult[i].balanceDelta == 0) {\r\n                continue;\r\n            }\r\n\r\n            if (productionResult[i].isProduced) {\r\n                _saveProducedResource(productionResult[i].resourceTypeId, productionResult[i].balanceDelta);\r\n            } else {\r\n                era().resources(productionResult[i].resourceTypeId).burn(productionResult[i].balanceDelta);\r\n            }\r\n        }\r\n\r\n        _updateProsperity();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function updateDebtsAccordingToNewDistributionsAmounts(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override onlyDistributions {\r\n        uint256 debtAmount = productionInfo.readyToBeDistributed * amount / world().distributions().getItemsPerNft();\r\n        if (debtAmount == 0) {\r\n            return;\r\n        }\r\n\r\n        _updateProducedResourceDebt(from, producedResourceDebt[from] - debtAmount);\r\n        _updateProducedResourceDebt(to, producedResourceDebt[to] + debtAmount);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function distributeToSingleShareholder(address holder) public override {\r\n        updateState();\r\n\r\n        IDistributions distributions = world().distributions();\r\n        uint256 nftBalance = distributions.balanceOf(holder, distributionId);\r\n        if (nftBalance == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 producedResourceDebtOfHolder = producedResourceDebt[holder];\r\n        uint256 partOfReadyToBeDistributed = productionInfo.readyToBeDistributed * nftBalance / distributions.getItemsPerNft();\r\n        uint256 partOfProduction = partOfReadyToBeDistributed > producedResourceDebtOfHolder\r\n            ? partOfReadyToBeDistributed - producedResourceDebtOfHolder\r\n            : 0;\r\n\r\n        if (partOfProduction == 0) {\r\n            return;\r\n        }\r\n\r\n        _updateProducedResourceDebt(holder, producedResourceDebtOfHolder + partOfProduction);\r\n\r\n        _updateProductionInfo(\r\n            productionInfo.lastUpdateStateTime,\r\n            productionInfo.lastUpdateStateRegionTime,\r\n            productionInfo.readyToBeDistributed,\r\n            productionInfo.totalDebt + partOfProduction\r\n        );\r\n\r\n        bytes32 productionResourceTypeId = getProducingResourceTypeId();\r\n        era().resources(productionResourceTypeId).mint(holder, partOfProduction);\r\n        emit DistributedToShareHolder(productionResourceTypeId, holder, partOfProduction);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function distributeToAllShareholders() public override {\r\n        updateState();\r\n\r\n        uint256 readyToBeDistributed = productionInfo.readyToBeDistributed;\r\n        bytes32 producingResourceTypeId = getProducingResourceTypeId();\r\n        IResource producingResource = era().resources(producingResourceTypeId);\r\n        IDistributions distributions = world().distributions();\r\n        uint256 itemsPerNft = distributions.getItemsPerNft();\r\n\r\n        uint256 newReadyToBeDistributed = readyToBeDistributed;\r\n        address[] memory topHolders = world().distributions().getDistributionReceivers(distributionId);\r\n        for (uint256 i = 0; i < topHolders.length; i++) {\r\n            address holder = topHolders[i];\r\n\r\n            uint256 holderDebt = producedResourceDebt[holder];\r\n            uint256 partOfReadyToBeDistributed = (readyToBeDistributed * distributions.balanceOf(holder, distributionId)) / itemsPerNft;\r\n            uint256 partOfProduction = partOfReadyToBeDistributed > holderDebt\r\n                ? partOfReadyToBeDistributed - holderDebt\r\n                : 0;\r\n\r\n            if (holderDebt != 0) {\r\n                _updateProducedResourceDebt(holder, 0);\r\n            }\r\n\r\n            newReadyToBeDistributed -= (holderDebt + partOfProduction);\r\n\r\n            if (partOfProduction == 0) {\r\n                continue;\r\n            }\r\n\r\n            producingResource.mint(holder, partOfProduction);\r\n            emit DistributedToShareHolder(producingResourceTypeId, holder, partOfProduction);\r\n        }\r\n\r\n        _updateProductionInfo(\r\n            productionInfo.lastUpdateStateTime,\r\n            productionInfo.lastUpdateStateRegionTime,\r\n            newReadyToBeDistributed,\r\n            0\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getResourcesAmount(bytes32 resourceTypeId, uint256 timestamp)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        ProductionResultItem[] memory result = getProductionResult(timestamp);\r\n\r\n        for (uint256 i = 0; i < result.length; i++) {\r\n            if (result[i].resourceTypeId == resourceTypeId) {\r\n                if (result[i].isProduced) {\r\n                    uint256 maxTreasury = getMaxTreasuryByLevel(getBuildingLevel());\r\n                    if (maxTreasury == 0) {\r\n                        return 0;\r\n                    }\r\n\r\n                    uint256 amountOfResourcePotentiallyGoingToTreasury = (result[i].balanceDelta * registry().getToTreasuryPercent()) / 1e18;\r\n                    uint256 currentTreasuryResourcesAmount = era().resources(getProducingResourceTypeId()).stateBalanceOf(address(this));\r\n\r\n                    // In case if building has more resources than max in treasury -> none of production resources will go to the treasury\r\n                    // therefore building doesnt produced anything to the building\r\n                    if (currentTreasuryResourcesAmount >= maxTreasury) {\r\n                        return currentTreasuryResourcesAmount;\r\n                    }\r\n\r\n                    return Math.min(\r\n                        amountOfResourcePotentiallyGoingToTreasury + currentTreasuryResourcesAmount,\r\n                        maxTreasury\r\n                    );\r\n                } else {\r\n                    return era().resources(resourceTypeId).stateBalanceOf(address(this)) - result[i].balanceDelta;\r\n                }\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getProductionResult(uint256 timestamp)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (ProductionResultItem[] memory)\r\n    {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        uint256 gameBeginTime = world().gameBeginTime();\r\n        if (timestamp < gameBeginTime) {\r\n            timestamp = gameBeginTime;\r\n        }\r\n\r\n        uint256 gameEndTime = world().gameEndTime();\r\n        if (gameEndTime != 0) {\r\n            timestamp = Math.min(timestamp, gameEndTime);\r\n        }\r\n\r\n        ProductionConfigItem[] memory productionConfigItems = getConfig();\r\n        ProductionResultItem[] memory productionResult = new ProductionResultItem[](productionConfigItems.length);\r\n        for (uint256 i = 0; i < productionConfigItems.length; i++) {\r\n            productionResult[i] = ProductionResultItem({\r\n                resourceTypeId: productionConfigItems[i].resourceTypeId,\r\n                isProduced: productionConfigItems[i].isProducing,\r\n                balanceDelta: 0\r\n            });\r\n        }\r\n\r\n        uint256 productionLastUpdateStateTime = productionInfo.lastUpdateStateTime;\r\n        uint256 productionLastUpdateStateRegionTime = productionInfo.lastUpdateStateRegionTime;\r\n\r\n        if (productionLastUpdateStateTime < gameBeginTime) {\r\n            productionLastUpdateStateTime = gameBeginTime;\r\n            productionLastUpdateStateRegionTime = 0;\r\n        }\r\n\r\n        if (timestamp <= productionLastUpdateStateTime) {\r\n            return productionResult;\r\n        }\r\n\r\n        uint256 regionTime = relatedSettlement.relatedRegion().getRegionTime(timestamp);\r\n\r\n        uint256 producedTicksByBasicProduction = _getProducedTicksByBasicProduction(\r\n            productionLastUpdateStateRegionTime,\r\n            regionTime\r\n        );\r\n\r\n        uint256 producedTicksByAdvancedProduction = _getProducedTicksByAdvancedProduction(\r\n            productionLastUpdateStateRegionTime,\r\n            regionTime,\r\n            advancedProduction.toBeProducedTicks\r\n        );\r\n\r\n        for (uint256 i = 0; i < productionConfigItems.length; i++) {\r\n            productionResult[i].balanceDelta = productionConfigItems[i].amountPerTick * producedTicksByAdvancedProduction;\r\n\r\n            // Produced value increased here because basic production does not stop and building upgrades through time\r\n            if (productionResult[i].isProduced) {\r\n                productionResult[i].balanceDelta += productionConfigItems[i].amountPerTick * producedTicksByBasicProduction;\r\n            }\r\n        }\r\n\r\n        return productionResult;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getBuildingCoefficient(uint256 level) public override pure returns (uint256) {\r\n        uint256 increaseByEveryNLevels = 5;\r\n        uint256 b = level / increaseByEveryNLevels;\r\n        uint256 c = level - b * increaseByEveryNLevels;\r\n        uint256 d = (((b + 1) * b) / 2) * increaseByEveryNLevels;\r\n        uint256 e = d + c * (b + 1);\r\n        return e;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function resetDistribution() public override virtual onlySettlementOwner {\r\n        if (!_isBuildingTokenRecallAllowed()) revert DistributionResetNotAllowedWhenTreasuryThresholdNotMet();\r\n        distributeToAllShareholders();\r\n        _createDefaultDistribution();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function isResourceAcceptable(bytes32 resourceTypeId) public view override returns (bool) {\r\n        ProductionConfigItem[] memory config = getConfig();\r\n        for (uint256 i = 0; i < config.length; i++) {\r\n            if (config[i].resourceTypeId == resourceTypeId) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function removeResourcesAndWorkers(\r\n        address workersReceiverAddress,\r\n        uint256 workersAmount,\r\n        address resourcesReceiverAddress,\r\n        bytes32[] calldata resourceTypeIds,\r\n        uint256[] calldata resourcesAmounts\r\n    ) public override onlyActiveGame onlyRulerOrWorldAssetFromSameEra {\r\n        if (workersAmount > 0) {\r\n            _transferWorkers(workersReceiverAddress, workersAmount);\r\n        }\r\n\r\n        _batchTransferResources(resourceTypeIds, resourcesReceiverAddress, resourcesAmounts);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getUpgradePrice(uint256 level)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256 maxTreasuryByLevel = getMaxTreasuryByLevel(level);\r\n        uint256 maxTreasuryByNextLevel = getMaxTreasuryByLevel(level + 1);\r\n        uint256 maxTreasuryByLevelWithCoefficient = (maxTreasuryByLevel * 75) / 100;\r\n        uint256 treasuryDifference = maxTreasuryByNextLevel - maxTreasuryByLevelWithCoefficient;\r\n        return treasuryDifference / 6;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getBuildingLevel() public view override returns (uint256) {\r\n        return basicProduction.level + advancedProduction.level;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getAssignedWorkers() public view virtual override returns (uint256) {\r\n        return era().workers().balanceOf(address(this));\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function upgradeBasicProduction(address resourcesOwner) public virtual override onlyActiveGame onlyRulerOrWorldAssetFromSameEra {\r\n        updateState();\r\n\r\n        if (block.timestamp < upgradeCooldownEndTime) revert BuildingCannotBeUpgradedWhileUpgradeIsOnCooldown();\r\n\r\n        uint256 buildingLevel = getBuildingLevel();\r\n        uint256 upgradePrice = getUpgradePrice(buildingLevel);\r\n        bytes32 upgradeResourceTypeId = WOOD_TYPE_ID;\r\n\r\n        if (resourcesOwner == address(0)) {\r\n            era().resources(upgradeResourceTypeId).burnFrom(msg.sender, upgradePrice);\r\n        } else {\r\n            IResource upgradeResource = era().resources(upgradeResourceTypeId);\r\n            upgradeResource.spendAllowance(resourcesOwner, msg.sender, upgradePrice);\r\n            upgradeResource.burnFrom(resourcesOwner, upgradePrice);\r\n        }\r\n\r\n        relatedSettlement.relatedRegion().decreaseCorruptionIndex(\r\n            address(relatedSettlement),\r\n            registry().getCorruptionIndexByResource(upgradeResourceTypeId) * upgradePrice / 1e18\r\n        );\r\n\r\n        upgradeCooldownEndTime = block.timestamp + getBasicUpgradeCooldownDuration(buildingLevel);\r\n\r\n        uint256 _newBasicProductionCoefficient = (getBuildingCoefficient(buildingLevel + 1) - getBuildingCoefficient(buildingLevel)) + basicProduction.coefficient;\r\n        uint256 _newBasicProductionLevel = basicProduction.level + 1;\r\n\r\n        basicProduction.coefficient = _newBasicProductionCoefficient;\r\n        basicProduction.level = _newBasicProductionLevel;\r\n\r\n        _updateProsperity();\r\n\r\n        emit BasicProductionUpgraded(_newBasicProductionLevel, _newBasicProductionCoefficient);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function upgradeAdvancedProduction(address resourcesOwner) public virtual override onlyActiveGame onlyRulerOrWorldAssetFromSameEra {\r\n        updateState();\r\n\r\n        if (block.timestamp < upgradeCooldownEndTime) revert BuildingCannotBeUpgradedWhileUpgradeIsOnCooldown();\r\n\r\n        uint256 buildingLevel = getBuildingLevel();\r\n        uint256 upgradePrice = getUpgradePrice(buildingLevel);\r\n        bytes32 upgradeResourceTypeId = ORE_TYPE_ID;\r\n\r\n        if (resourcesOwner == address(0)) {\r\n            era().resources(upgradeResourceTypeId).burnFrom(msg.sender, upgradePrice);\r\n        } else {\r\n            IResource upgradeResource = era().resources(upgradeResourceTypeId);\r\n            upgradeResource.spendAllowance(resourcesOwner, msg.sender, upgradePrice);\r\n            upgradeResource.burnFrom(resourcesOwner, upgradePrice);\r\n        }\r\n\r\n        relatedSettlement.relatedRegion().decreaseCorruptionIndex(\r\n            address(relatedSettlement),\r\n            registry().getCorruptionIndexByResource(upgradeResourceTypeId) * upgradePrice / 1e18\r\n        );\r\n\r\n        upgradeCooldownEndTime = block.timestamp + getAdvancedUpgradeCooldownDuration(buildingLevel);\r\n\r\n        uint256 _newAdvancedProductionCoefficient = (getBuildingCoefficient(buildingLevel + 1) - getBuildingCoefficient(buildingLevel)) + advancedProduction.coefficient;\r\n        uint256 _newAdvancedProductionLevel = advancedProduction.level + 1;\r\n\r\n        advancedProduction.coefficient = _newAdvancedProductionCoefficient;\r\n        advancedProduction.level = _newAdvancedProductionLevel;\r\n\r\n        _updateProsperity();\r\n\r\n        emit AdvancedProductionUpgraded(_newAdvancedProductionLevel, _newAdvancedProductionCoefficient);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getBasicUpgradeCooldownDuration(uint256 level) public view virtual override returns (uint256) {\r\n        return level * 6 hours / registry().getGlobalMultiplier();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getAdvancedUpgradeCooldownDuration(uint256 level) public view virtual override returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getProducingResourceTypeId() public view virtual override returns (bytes32) {\r\n        ProductionConfigItem[] memory productionConfigItems = getConfig();\r\n        for (uint256 i = 0; i < productionConfigItems.length; i++) {\r\n            if (productionConfigItems[i].isProducing) {\r\n                return productionConfigItems[i].resourceTypeId;\r\n            }\r\n        }\r\n\r\n        return bytes32(0);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getWorkersCapacity() public view override returns (uint256) {\r\n        return advancedProduction.coefficient * registry().getWorkerCapacityCoefficient(buildingTypeId);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getTreasuryAmount(uint256 timestamp) public view virtual override returns (uint256) {\r\n        return getResourcesAmount(getProducingResourceTypeId(), timestamp);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getMaxTreasuryByLevel(uint256 level) public view virtual override returns (uint256) {\r\n        return (getBuildingCoefficient(level) ** 2) * 10 * 1e18;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function stealTreasury(\r\n        address stealerSettlementAddress,\r\n        uint256 amount\r\n    )\r\n        public\r\n        override\r\n        onlyWorldAssetFromSameEra\r\n        returns (uint256, uint256)\r\n    {\r\n        updateState();\r\n\r\n        IResource producingResource = era().resources(getProducingResourceTypeId());\r\n\r\n        uint256 currentTreasuryAmount = Math.min(\r\n            getMaxTreasuryByLevel(getBuildingLevel()),\r\n            producingResource.stateBalanceOf(address(this))\r\n        );\r\n\r\n        if (currentTreasuryAmount == 0) {\r\n            return (0, 0);\r\n        }\r\n\r\n        amount = Math.min(currentTreasuryAmount, amount);\r\n\r\n        ISettlement stealerSettlement = ISettlement(stealerSettlementAddress);\r\n        IBuilding sameBuildingOfStealerSettlement = stealerSettlement.buildings(buildingTypeId);\r\n        sameBuildingOfStealerSettlement.updateState();\r\n\r\n        uint256 stealerBuildingMaxTreasuryAmount = sameBuildingOfStealerSettlement.getMaxTreasuryByLevel(sameBuildingOfStealerSettlement.getBuildingLevel());\r\n        uint256 stealerBuildingCurrentTreasuryAmount = Math.min(\r\n            stealerBuildingMaxTreasuryAmount,\r\n            producingResource.stateBalanceOf(address(sameBuildingOfStealerSettlement))\r\n        );\r\n        uint256 amountOfResourcesCanFitIntoStealerBuilding = stealerBuildingMaxTreasuryAmount - stealerBuildingCurrentTreasuryAmount;\r\n        uint256 amountOfResourcesThatWillBeStolen = Math.min(amountOfResourcesCanFitIntoStealerBuilding, amount);\r\n        uint256 amountOfResourcesThatWillBeBurned = amount - amountOfResourcesThatWillBeStolen;\r\n\r\n        if (amountOfResourcesThatWillBeStolen != 0) {\r\n            producingResource.transfer(address(sameBuildingOfStealerSettlement), amountOfResourcesThatWillBeStolen);\r\n        }\r\n\r\n        if (amountOfResourcesThatWillBeBurned != 0) {\r\n            burnTreasury(amountOfResourcesThatWillBeBurned);\r\n        }\r\n\r\n        return (amountOfResourcesThatWillBeStolen, amountOfResourcesThatWillBeBurned);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function burnTreasury(uint256 burnAmount) public override onlyWorldAssetFromSameEra {\r\n        IResource resource = era().resources(getProducingResourceTypeId());\r\n        resource.burn(burnAmount);\r\n        _updateProsperity();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function increaseAdditionalWorkersCapacityMultiplier(uint256 capacityAmount) public override onlyWorldAssetFromSameEra {\r\n        updateState();\r\n\r\n        uint256 _newAdditionalWorkersCapacityMultiplier = advancedProduction.additionalWorkersCapacityMultiplier + capacityAmount;\r\n        advancedProduction.additionalWorkersCapacityMultiplier = _newAdditionalWorkersCapacityMultiplier;\r\n        emit AdvancedProductionAdditionalWorkersCapacityMultiplierUpdated(_newAdditionalWorkersCapacityMultiplier);\r\n\r\n        // Kick out extra workers from building into settlement\r\n        uint256 availableForAdvancedProductionWorkersCapacity = getAvailableForAdvancedProductionWorkersCapacity();\r\n        uint256 assignedWorkers = getAssignedWorkers();\r\n        if (assignedWorkers > availableForAdvancedProductionWorkersCapacity) {\r\n            uint256 workersToKickOut = assignedWorkers - availableForAdvancedProductionWorkersCapacity;\r\n            _transferWorkers(address(relatedSettlement), workersToKickOut);\r\n        }\r\n        //\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function decreaseAdditionalWorkersCapacityMultiplier(uint256 capacityAmount) public override onlyWorldAssetFromSameEra {\r\n        updateState();\r\n\r\n        uint256 _newAdditionalWorkersCapacityMultiplier = advancedProduction.additionalWorkersCapacityMultiplier - capacityAmount;\r\n        advancedProduction.additionalWorkersCapacityMultiplier = _newAdditionalWorkersCapacityMultiplier;\r\n        emit AdvancedProductionAdditionalWorkersCapacityMultiplierUpdated(_newAdditionalWorkersCapacityMultiplier);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getAdditionalWorkersFromAdditionalWorkersCapacityMultiplier() public view override returns (uint256) {\r\n        uint256 currentWorkersCapacityMultiplier = Math.min(\r\n            advancedProduction.additionalWorkersCapacityMultiplier,\r\n            registry().getMaxAdvancedProductionTileBuff()\r\n        );\r\n\r\n        uint256 workersCapacity = getWorkersCapacity();\r\n        return MathExtension.roundDownWithPrecision(\r\n            workersCapacity * currentWorkersCapacityMultiplier / 1e18,\r\n            1e18\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getAvailableForAdvancedProductionWorkersCapacity() public view override returns (uint256) {\r\n        return getWorkersCapacity() - getAdditionalWorkersFromAdditionalWorkersCapacityMultiplier();\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getConfig() public view virtual override returns (ProductionConfigItem[] memory productionConfigItems);\r\n\r\n    /// @dev Allows caller to be only distributions contract\r\n    function _onlyDistributions() internal view {\r\n        if (address(world().distributions()) != msg.sender) revert OnlyDistributions();\r\n    }\r\n\r\n    /// @dev Allows caller to be only settlement owner\r\n    function _onlySettlementOwner() internal view {\r\n        if (relatedSettlement.getSettlementOwner() != msg.sender) revert OnlySettlementOwner();\r\n    }\r\n\r\n    /// @dev Allows caller to be ruler or world or world asset\r\n    function _onlyRulerOrWorldAssetFromSameEra() internal view {\r\n        if (!relatedSettlement.isRuler(msg.sender) &&\r\n            msg.sender != address(world()) &&\r\n            world().worldAssets(eraNumber(), msg.sender) == bytes32(0)) revert OnlyRulerOrWorldAssetFromSameEra();\r\n    }\r\n\r\n    /// @dev Calculates how many ticks produced by advanced production by provided begin time, end time and to be produced ticks\r\n    function _getProducedTicksByAdvancedProduction(\r\n        uint256 advancedProductionBeginTime,\r\n        uint256 advancedProductionEndTime,\r\n        uint256 toBeProducedTicks\r\n    ) internal view returns (uint256) {\r\n        if (advancedProductionEndTime <= advancedProductionBeginTime) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 advancedProductionDuration = advancedProductionEndTime - advancedProductionBeginTime;\r\n\r\n        uint256 productionMultiplier = _getAdvancedProductionMultiplier();\r\n        uint256 ticksPassed = advancedProductionDuration / (1e18 / registry().getProductionTicksInSecond());\r\n\r\n        return Math.min(\r\n            ticksPassed * productionMultiplier / 1e18,\r\n            toBeProducedTicks\r\n        );\r\n    }\r\n\r\n    /// @dev Calculates how many ticks produced by basic production by provided begin time, end time\r\n    function _getProducedTicksByBasicProduction(\r\n        uint256 basicProductionBeginTime,\r\n        uint256 basicProductionEndTime\r\n    ) internal view returns (uint256) {\r\n        uint256 basicProductionDuration = basicProductionEndTime - basicProductionBeginTime;\r\n        uint256 ticksPassed = basicProductionDuration / (1e18 / registry().getProductionTicksInSecond());\r\n\r\n        return _getBasicProductionMultiplier() * ticksPassed / 1e18;\r\n    }\r\n\r\n    /// @dev Creates default distribution (all possible tokens will be minted to current settlement owner)\r\n    function _createDefaultDistribution() internal {\r\n        distributionId = world().distributions().mint(relatedSettlement.getSettlementOwner());\r\n        emit DistributionCreated(distributionId);\r\n    }\r\n\r\n    /// @dev Saves produced amount of resource between treasury and productionInfo.readyToBeDistributed\r\n    function _saveProducedResource(bytes32 resourceTypeId, uint256 amount) internal {\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        //N% of resources moves to treasury pool\r\n        uint256 amountOfResourceGoingToTreasury = (amount * registry().getToTreasuryPercent()) / 1e18;\r\n\r\n        uint256 currentTreasury = era().resources(resourceTypeId).stateBalanceOf(address(this));\r\n        uint256 maxTreasury = getMaxTreasuryByLevel(getBuildingLevel());\r\n\r\n        if (currentTreasury >= maxTreasury) {\r\n            amountOfResourceGoingToTreasury = 0;\r\n        } else if (amountOfResourceGoingToTreasury > maxTreasury - currentTreasury) {\r\n            amountOfResourceGoingToTreasury = maxTreasury - currentTreasury;\r\n        }\r\n\r\n        if (amountOfResourceGoingToTreasury > 0) {\r\n            era().resources(resourceTypeId).mint(address(this), amountOfResourceGoingToTreasury);\r\n            amount = amount - amountOfResourceGoingToTreasury;\r\n        }\r\n\r\n        if (amount > 0) {\r\n            relatedSettlement.relatedRegion().increaseCorruptionIndex(\r\n                address(relatedSettlement),\r\n                registry().getCorruptionIndexByResource(resourceTypeId) * amount / 1e18\r\n            );\r\n\r\n            _updateProductionInfo(\r\n                productionInfo.lastUpdateStateTime,\r\n                productionInfo.lastUpdateStateRegionTime,\r\n                productionInfo.readyToBeDistributed + amount,\r\n                productionInfo.totalDebt\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Updates building prosperity according to changed amount of resources in building\r\n    function _updateProsperity() internal virtual {\r\n        uint256 buildingLevel = getBuildingLevel();\r\n        uint256 levelCoefficient = getBuildingCoefficient(buildingLevel);\r\n\r\n        uint256 currentProductionResourceBalance = era().resources(getProducingResourceTypeId()).stateBalanceOf(\r\n            address(this)\r\n        );\r\n\r\n        uint256 prosperityBefore = givenProsperityAmount;\r\n\r\n        uint256 resourceWeight = registry().getResourceWeight(getProducingResourceTypeId());\r\n        uint256 potentialNewProsperity = (currentProductionResourceBalance * resourceWeight / levelCoefficient) / 1e18;\r\n        uint256 maxProsperity = (getMaxTreasuryByLevel(buildingLevel) * resourceWeight / levelCoefficient) / 1e18;\r\n\r\n        uint256 prosperityAfter = Math.min(maxProsperity, potentialNewProsperity);\r\n        givenProsperityAmount = prosperityAfter;\r\n\r\n        if (prosperityBefore > prosperityAfter) {\r\n            era().prosperity().burnFrom(address(relatedSettlement), prosperityBefore - prosperityAfter);\r\n        } else if (prosperityBefore < prosperityAfter) {\r\n            era().prosperity().mint(address(relatedSettlement), prosperityAfter - prosperityBefore);\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates current game time, taking into an account game end time\r\n    function _getCurrentTime() internal view returns (uint256) {\r\n        uint256 gameBeginTime = world().gameBeginTime();\r\n        uint256 gameEndTime = world().gameEndTime();\r\n        uint256 timestamp = block.timestamp;\r\n\r\n        if (timestamp < gameBeginTime) {\r\n            timestamp = gameBeginTime;\r\n        }\r\n\r\n        if (gameEndTime == 0) {\r\n            return timestamp;\r\n        }\r\n\r\n        return Math.min(timestamp, gameEndTime);\r\n    }\r\n\r\n    /// @dev Calculates basic production multiplier\r\n    function _getBasicProductionMultiplier() internal view returns (uint256) {\r\n        bytes32 _buildingTypeId = buildingTypeId;\r\n\r\n        return (\r\n            basicProduction.coefficient\r\n            * registry().getBasicProductionBuildingCoefficient(_buildingTypeId)\r\n            * registry().getWorkerCapacityCoefficient(_buildingTypeId)\r\n            * registry().getGlobalMultiplier()\r\n        ) / 1e18;\r\n    }\r\n\r\n    /// @dev Calculates advanced production multiplier\r\n    function _getAdvancedProductionMultiplier() internal view returns (uint256) {\r\n        uint256 multiplierFromWorkers = getAssignedWorkers() + getAdditionalWorkersFromAdditionalWorkersCapacityMultiplier();\r\n        return multiplierFromWorkers * registry().getGlobalMultiplier();\r\n    }\r\n\r\n    /// @dev Calculates amount of production ticks for current building according to its resources balances\r\n    function _calculateProductionTicksAmount() internal view returns (uint256) {\r\n        ProductionConfigItem[] memory config = getConfig();\r\n        uint256 productionTicksAmountUntilStop = type(uint256).max;\r\n\r\n        for (uint256 i = 0; i < config.length; i++) {\r\n            if (config[i].isProducing) {\r\n                continue;\r\n            }\r\n\r\n            uint256 balance = era().resources(config[i].resourceTypeId).stateBalanceOf(address(this));\r\n            if (balance == 0) {\r\n                return 0;\r\n            }\r\n\r\n            productionTicksAmountUntilStop = Math.min(\r\n                balance / config[i].amountPerTick,\r\n                productionTicksAmountUntilStop\r\n            );\r\n        }\r\n\r\n        return productionTicksAmountUntilStop;\r\n    }\r\n\r\n    /// @dev Calculates is building token recall allowed according to building token transfer threshold\r\n    function _isBuildingTokenRecallAllowed() internal returns (bool) {\r\n        uint256 maxTreasury = getMaxTreasuryByLevel(getBuildingLevel());\r\n        bytes32 producingResourceTypeId = getProducingResourceTypeId();\r\n        if (producingResourceTypeId == bytes32(0)) {\r\n            return false;\r\n        }\r\n\r\n        uint256 currentTreasuryThreshold = (maxTreasury * registry().getBuildingTokenTransferThresholdPercent()) / 1e18;\r\n        uint256 currentTreasury = era().resources(producingResourceTypeId).balanceOf(address(this));\r\n\r\n        return currentTreasury <= currentTreasuryThreshold;\r\n    }\r\n\r\n    /// @dev Batch transfer resources from building to specified address\r\n    function _batchTransferResources(\r\n        bytes32[] calldata resourceTypeIds,\r\n        address to,\r\n        uint256[] calldata amounts\r\n    ) internal {\r\n        for (uint256 i = 0; i < resourceTypeIds.length; i++) {\r\n            _transferResources(resourceTypeIds[i], to, amounts[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers workers from building to specified address\r\n    function _transferWorkers(address to, uint256 amount) internal {\r\n        era().workers().transfer(to, amount);\r\n    }\r\n\r\n    /// @dev Transfers resources from building to specified address\r\n    function _transferResources(\r\n        bytes32 resourceTypeId,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        updateState();\r\n\r\n        if (resourceTypeId == getProducingResourceTypeId()) {\r\n            revert CannotTransferProducingResourceFromBuilding();\r\n        }\r\n\r\n        IResource resource = era().resources(resourceTypeId);\r\n        uint256 balance = resource.balanceOf(address(this));\r\n        if (balance == 0) {\r\n            return;\r\n        }\r\n\r\n        if (amount > balance) {\r\n            amount = balance;\r\n        }\r\n\r\n        if (amount > 0) {\r\n            resource.transfer(to, amount);\r\n        }\r\n    }\r\n\r\n    /// @dev Updates production info\r\n    function _updateProductionInfo(\r\n        uint256 newLastUpdateStateTime,\r\n        uint256 newLastUpdateStateRegionTime,\r\n        uint256 newReadyToBeDistributed,\r\n        uint256 newTotalDebt\r\n    ) internal {\r\n        productionInfo.lastUpdateStateTime = newLastUpdateStateTime;\r\n        productionInfo.lastUpdateStateRegionTime = newLastUpdateStateRegionTime;\r\n        productionInfo.readyToBeDistributed = newReadyToBeDistributed;\r\n        productionInfo.totalDebt = newTotalDebt;\r\n\r\n        emit ProductionInfoUpdated(\r\n            productionInfo.lastUpdateStateTime,\r\n            productionInfo.lastUpdateStateRegionTime,\r\n            productionInfo.readyToBeDistributed,\r\n            productionInfo.totalDebt\r\n        );\r\n    }\r\n\r\n    /// @dev Updates produced resource debt for specified nft holder\r\n    function _updateProducedResourceDebt(\r\n        address distributionNftHolder,\r\n        uint256 newDebt\r\n    ) internal {\r\n        producedResourceDebt[distributionNftHolder] = newDebt;\r\n\r\n        emit ProducedResourceDebtUpdated(\r\n            distributionNftHolder,\r\n            newDebt\r\n        );\r\n    }\r\n}\r\n\r\n"
    },
    "contracts/core/assets/building/IBuilding.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../IWorld.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\n\r\n/// @title Building interface\r\n/// @notice Functions to read state/modify state in order to get current building parameters and/or interact with it\r\ninterface IBuilding {\r\n    struct BasicProduction {\r\n        uint256 level;\r\n        uint256 coefficient;\r\n    }\r\n\r\n    struct AdvancedProduction {\r\n        uint256 level;\r\n        uint256 coefficient;\r\n        uint256 additionalWorkersCapacityMultiplier;\r\n        uint256 toBeProducedTicks;\r\n    }\r\n\r\n    struct ProductionInfo {\r\n        uint256 lastUpdateStateTime;\r\n        uint256 lastUpdateStateRegionTime;\r\n        uint256 readyToBeDistributed;\r\n        uint256 totalDebt;\r\n    }\r\n\r\n    struct ProductionResultItem {\r\n        bytes32 resourceTypeId;\r\n        uint256 balanceDelta;\r\n        bool isProduced;\r\n    }\r\n\r\n    struct ProductionConfigItem {\r\n        bytes32 resourceTypeId;\r\n        uint256 amountPerTick;\r\n        bool isProducing;\r\n    }\r\n\r\n    // State variables\r\n\r\n    /// @notice Building type id\r\n    /// @dev Immutable, initialized on the building creation\r\n    function buildingTypeId() external view returns (bytes32 buildingTypeId);\r\n\r\n    /// @notice Settlement address to which this building belongs\r\n    /// @dev Immutable, initialized on the building creation\r\n    function relatedSettlement() external view returns (ISettlement);\r\n\r\n    /// @notice Basic production\r\n    /// @dev Contains basic production upgrade data\r\n    /// @return level Basic production level\r\n    /// @return coefficient Basic production coefficient\r\n    function basicProduction() external view returns (\r\n        uint256 level,\r\n        uint256 coefficient\r\n    );\r\n\r\n    /// @notice Advanced production\r\n    /// @dev Contains advanced production upgrade data\r\n    /// @return level Advanced production level\r\n    /// @return coefficient Advanced production coefficient\r\n    /// @return additionalWorkersCapacityMultiplier Additional workers capacity multiplier\r\n    /// @return toBeProducedTicks To be produced ticks of producing resource\r\n    function advancedProduction() external view returns (\r\n        uint256 level,\r\n        uint256 coefficient,\r\n        uint256 additionalWorkersCapacityMultiplier,\r\n        uint256 toBeProducedTicks\r\n    );\r\n\r\n    /// @notice Upgrade cooldown end time\r\n    /// @dev Updated when #upgradeBasicProduction or #upgradeAdvancedProduction is called\r\n    /// @return upgradeCooldownEndTime Upgrade cooldown end time\r\n    function upgradeCooldownEndTime() external view returns (uint256 upgradeCooldownEndTime);\r\n\r\n    /// @notice Amount of prosperity given\r\n    /// @dev Contains last written given prosperity amount by building treasury\r\n    /// @return givenProsperityAmount Given prosperity amount\r\n    function givenProsperityAmount() external view returns (uint256 givenProsperityAmount);\r\n\r\n    /// @notice Contains production info of the building\r\n    /// @dev Contains information related to how production is calculated\r\n    /// @return lastUpdateStateTime Time at which last #updateState is called\r\n    /// @return lastUpdateStateRegionTime Region time at which last #updateState is called\r\n    /// @return readyToBeDistributed Amount of produced resource ready to be distributed\r\n    /// @return totalDebt Total debt\r\n    function productionInfo()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 lastUpdateStateTime,\r\n            uint256 lastUpdateStateRegionTime,\r\n            uint256 readyToBeDistributed,\r\n            uint256 totalDebt\r\n        );\r\n\r\n    /// @notice Distribution id\r\n    /// @dev Initialized on creation and updated on #resetDistribution\r\n    function distributionId() external view returns (uint256);\r\n\r\n    /// @notice Produced resource debt\r\n    /// @dev Updated when #distributeToSingleHolder or #distributeToAllShareholders is called\r\n    function producedResourceDebt(address holder) external view returns (uint256);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when #doBasicProductionUpgrade is called\r\n    /// @param newBasicProductionLevel New basic production level\r\n    event BasicProductionUpgraded(uint256 newBasicProductionLevel, uint256 newBasicProductionCoefficient);\r\n\r\n    /// @notice Emitted when #doAdvancedProductionUpgrade is called\r\n    /// @param newAdvancedProductionLevel New advanced production level\r\n    event AdvancedProductionUpgraded(uint256 newAdvancedProductionLevel, uint256 newAdvancedProductionCoefficient);\r\n\r\n    /// @notice Emitted when #increaseAdditionalWorkersCapacityMultiplier or #decreaseAdditionalWorkersCapacityMultiplier\r\n    /// @param newAdditionalWorkersCapacityMultiplier New additional workers capacity multiplier\r\n    event AdvancedProductionAdditionalWorkersCapacityMultiplierUpdated(uint256 newAdditionalWorkersCapacityMultiplier);\r\n\r\n    /// @notice Emitted when #distribute is called (when resources from production are distributed to building token holders)\r\n    /// @param resourceTypeId Resource type id\r\n    /// @param holder Receiver address\r\n    /// @param amount Amount of distributed resources\r\n    event DistributedToShareHolder(bytes32 resourceTypeId, address holder, uint256 amount);\r\n\r\n    /// @notice Emitted when #_setDefaultDistribution is called\r\n    /// @param newDistributionId New distribution id\r\n    event DistributionCreated(uint256 newDistributionId);\r\n\r\n    /// @notice Emitted when productionInfo is updated\r\n    /// @param lastUpdateStateTime Last update state time\r\n    /// @param lastUpdateStateRegionTime Last update state region time\r\n    /// @param readyToBeDistributed Ready to be distributed\r\n    /// @param totalDebt Total debt\r\n    event ProductionInfoUpdated(\r\n        uint256 lastUpdateStateTime,\r\n        uint256 lastUpdateStateRegionTime,\r\n        uint256 readyToBeDistributed,\r\n        uint256 totalDebt\r\n    );\r\n\r\n    /// @notice Emitted when producedResourceDebt updated for distributionNftHolder\r\n    /// @param distributionNftHolder Distribution nft holder\r\n    /// @param newDebt New debt\r\n    event ProducedResourceDebtUpdated(\r\n        address distributionNftHolder,\r\n        uint256 newDebt\r\n    );\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which can be called only by Distributions\r\n    error OnlyDistributions();\r\n\r\n    /// @notice Thrown when attempting to call action which can be called only by settlement owner\r\n    error OnlySettlementOwner();\r\n\r\n    /// @notice Thrown when attempting to call action which can be called only by ruler or world asset\r\n    error OnlyRulerOrWorldAssetFromSameEra();\r\n\r\n    /// @notice Thrown when attempting to reset distribution of building tokens when its not allowed\r\n    error DistributionResetNotAllowedWhenTreasuryThresholdNotMet();\r\n\r\n    /// @notice Thrown when attempting to upgrade building when upgrades are on cooldown\r\n    error BuildingCannotBeUpgradedWhileUpgradeIsOnCooldown();\r\n\r\n    /// @notice Thrown when attempting to transfer producing resource from building\r\n    error CannotTransferProducingResourceFromBuilding();\r\n\r\n    // Functions\r\n\r\n    /// @notice Resets current building distribution\r\n    /// @dev Creates new distribution Nft and mints it to current settlement owner\r\n    function resetDistribution() external;\r\n\r\n    /// @notice Callback which recalculates production. Called when resources related to production of this building is transferred from/to this building\r\n    /// @dev Even though function is opened, it is auto-called by transfer method. Standalone calls provide 0 impact.\r\n    function handleProductionResourcesChanged() external;\r\n\r\n    /// @notice Updates state of this building up to block.timestamp\r\n    /// @dev Updates building production minting treasury and increasing #production.readyToBeDistributed\r\n    function updateState() external;\r\n\r\n    /// @notice Updates debts for shareholders whenever their share part changes\r\n    /// @dev Even though function is opened, it can be called only by distributions\r\n    /// @param from From address\r\n    /// @param to To address\r\n    /// @param amount Amount\r\n    function updateDebtsAccordingToNewDistributionsAmounts(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Distributes produced resource to single shareholder\r\n    /// @dev Useful to taking part of the resource from the building for single shareholder (to not pay gas for minting for all shareholders)\r\n    /// @param holder Holder\r\n    function distributeToSingleShareholder(address holder) external;\r\n\r\n    /// @notice Distributes produces resource to all shareholders\r\n    /// @dev Useful to get full produced resources to all shareholders\r\n    function distributeToAllShareholders() external;\r\n\r\n    /// @notice Calculates building coefficient by provided level\r\n    /// @dev Used to determine max treasury amount and new production coefficients\r\n    /// @param level Building level\r\n    /// @return buildingCoefficient Building coefficient\r\n    function getBuildingCoefficient(uint256 level) external pure returns (uint256 buildingCoefficient);\r\n\r\n    /// @notice Calculates amount of workers currently sitting in this building\r\n    /// @dev Same as workers.balanceOf(buildingAddress)\r\n    /// @return assignedWorkersAmount Amount of assigned workers\r\n    function getAssignedWorkers() external view returns (uint256 assignedWorkersAmount);\r\n\r\n    /// @notice Calculates real amount of provided resource in building related to its production at provided time\r\n    /// @dev Useful for determination how much of production resource (either producing and spending) at the specific time\r\n    /// @param resourceTypeId Type id of resource related to production\r\n    /// @param timestamp Time at which calculate amount of resources in building. If timestamp=0 -> calculates as block.timestamp\r\n    /// @return resourcesAmount Real amount of provided resource in building related to its production at provided time\r\n    function getResourcesAmount(bytes32 resourceTypeId, uint256 timestamp) external view returns (uint256 resourcesAmount);\r\n\r\n    /// @notice Calculates production resources changes at provided time\r\n    /// @dev Useful for determination how much of all production will be burned/produced at the specific time\r\n    /// @param timestamp Time at which calculate amount of resources in building. If timestamp=0 -> calculates as block.timestamp\r\n    /// @return productionResult Production resources changes at provided time\r\n    function getProductionResult(uint256 timestamp) external view returns (ProductionResultItem[] memory productionResult);\r\n\r\n    /// @notice Calculates upgrade price by provided level\r\n    /// @dev Useful for determination how much upgrade will cost at any level\r\n    /// @param level Level at which calculate price\r\n    /// @return price Amount of resources needed for upgrade\r\n    function getUpgradePrice(uint256 level) external view returns (uint256 price);\r\n\r\n    /// @notice Calculates basic upgrade duration for provided level\r\n    /// @dev If level=1 then returned value will be duration which is taken for upgrading from 1 to 2 level\r\n    /// @param level At which level calculate upgrade duration\r\n    /// @return upgradeCooldownDuration Upgrade cooldown duration\r\n    function getBasicUpgradeCooldownDuration(uint256 level) external view returns (uint256 upgradeCooldownDuration);\r\n\r\n    /// @notice Calculates advanced upgrade duration for provided level\r\n    /// @dev If level=1 then returned value will be duration which is taken for upgrading from 1 to 2 level\r\n    /// @param level At which level calculate upgrade duration\r\n    /// @return upgradeCooldownDuration Upgrade cooldown duration\r\n    function getAdvancedUpgradeCooldownDuration(uint256 level) external view returns (uint256 upgradeCooldownDuration);\r\n\r\n    /// @notice Upgrades basic production\r\n    /// @dev Necessary resources for upgrade will be taken either from msg.sender or resourcesOwner (if resource.allowance allows it)\r\n    /// @dev If resourcesOwner == address(0) -> resources will be taken from msg.sender\r\n    /// @dev If resourcesOwner != address(0) and resourcesOwner has given allowance to msg.sender >= upgradePrice -> resources will be taken from resourcesOwner\r\n    /// @param resourcesOwner Resources owner\r\n    function upgradeBasicProduction(address resourcesOwner) external;\r\n\r\n    /// @notice Upgrades advanced production\r\n    /// @dev Necessary resources for upgrade will be taken either from msg.sender or resourcesOwner (if resource.allowance allows it)\r\n    /// @dev If resourcesOwner == address(0) -> resources will be taken from msg.sender\r\n    /// @dev If resourcesOwner != address(0) and resourcesOwner has given allowance to msg.sender >= upgradePrice -> resources will be taken from resourcesOwner\r\n    /// @param resourcesOwner Resources owner\r\n    function upgradeAdvancedProduction(address resourcesOwner) external;\r\n\r\n    /// @notice Calculates current level\r\n    /// @dev Takes into an account if upgrades are ended or not\r\n    /// @return level Current building level\r\n    function getBuildingLevel() external view returns (uint256 level);\r\n\r\n    /// @notice Returns production config for current building\r\n    /// @dev Main config that determines which resources is produced/spend by production of this building\r\n    /// @dev ProductionConfigItem.amountPerTick is value how much of resource is spend/produced by 1 worker in 1 tick of production\r\n    /// @return productionConfigItems Production config for current building\r\n    function getConfig() external view returns (ProductionConfigItem[] memory productionConfigItems);\r\n\r\n    /// @notice Transfers game resources and workers from building to provided addresses\r\n    /// @dev Removes resources+workers from building in single transaction\r\n    /// @param workersReceiverAddress Workers receiver address (building or settlement)\r\n    /// @param workersAmount Workers amount (in 1e18 precision)\r\n    /// @param resourcesReceiverAddress Resources receiver address\r\n    /// @param resourceTypeIds Resource type ids\r\n    /// @param resourcesAmounts Resources amounts\r\n    function removeResourcesAndWorkers(\r\n        address workersReceiverAddress,\r\n        uint256 workersAmount,\r\n        address resourcesReceiverAddress,\r\n        bytes32[] calldata resourceTypeIds,\r\n        uint256[] calldata resourcesAmounts\r\n    ) external;\r\n\r\n    /// @notice Calculates maximum amount of treasury by provided level\r\n    /// @dev Can be used to determine maximum amount of treasury by any level\r\n    /// @param level Building level\r\n    /// @param maxTreasury Maximum amount of treasury\r\n    function getMaxTreasuryByLevel(uint256 level) external view returns (uint256 maxTreasury);\r\n\r\n    /// @notice Steals resources from treasury\r\n    /// @dev Called by siege, resources will be stolen into stealer settlement building treasury\r\n    /// @param stealerSettlementAddress Settlement address which will get resources\r\n    /// @param amount Amount of resources to steal and burn\r\n    /// @return stolenAmount Amount of stolen resources\r\n    /// @return burnedAmount Amount of burned resources\r\n    function stealTreasury(\r\n        address stealerSettlementAddress,\r\n        uint256 amount\r\n    ) external returns (uint256 stolenAmount, uint256 burnedAmount);\r\n\r\n    /// @notice Burns building treasury\r\n    /// @dev Can be called by world asset\r\n    /// @param amount Amount of resources to burn from treasury\r\n    function burnTreasury(\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Increases additional workers capacity multiplier\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param capacityAmount Capacity amount\r\n    function increaseAdditionalWorkersCapacityMultiplier(uint256 capacityAmount) external;\r\n\r\n    /// @notice Decreases additional workers capacity multiplier\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param capacityAmount Capacity amount\r\n    function decreaseAdditionalWorkersCapacityMultiplier(uint256 capacityAmount) external;\r\n\r\n    /// @notice Calculates workers capacity (maximum amount of workers)\r\n    /// @dev Used in determination of determinate maximum amount of workers\r\n    /// @return workersCapacity Workers capacity\r\n    function getWorkersCapacity() external view returns (uint256 workersCapacity);\r\n\r\n    /// @notice Calculates producing resource type id for this building\r\n    /// @dev Return value is value from #getConfig where 'isProducing'=true\r\n    /// @return resourceTypeId Type id of producing resource\r\n    function getProducingResourceTypeId() external view returns (bytes32 resourceTypeId);\r\n\r\n    /// @notice Calculates treasury amount at specified time\r\n    /// @dev Useful for determination how much treasury will be at specific time\r\n    /// @param timestamp Time at which calculate amount of treasury in building. If timestamp=0 -> calculates as block.timestamp\r\n    /// @return treasuryAmount Treasury amount at specified time\r\n    function getTreasuryAmount(uint256 timestamp) external view returns (uint256 treasuryAmount);\r\n\r\n    /// @notice Calculates if building is capable to accept resource\r\n    /// @dev Return value based on #getConfig\r\n    /// @param resourceTypeId Resource type id\r\n    /// @return isResourceAcceptable Is building can accept resource\r\n    function isResourceAcceptable(bytes32 resourceTypeId) external view returns (bool isResourceAcceptable);\r\n\r\n    /// @notice Calculates capacity of available workers for advanced production\r\n    /// @dev Difference between #getWorkersCapacity and #getAdditionalWorkersFromAdditionalWorkersCapacityMultiplier\r\n    function getAvailableForAdvancedProductionWorkersCapacity() external view returns (uint256);\r\n\r\n    /// @notice Calculates additional workers 'granted' from capacity multiplier\r\n    /// @dev Return value based on current advancedProduction.additionalWorkersCapacityMultiplier\r\n    function getAdditionalWorkersFromAdditionalWorkersCapacityMultiplier() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/core/assets/building/impl/Farm.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../Building.sol\";\r\n\r\ncontract Farm is Building {\r\n    /// @inheritdoc Building\r\n    function getConfig() public pure override returns (ProductionConfigItem[] memory) {\r\n        ProductionConfigItem[] memory productionConfigItems = new ProductionConfigItem[](1);\r\n\r\n        productionConfigItems[0] = ProductionConfigItem({\r\n            resourceTypeId: FOOD_TYPE_ID,\r\n            amountPerTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: true\r\n        });\r\n\r\n        return productionConfigItems;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/impl/Fort.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../Building.sol\";\r\nimport \"./IFort.sol\";\r\n\r\ncontract Fort is Building, IFort {\r\n    /// @inheritdoc IFort\r\n    uint256 public override health;\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getProducingResourceTypeId() public view override(Building, IBuilding) returns (bytes32) {\r\n        return bytes32(0);\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function resetDistribution() public override(Building, IBuilding) {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams)\r\n        public\r\n        override\r\n        initializer\r\n    {\r\n        (\r\n            address settlementAddress,\r\n            bytes32 currentBuildingTypeId\r\n        ) = abi.decode(initParams, (address, bytes32));\r\n\r\n        relatedSettlement = ISettlement(settlementAddress);\r\n        buildingTypeId = currentBuildingTypeId;\r\n\r\n        basicProduction.level = 1;\r\n        basicProduction.coefficient = 1;\r\n\r\n        advancedProduction.level = 1;\r\n        advancedProduction.coefficient = 1;\r\n\r\n        _updateProductionInfo(\r\n            block.timestamp,\r\n            0,\r\n            0,\r\n            0\r\n        );\r\n\r\n        health = 4e18;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getConfig()\r\n        public\r\n        pure\r\n        override(Building, IBuilding)\r\n        returns (ProductionConfigItem[] memory)\r\n    {\r\n        ProductionConfigItem[] memory productionConfigItems = new ProductionConfigItem[](3);\r\n\r\n        productionConfigItems[0] = ProductionConfigItem({\r\n            resourceTypeId: FOOD_TYPE_ID,\r\n            amountPerTick: uint256(3e18) / (1 days),\r\n            isProducing: false\r\n        });\r\n\r\n        productionConfigItems[1] = ProductionConfigItem({\r\n            resourceTypeId: WOOD_TYPE_ID,\r\n            amountPerTick: uint256(2e18) / (1 days),\r\n            isProducing: false\r\n        });\r\n\r\n        productionConfigItems[2] = ProductionConfigItem({\r\n            resourceTypeId: HEALTH_TYPE_ID,\r\n            amountPerTick: uint256(1e18) / (1 days),\r\n            isProducing: true\r\n        });\r\n\r\n        return productionConfigItems;\r\n    }\r\n\r\n    /// @inheritdoc IFort\r\n    function getMaxHealthOnLevel(uint256 level) public view override returns (uint256) {\r\n        return (getBuildingCoefficient(level) ** 3) * 1e18;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getTreasuryAmount(uint256 timestamp) public view override(Building, IBuilding) returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getMaxTreasuryByLevel(uint256 level) public view override(Building, IBuilding) returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getUpgradePrice(uint256 level)\r\n        public\r\n        view\r\n        virtual\r\n        override(Building, IBuilding)\r\n        returns (uint256)\r\n    {\r\n        // Same formula as 'buildings' upgrade price, but since fort does not have treasury -> it is redefined\r\n        uint256 maxTreasuryByLevel = (getBuildingCoefficient(level) ** 2) * 10 * 1e18;\r\n        uint256 maxTreasuryByNextLevel = (getBuildingCoefficient(level + 1) ** 2) * 10 * 1e18;\r\n        uint256 maxTreasuryByLevelWithCoefficient = (maxTreasuryByLevel * 75) / 100;\r\n        uint256 treasuryDifference = maxTreasuryByNextLevel - maxTreasuryByLevelWithCoefficient;\r\n        return treasuryDifference / 6;\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function updateState() public override(Building, IBuilding) {\r\n        relatedSettlement.relatedRegion().updateState();\r\n\r\n        uint256 currentTime = _getCurrentTime();\r\n        if (productionInfo.lastUpdateStateTime == currentTime) {\r\n            return;\r\n        }\r\n\r\n        ProductionResultItem[] memory productionResult = getProductionResult(currentTime);\r\n        _updateProductionInfo(currentTime, 0, 0, 0);\r\n\r\n        for (uint256 i = 0; i < productionResult.length; i++) {\r\n            if (productionResult[i].balanceDelta == 0) {\r\n                continue;\r\n            }\r\n\r\n            if (productionResult[i].resourceTypeId == HEALTH_TYPE_ID) {\r\n                // Updates health and applies siege damage\r\n\r\n                uint256 healthDelta = productionResult[i].balanceDelta;\r\n                bool isHealthProduced = productionResult[i].isProduced;\r\n                uint256 currentHealth = health;\r\n\r\n                if (isHealthProduced) {\r\n                    _updateHealth(currentHealth + healthDelta);\r\n                    continue;\r\n                }\r\n\r\n                if (currentHealth >= healthDelta) {\r\n                    _updateHealth(currentHealth - healthDelta);\r\n                    continue;\r\n                }\r\n\r\n                _updateHealth(0);\r\n                relatedSettlement.siege().applyDamage(healthDelta - currentHealth);\r\n\r\n                continue;\r\n            }\r\n\r\n            era().resources(productionResult[i].resourceTypeId).burn(productionResult[i].balanceDelta);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IBuilding\r\n    function getProductionResult(uint256 timestamp)\r\n        public\r\n        view\r\n        virtual\r\n        override(Building, IBuilding)\r\n        returns (ProductionResultItem[] memory)\r\n    {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        uint256 gameBeginTime = world().gameBeginTime();\r\n        if (timestamp < gameBeginTime) {\r\n            timestamp = gameBeginTime;\r\n        }\r\n\r\n        uint256 gameEndTime = world().gameEndTime();\r\n        if (gameEndTime != 0) {\r\n            timestamp = Math.min(timestamp, gameEndTime);\r\n        }\r\n\r\n        ProductionConfigItem[] memory productionConfigItems = getConfig();\r\n        ProductionResultItem[] memory productionResult = new ProductionResultItem[](productionConfigItems.length);\r\n        for (uint256 i = 0; i < productionConfigItems.length; i++) {\r\n            productionResult[i] = ProductionResultItem({\r\n                resourceTypeId: productionConfigItems[i].resourceTypeId,\r\n                isProduced: productionConfigItems[i].isProducing,\r\n                balanceDelta: 0\r\n            });\r\n        }\r\n\r\n        uint256 productionLastUpdateStateTime = productionInfo.lastUpdateStateTime;\r\n        if (productionLastUpdateStateTime < gameBeginTime) {\r\n            productionLastUpdateStateTime = gameBeginTime;\r\n        }\r\n\r\n        if (timestamp <= productionLastUpdateStateTime) {\r\n            return productionResult;\r\n        }\r\n\r\n        FortProductionResultParams memory fortProductionResultParams = _calculateFortProductionResultParams(\r\n            timestamp,\r\n            productionLastUpdateStateTime,\r\n            productionConfigItems[2].amountPerTick\r\n        );\r\n\r\n        for (uint256 i = 0; i < productionConfigItems.length; i++) {\r\n            if (productionConfigItems[i].isProducing) {\r\n                bool isHealthProduced = fortProductionResultParams.healthProduced >= fortProductionResultParams.healthLost;\r\n                uint256 healthChanges = isHealthProduced\r\n                    ? fortProductionResultParams.healthProduced - fortProductionResultParams.healthLost\r\n                    : fortProductionResultParams.healthLost - fortProductionResultParams.healthProduced;\r\n\r\n                productionResult[i].isProduced = isHealthProduced;\r\n                productionResult[i].balanceDelta = healthChanges;\r\n            } else {\r\n                productionResult[i].balanceDelta = productionConfigItems[i].amountPerTick * fortProductionResultParams.advancedTicksProduced;\r\n            }\r\n        }\r\n\r\n        return productionResult;\r\n    }\r\n\r\n    /// @inheritdoc IFort\r\n    function calculateDamageDone(uint256 timestamp)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 damage)\r\n    {\r\n        ProductionResultItem[] memory productionResultItems = getProductionResult(timestamp);\r\n\r\n        uint256 healthDelta;\r\n        bool isHealthProduced;\r\n\r\n        for (uint256 i = 0; i < productionResultItems.length; i++) {\r\n            if (productionResultItems[i].resourceTypeId == HEALTH_TYPE_ID) {\r\n                healthDelta = productionResultItems[i].balanceDelta;\r\n                isHealthProduced = productionResultItems[i].isProduced;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (healthDelta == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (isHealthProduced) {\r\n            return 0;\r\n        }\r\n\r\n        if (health >= healthDelta) {\r\n            return 0;\r\n        }\r\n\r\n        return healthDelta - health;\r\n    }\r\n\r\n    struct FortProductionResultParams {\r\n        uint256 healthProduced;\r\n        uint256 healthLost;\r\n        uint256 advancedTicksProduced;\r\n    }\r\n\r\n    /// @inheritdoc Building\r\n    function _updateProsperity() internal override {}\r\n\r\n    /// @dev Calculates fort degen income based on current siege power\r\n    function _calculateDegenIncome() internal view returns (uint256) {\r\n        return relatedSettlement.siege().totalSiegePower() * registry().getGlobalMultiplier();\r\n    }\r\n\r\n    /// @dev Calculates fort production result params\r\n    function _calculateFortProductionResultParams(\r\n        uint256 timestamp,\r\n        uint256 productionLastUpdateStateTime,\r\n        uint256 healthPerTick\r\n    ) internal view returns (FortProductionResultParams memory) {\r\n        uint256 basicRegenIncome = (healthPerTick * _getBasicProductionMultiplier()) / 1e18;\r\n        uint256 advancedRegenIncome = (healthPerTick * _getAdvancedProductionMultiplier()) / 1e18;\r\n        uint256 degenIncome = _calculateDegenIncome();\r\n\r\n        // If basic regen greater (or equal) than degen -> actual degen is zero and basic regen reduced\r\n        // else basic regen is zero and degen is reduced\r\n        if (basicRegenIncome >= degenIncome) {\r\n            basicRegenIncome = basicRegenIncome - degenIncome;\r\n            degenIncome = 0;\r\n        } else {\r\n            degenIncome = degenIncome - basicRegenIncome;\r\n            basicRegenIncome = 0;\r\n        }\r\n\r\n        uint256 maxHealth = getMaxHealthOnLevel(getBuildingLevel());\r\n        uint256 toBeProducedHealth = healthPerTick * advancedProduction.toBeProducedTicks;\r\n\r\n        FortAdvancedProductionParams memory fortAdvancedProductionParams = _calculateFortAdvancedProductionParams(\r\n            health,\r\n            maxHealth,\r\n            basicRegenIncome,\r\n            advancedRegenIncome,\r\n            degenIncome,\r\n            toBeProducedHealth\r\n        );\r\n\r\n        uint256 elapsedSeconds = timestamp - productionLastUpdateStateTime;\r\n\r\n        return _composeFortProductionResultParams(\r\n            elapsedSeconds,\r\n            fortAdvancedProductionParams.fullHealthProductionSeconds,\r\n            fortAdvancedProductionParams.partialHealthProductionSeconds,\r\n            basicRegenIncome,\r\n            advancedRegenIncome,\r\n            degenIncome,\r\n            healthPerTick\r\n        );\r\n    }\r\n\r\n    /// @dev Composes fort production result params by provided data\r\n    function _composeFortProductionResultParams(\r\n        uint256 elapsedSeconds,\r\n        uint256 fullHealthProductionSeconds,\r\n        uint256 partialHealthProductionSeconds,\r\n        uint256 basicRegenIncome,\r\n        uint256 advancedRegenIncome,\r\n        uint256 degenIncome,\r\n        uint256 healthPerTick\r\n    ) internal pure returns (FortProductionResultParams memory) {\r\n        uint256 fullIncomeSecondsElapsed = Math.min(\r\n            fullHealthProductionSeconds,\r\n            elapsedSeconds\r\n        );\r\n\r\n        uint256 partialIncomeSecondsElapsed = Math.min(\r\n            elapsedSeconds - fullIncomeSecondsElapsed,\r\n            partialHealthProductionSeconds\r\n        );\r\n\r\n        uint256 basicHealthProduced = elapsedSeconds * basicRegenIncome;\r\n        uint256 advancedHealthProduced = fullIncomeSecondsElapsed * advancedRegenIncome + partialIncomeSecondsElapsed * degenIncome;\r\n\r\n        uint256 healthProduced = basicHealthProduced + advancedHealthProduced;\r\n        uint256 healthLost = elapsedSeconds * degenIncome;\r\n        uint256 advancedTicksProduced = advancedHealthProduced / healthPerTick;\r\n\r\n        return FortProductionResultParams(healthProduced, healthLost, advancedTicksProduced);\r\n    }\r\n\r\n    struct FortAdvancedProductionParams {\r\n        uint256 fullHealthProductionSeconds;\r\n        uint256 partialHealthProductionSeconds;\r\n    }\r\n\r\n    /// @dev Calculates fort advanced production params\r\n    function _calculateFortAdvancedProductionParams(\r\n        uint256 currentHealth,\r\n        uint256 maxHealth,\r\n        uint256 basicRegenIncome,\r\n        uint256 advancedRegenIncome,\r\n        uint256 degenIncome,\r\n        uint256 toBeProducedHealth\r\n    ) internal pure returns (FortAdvancedProductionParams memory) {\r\n        // If advanced regen = 0, no advanced production is taking place\r\n        if (advancedRegenIncome == 0) {\r\n            return FortAdvancedProductionParams(0, 0);\r\n        }\r\n\r\n        uint256 missingHealth = maxHealth - currentHealth;\r\n        uint256 regenIncome = basicRegenIncome + advancedRegenIncome;\r\n        uint256 secondsUntilResourcesDepletionWithFullSpeed = toBeProducedHealth / advancedRegenIncome;\r\n\r\n        // If degen is greater (or equal) than combined regen ->\r\n        // advanced production is working at full speed and will stop when there will be no resources\r\n        if (degenIncome >= regenIncome) {\r\n            return FortAdvancedProductionParams(secondsUntilResourcesDepletionWithFullSpeed, 0);\r\n        }\r\n\r\n        uint256 netRegen = regenIncome - degenIncome;\r\n        uint256 secondsUntilFullWithCurrentSpeed = (missingHealth % netRegen) == 0\r\n            ? missingHealth / netRegen\r\n            : (missingHealth / netRegen) + 1;\r\n\r\n        // If degen is zero -> hp can only go up and will stop when its full or there will be no resources\r\n        if (degenIncome == 0) {\r\n            return FortAdvancedProductionParams(\r\n                Math.min(\r\n                    secondsUntilResourcesDepletionWithFullSpeed,\r\n                    secondsUntilFullWithCurrentSpeed\r\n                ),\r\n                0\r\n            );\r\n        }\r\n\r\n        // Basic regen at this point is always zero and degen is not zero\r\n\r\n        // If resources will run out faster than we will reach full hp ->\r\n        // advanced production is working at full speed and will be interrupted by empty resources\r\n        if (secondsUntilResourcesDepletionWithFullSpeed <= secondsUntilFullWithCurrentSpeed) {\r\n            return FortAdvancedProductionParams(secondsUntilResourcesDepletionWithFullSpeed, 0);\r\n        }\r\n\r\n        // At this point we will reach full hp with current production speed meaning partial production will take place\r\n        // and it will last until we have resources for current degen\r\n        // or it also means\r\n        // part of production that is left after we have reached full hp is the same as\r\n        // amount of seconds until full subtracted from amount of seconds until depletion BUT multiplied by regen/degen ratio\r\n        // in order to 'extend' production seconds\r\n        // for example:\r\n        // - we have 100 seconds until resources depletion with full speed\r\n        // - we have 40 seconds until full with current speed\r\n        // - we have 20 hp/s of advanced regen\r\n        // - we have 10 hp/s of degen\r\n        // - 100 - 40 = 60 seconds -> amount of seconds of full production speed that has to be converted to lower consumption\r\n        // or 60 seconds * 20 hp/s = 1200hp -> amount of hp would have been produced with full speed\r\n        // then 1200 hp / 10hp/s = 120 seconds of lowered production\r\n        uint256 partialHealthProductionSeconds = ((secondsUntilResourcesDepletionWithFullSpeed - secondsUntilFullWithCurrentSpeed) * regenIncome) / degenIncome;\r\n\r\n        return FortAdvancedProductionParams(secondsUntilFullWithCurrentSpeed, partialHealthProductionSeconds);\r\n    }\r\n\r\n    /// @dev Updates fort health\r\n    function _updateHealth(uint256 value) internal {\r\n        uint256 maxHealth = getMaxHealthOnLevel(getBuildingLevel());\r\n        uint256 newHealth = Math.min(value, maxHealth);\r\n        health = newHealth;\r\n\r\n        emit HealthUpdated(newHealth);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/impl/IFort.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IBuilding.sol\";\r\n\r\n/// @title Fort interface\r\n/// @notice Functions to read state/modify state in order to get current fort parameters and/or interact with it\r\ninterface IFort is IBuilding {\r\n    // State variables\r\n\r\n    /// @notice Fort health\r\n    /// @dev Updated when #updateHealth is called\r\n    function health() external view returns (uint256);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when #updateState is called (if health is changed in the process)\r\n    /// @param newHealth New health\r\n    event HealthUpdated(uint256 newHealth);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which is disabled\r\n    error Disabled();\r\n\r\n    // Functions\r\n\r\n    /// @notice Calculates maximum amount of health for provided level\r\n    /// @dev Useful to determine maximum amount of health will be available at provided level\r\n    /// @param level Level at which calculate maximum amount of health\r\n    /// @return maxHealth Maximum amount of health for provided level\r\n    function getMaxHealthOnLevel(uint256 level) external view returns (uint256 maxHealth);\r\n\r\n    /// @notice Calculates damage done at specified timestamp\r\n    /// @dev Uses fort production and siege parameters to forecast health and damage will be dealt at specified time\r\n    /// @param timestamp Time at which calculate parameters\r\n    /// @return damage Amount of damage done from fort.productionInfo.lastUpdateState to specified timestamp\r\n    function calculateDamageDone(uint256 timestamp)\r\n        external\r\n        view\r\n        returns (uint256 damage);\r\n}\r\n"
    },
    "contracts/core/assets/building/impl/Lumbermill.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../Building.sol\";\r\n\r\ncontract Lumbermill is Building {\r\n    /// @inheritdoc IBuilding\r\n    function getConfig() public pure override returns (ProductionConfigItem[] memory) {\r\n        ProductionConfigItem[] memory productionConfigItems = new ProductionConfigItem[](2);\r\n\r\n        productionConfigItems[0] = ProductionConfigItem({\r\n            resourceTypeId: FOOD_TYPE_ID,\r\n            amountPerTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: false\r\n        });\r\n\r\n        productionConfigItems[1] = ProductionConfigItem({\r\n            resourceTypeId: WOOD_TYPE_ID,\r\n            amountPerTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: true\r\n        });\r\n\r\n        return productionConfigItems;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/impl/Mine.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../Building.sol\";\r\n\r\ncontract Mine is Building {\r\n    /// @inheritdoc IBuilding\r\n    function getConfig() public pure override returns (ProductionConfigItem[] memory) {\r\n        ProductionConfigItem[] memory productionConfigItems = new ProductionConfigItem[](3);\r\n\r\n        productionConfigItems[0] = ProductionConfigItem({\r\n            resourceTypeId: FOOD_TYPE_ID,\r\n            amountPerTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: false\r\n        });\r\n\r\n        productionConfigItems[1] = ProductionConfigItem({\r\n            resourceTypeId: WOOD_TYPE_ID,\r\n            amountPerTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: false\r\n        });\r\n\r\n        productionConfigItems[2] = ProductionConfigItem({\r\n            resourceTypeId: ORE_TYPE_ID,\r\n            amountPerTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: true\r\n        });\r\n\r\n        return productionConfigItems;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/building/impl/Smithy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../Building.sol\";\r\n\r\ncontract Smithy is Building {\r\n    /// @inheritdoc IBuilding\r\n    function getConfig() public pure override returns (ProductionConfigItem[] memory) {\r\n        ProductionConfigItem[] memory productionConfigItems = new ProductionConfigItem[](4);\r\n\r\n        productionConfigItems[0] = ProductionConfigItem({\r\n            resourceTypeId: FOOD_TYPE_ID,\r\n            amountPerTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: false\r\n        });\r\n\r\n        productionConfigItems[1] = ProductionConfigItem({\r\n            resourceTypeId: WOOD_TYPE_ID,\r\n            amountPerTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: false\r\n        });\r\n\r\n        productionConfigItems[2] = ProductionConfigItem({\r\n            resourceTypeId: ORE_TYPE_ID,\r\n            amountPerTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: false\r\n        });\r\n\r\n        productionConfigItems[3] = ProductionConfigItem({\r\n            resourceTypeId: INGOT_TYPE_ID,\r\n            amountPerTick: uint256(10e18) / (1 days) / 10000,\r\n            isProducing: true\r\n        });\r\n\r\n        return productionConfigItems;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/era/Era.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../region/IRegion.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"./IEra.sol\";\r\nimport \"../../geography/IGeography.sol\";\r\nimport \"../../../const/GameAssetTypes.sol\";\r\n\r\ncontract Era is WorldAsset, IEra {\r\n    /// @inheritdoc IEra\r\n    mapping(uint64 => IRegion) public override regions;\r\n    /// @inheritdoc IEra\r\n    mapping(uint64 => ISettlement) public override settlementByPosition;\r\n    /// @inheritdoc IEra\r\n    mapping(uint256 => ISettlement) public override settlementByBannerId;\r\n    /// @inheritdoc IEra\r\n    uint256 public override totalCultists;\r\n    /// @inheritdoc IEra\r\n    uint256 public override creationTime;\r\n\r\n    /// @inheritdoc IEra\r\n    IWorkers public override workers;\r\n    /// @inheritdoc IEra\r\n    IProsperity public override prosperity;\r\n    /// @inheritdoc IEra\r\n    mapping(bytes32 => IResource) public override resources;\r\n    /// @inheritdoc IEra\r\n    mapping(bytes32 => IUnits) public override units;\r\n    /// @inheritdoc IEra\r\n    ITileCapturingSystem public override tileCapturingSystem;\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        creationTime = block.timestamp;\r\n\r\n        (\r\n            uint256 eraNumber\r\n        ) = abi.decode(initParams, (uint256));\r\n\r\n        // 1. create new resources\r\n        IRegistry.GameResource[] memory gameResources = registry().getGameResources();\r\n        for (uint256 i = 0; i < gameResources.length; i++) {\r\n            IRegistry.GameResource memory gameResource = gameResources[i];\r\n\r\n            address resourceAddress = _createNewResource(\r\n                gameResource,\r\n                eraNumber\r\n            );\r\n\r\n            resources[gameResource.resourceTypeId] = IResource(resourceAddress);\r\n            emit ResourceCreated(resourceAddress, gameResource.resourceTypeId);\r\n        }\r\n\r\n        // 2. create new units\r\n        IRegistry.GameUnit[] memory gameUnits = registry().getGameUnits();\r\n        for (uint256 i = 0; i < gameUnits.length; i++) {\r\n            IRegistry.GameUnit memory gameUnit = gameUnits[i];\r\n\r\n            address unitsAddress = _createNewUnits(\r\n                gameUnit,\r\n                eraNumber\r\n            );\r\n\r\n            units[gameUnit.unitTypeId] = IUnits(unitsAddress);\r\n            emit UnitsCreated(unitsAddress, gameUnit.unitTypeId);\r\n        }\r\n\r\n        // 3. create new workers\r\n        address workersAddress = _createNewWorkers(eraNumber);\r\n        workers = IWorkers(workersAddress);\r\n        emit WorkersCreated(workersAddress);\r\n\r\n        // 4. create new prosperity\r\n        address prosperityAddress = _createNewProsperity(eraNumber);\r\n        prosperity = IProsperity(prosperityAddress);\r\n        emit ProsperityCreated(prosperityAddress);\r\n\r\n        // 5. create new tile capturing system\r\n        address tileCapturingSystemAddress = _createNewTileCapturingSystem(eraNumber);\r\n        tileCapturingSystem = ITileCapturingSystem(tileCapturingSystemAddress);\r\n        emit TileCapturingSystemCreated(tileCapturingSystemAddress);\r\n    }\r\n\r\n    /// @inheritdoc IEra\r\n    function activateRegion(uint64 regionId) public override {\r\n        if (address(regions[regionId]) != address(0)) revert EraCannotActivateRegionMoreThanOnce();\r\n        if (!world().geography().isRegionIncluded(regionId)) revert EraCannotActivateNotIncludedRegion();\r\n\r\n        //1. create region\r\n        address regionAddress = worldAssetFactory().create(\r\n            address(world()),\r\n            eraNumber(),\r\n            REGION_GROUP_TYPE_ID,\r\n            BASIC_TYPE_ID,\r\n            abi.encode(regionId)\r\n        );\r\n\r\n        IRegion region = IRegion(regionAddress);\r\n        regions[regionId] = region;\r\n        emit RegionActivated(regionAddress, regionId);\r\n\r\n        //2. creates region cultists settlement\r\n        region.createCultistsSettlement(regionId);\r\n    }\r\n\r\n    /// @inheritdoc IEra\r\n    function restoreUserSettlement(\r\n        uint64 position\r\n    ) public override onlyActiveGame {\r\n        if (eraNumber() != world().currentEraNumber()) revert UserSettlementCannotBeRestoredFromInactiveEra();\r\n\r\n        ICrossErasMemory crossErasMemory = world().crossErasMemory();\r\n\r\n        ISettlement settlement = crossErasMemory.settlementByPosition(position);\r\n        if (settlement.isRottenSettlement()) revert UserSettlementCannotBeRestoredIfItsRotten();\r\n\r\n        uint256 bannerIdByPosition = settlement.bannerId();\r\n\r\n        (uint64 regionId, bool isPositionExist) = world().geography().getRegionIdByPosition(position);\r\n\r\n        address settlementAddress = this.createSettlementByType(\r\n            bannerIdByPosition,\r\n            position,\r\n            regionId,\r\n            BASIC_TYPE_ID\r\n        );\r\n\r\n        _addUserSettlement(crossErasMemory, settlementAddress, false);\r\n\r\n        emit SettlementRestored(settlementAddress, position);\r\n    }\r\n\r\n    /// @inheritdoc IEra\r\n    function createUserSettlement(\r\n        uint64 position,\r\n        uint64 regionId,\r\n        uint256 bannerId\r\n    ) public override onlyWorldAssetFromSameEra returns (address) {\r\n        IGeography geography = world().geography();\r\n        ICrossErasMemory crossErasMemory = world().crossErasMemory();\r\n\r\n        if (address(crossErasMemory.settlementByPosition(position)) != address(0)) revert UserSettlementCannotBeCreatedOnPositionWithAnotherSettlement();\r\n        if (_hasSettlementInRadius(geography, crossErasMemory, position, 2)) revert UserSettlementCannotBeCreatedOnPositionWhichIsToCloseToAnotherSettlement();\r\n        if (address(crossErasMemory.settlementByBannerId(bannerId)) != address(0)) revert UserSettlementCannotBeCreatedIfBannerNftIdIsAlreadyTakenByAnotherSettlement();\r\n        if (eraNumber() != world().currentEraNumber()) revert UserSettlementCannotBeCreatedInInactiveEra();\r\n        if (crossErasMemory.regionUserSettlementsCount(regionId) == registry().getMaxSettlementsPerRegion()) revert UserSettlementCannotBeCreatedInRegionWithMaximumAllowedSettlements();\r\n        if (!_hasSettlementInRingRadius(geography, crossErasMemory, position, 3)) revert UserSettlementCannotBeCreatedOnPositionWhichIsNotConnectedToAnotherSettlement();\r\n\r\n        address settlementAddress = this.createSettlementByType(\r\n            bannerId,\r\n            position,\r\n            regionId,\r\n            BASIC_TYPE_ID\r\n        );\r\n\r\n        _addUserSettlement(crossErasMemory, settlementAddress, true);\r\n\r\n        return settlementAddress;\r\n    }\r\n\r\n    /// @inheritdoc IEra\r\n    function createSettlementByType(\r\n        uint256 bannerId,\r\n        uint64 position,\r\n        uint64 regionId,\r\n        bytes32 assetTypeId\r\n    ) public override onlyWorldAssetFromSameEra returns (address) {\r\n        address regionAddress = address(regions[regionId]);\r\n\r\n        address settlementAddress = worldAssetFactory().create(\r\n            address(world()),\r\n            eraNumber(),\r\n            SETTLEMENT_GROUP_TYPE_ID,\r\n            assetTypeId,\r\n            abi.encode(bannerId, regionAddress, position)\r\n        );\r\n\r\n        ICrossErasMemory crossErasMemory = world().crossErasMemory();\r\n        _placeSettlementOnMap(crossErasMemory, settlementAddress);\r\n\r\n        tileCapturingSystem.handleSettlementCreatedOnPosition(position);\r\n\r\n        emit SettlementCreated(settlementAddress, assetTypeId, regionAddress, position, bannerId);\r\n\r\n        return settlementAddress;\r\n    }\r\n\r\n    /// @inheritdoc IEra\r\n    function increaseTotalCultists(\r\n        uint256 value\r\n    ) public override onlyWorldAssetFromSameEra {\r\n        totalCultists += value;\r\n        emit TotalCultistsChanged(totalCultists);\r\n    }\r\n\r\n    /// @inheritdoc IEra\r\n    function decreaseTotalCultists(\r\n        uint256 value\r\n    ) public override onlyWorldAssetFromSameEra {\r\n        totalCultists -= value;\r\n        emit TotalCultistsChanged(totalCultists);\r\n    }\r\n\r\n    /// @dev Creates tile capturing system instance\r\n    function _createNewTileCapturingSystem(uint256 eraNumber) internal returns (address) {\r\n        return worldAssetFactory().create(\r\n            address(world()),\r\n            eraNumber,\r\n            TILE_CAPTURING_SYSTEM_GROUP_TYPE_ID,\r\n            BASIC_TYPE_ID,\r\n            abi.encode()\r\n        );\r\n    }\r\n\r\n    /// @dev Creates new prosperity instance\r\n    function _createNewProsperity(uint256 eraNumber) internal returns (address) {\r\n        return worldAssetFactory().create(\r\n            address(world()),\r\n            eraNumber,\r\n            PROSPERITY_GROUP_TYPE_ID,\r\n            BASIC_TYPE_ID,\r\n            abi.encode()\r\n        );\r\n    }\r\n\r\n    /// @dev Creates new workers instance\r\n    function _createNewWorkers(uint256 eraNumber) internal returns (address) {\r\n        return worldAssetFactory().create(\r\n            address(world()),\r\n            eraNumber,\r\n            WORKERS_GROUP_TYPE_ID,\r\n            BASIC_TYPE_ID,\r\n            abi.encode()\r\n        );\r\n    }\r\n\r\n    /// @dev Creates new resource instance\r\n    function _createNewResource(\r\n        IRegistry.GameResource memory gameResource,\r\n        uint256 eraNumber\r\n    ) internal returns (address) {\r\n        return worldAssetFactory().create(\r\n            address(world()),\r\n            eraNumber,\r\n            RESOURCE_GROUP_TYPE_ID,\r\n            BASIC_TYPE_ID,\r\n            abi.encode(gameResource.tokenName, gameResource.tokenSymbol, gameResource.resourceTypeId)\r\n        );\r\n    }\r\n\r\n    /// @dev Creates new units instance\r\n    function _createNewUnits(\r\n        IRegistry.GameUnit memory gameUnit,\r\n        uint256 eraNumber\r\n    ) internal returns (address) {\r\n        return worldAssetFactory().create(\r\n            address(world()),\r\n            eraNumber,\r\n            UNITS_GROUP_TYPE_ID,\r\n            BASIC_TYPE_ID,\r\n            abi.encode(gameUnit.tokenName, gameUnit.tokenSymbol, gameUnit.unitTypeId)\r\n        );\r\n    }\r\n\r\n    /// @dev Calculates does any settlement exists in provided radius\r\n    function _hasSettlementInRadius(\r\n        IGeography geography,\r\n        ICrossErasMemory crossErasMemory,\r\n        uint64 position,\r\n        uint256 radius\r\n    ) internal view returns (bool) {\r\n        for (uint256 i = 1; i <= radius; i++) {\r\n            if (_hasSettlementInRingRadius(geography, crossErasMemory, position, i)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Calculates does any settlement exists in provided ring radius\r\n    function _hasSettlementInRingRadius(\r\n        IGeography geography,\r\n        ICrossErasMemory crossErasMemory,\r\n        uint64 position,\r\n        uint256 radius\r\n    ) internal view returns (bool) {\r\n        (uint64[] memory ringPositions, uint256 ringPositionsLength) = geography.getRingPositions(position, radius);\r\n        for (uint256 i = 0; i < ringPositionsLength; i++) {\r\n            if (address(crossErasMemory.settlementByPosition(ringPositions[i])) != address(0)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Adds user settlement\r\n    function _addUserSettlement(\r\n        ICrossErasMemory crossErasMemory,\r\n        address settlementAddress,\r\n        bool isNewSettlement\r\n    ) internal {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n        uint256 bannerId = settlement.bannerId();\r\n        uint64 regionId = settlement.relatedRegion().regionId();\r\n\r\n        settlementByBannerId[bannerId] = ISettlement(settlementAddress);\r\n        crossErasMemory.addUserSettlement(\r\n            bannerId,\r\n            regionId,\r\n            settlementAddress,\r\n            isNewSettlement\r\n        );\r\n    }\r\n\r\n    /// @dev Places settlement on map\r\n    function _placeSettlementOnMap(\r\n        ICrossErasMemory crossErasMemory,\r\n        address settlementAddress\r\n    ) internal {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n        uint64 position = settlement.position();\r\n\r\n        settlementByPosition[position] = settlement;\r\n        world().crossErasMemory().placeSettlementOnMap(position, settlementAddress);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/era/IEra.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../settlement/ISettlement.sol\";\r\nimport \"../tileCapturingSystem/ITileCapturingSystem.sol\";\r\nimport \"../tokens/resources/IResource.sol\";\r\n\r\n/// @title Era interface\r\n/// @notice Functions to read state/modify state in order to get current era parameters and/or interact with it\r\ninterface IEra {\r\n\r\n    // State variables\r\n\r\n    /// @notice Mapping containing activated regions by provided region id\r\n    /// @dev Updated when #activateRegion is called\r\n    function regions(uint64 regionId) external view returns (IRegion);\r\n\r\n    /// @notice Mapping containing settlement by provided position\r\n    /// @dev Updated when new settlement is created\r\n    function settlementByPosition(uint64 position) external view returns (ISettlement);\r\n\r\n    /// @notice Mapping containing settlement address by provided banner id\r\n    /// @dev Updated when #addUserSettlement is called\r\n    function settlementByBannerId(uint256 bannerId) external view returns (ISettlement);\r\n\r\n    /// @notice Total cultists\r\n    /// @dev Updated when #increaseTotalCultists or #decreaseTotalCultists is called\r\n    function totalCultists() external view returns (uint256);\r\n\r\n    /// @notice Era creation time\r\n    /// @dev Immutable, initialized on creation\r\n    function creationTime() external view returns (uint256);\r\n\r\n    /// @notice Workers token\r\n    /// @dev Updated when #setWorkersContract is called\r\n    function workers() external view returns (IWorkers);\r\n\r\n    /// @notice Prosperity token\r\n    /// @dev Updated when #setProsperityContract is called\r\n    function prosperity() external view returns (IProsperity);\r\n\r\n    /// @notice Mapping containing game resources by resource type id\r\n    /// @dev Updated when #addResource is called\r\n    function resources(bytes32 resourceTypeId) external view returns (IResource);\r\n\r\n    /// @notice Mapping containing units by unit type id\r\n    /// @dev Updated when #addUnit is called\r\n    function units(bytes32 unitTypeId) external view returns (IUnits);\r\n\r\n    /// @notice Tile capturing system\r\n    /// @dev Updated when #setTileCapturingSystemContract is called\r\n    function tileCapturingSystem() external view returns (ITileCapturingSystem);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when era resource is created\r\n    /// @param resourceAddress Resource address\r\n    /// @param resourceTypeId Resource type id\r\n    event ResourceCreated(\r\n        address resourceAddress,\r\n        bytes32 resourceTypeId\r\n    );\r\n\r\n    /// @notice Emitted when era units is created\r\n    /// @param unitsAddress Units address\r\n    /// @param unitTypeId Unit type id\r\n    event UnitsCreated(\r\n        address unitsAddress,\r\n        bytes32 unitTypeId\r\n    );\r\n\r\n    /// @notice Emitted when era workers is created\r\n    /// @param workersAddress Workers address\r\n    event WorkersCreated(\r\n        address workersAddress\r\n    );\r\n\r\n    /// @notice Emitted when era prosperity is created\r\n    /// @param prosperityAddress Prosperity address\r\n    event ProsperityCreated(\r\n        address prosperityAddress\r\n    );\r\n\r\n    /// @notice Emitted when era tile capturing system is created\r\n    /// @param tileCapturingSystemAddress Tile capturing system address\r\n    event TileCapturingSystemCreated(\r\n        address tileCapturingSystemAddress\r\n    );\r\n\r\n    /// @notice Emitted when #activateRegion is called\r\n    /// @param regionAddress Region address\r\n    /// @param regionId Region id\r\n    event RegionActivated(\r\n        address regionAddress,\r\n        uint256 regionId\r\n    );\r\n\r\n    /// @notice Emitted when #newAssetSettlement is called\r\n    /// @param settlementAddress Created settlement address\r\n    /// @param assetTypeId Asset type id\r\n    /// @param regionAddress Address of the region where settlement is created\r\n    /// @param position Position\r\n    /// @param bannerId Banner id\r\n    event SettlementCreated(\r\n        address settlementAddress,\r\n        bytes32 assetTypeId,\r\n        address regionAddress,\r\n        uint64 position,\r\n        uint256 bannerId\r\n    );\r\n\r\n    /// @notice Emitted when #restoreUserSettlement is called\r\n    /// @param settlementAddress Settlement address\r\n    /// @param position Position\r\n    event SettlementRestored(\r\n        address settlementAddress,\r\n        uint64 position\r\n    );\r\n\r\n    /// @notice Emitted when #increaseTotalCultists or #decreaseTotalCultists is called\r\n    /// @param newTotalCultists New total cultists\r\n    event TotalCultistsChanged(uint256 newTotalCultists);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to activate region more than once\r\n    error EraCannotActivateRegionMoreThanOnce();\r\n\r\n    /// @notice Thrown when attempting to activate region which is not included to the game\r\n    error EraCannotActivateNotIncludedRegion();\r\n\r\n    /// @notice Thrown when attempting to restore user settlement from inactive era\r\n    error UserSettlementCannotBeRestoredFromInactiveEra();\r\n\r\n    /// @notice Thrown when attempting to restore user settlement if it is rotten\r\n    error UserSettlementCannotBeRestoredIfItsRotten();\r\n\r\n    /// @notice Thrown when attempting to create user settlement on position with another settlement\r\n    error UserSettlementCannotBeCreatedOnPositionWithAnotherSettlement();\r\n\r\n    /// @notice Thrown when attempting to create user settlement on position which is to close to another settlement\r\n    error UserSettlementCannotBeCreatedOnPositionWhichIsToCloseToAnotherSettlement();\r\n\r\n    /// @notice Thrown when attempting to create user settlement with banner nft id which is already taken by another settlement\r\n    error UserSettlementCannotBeCreatedIfBannerNftIdIsAlreadyTakenByAnotherSettlement();\r\n\r\n    /// @notice Thrown when attempting to create user settlement in inactive era\r\n    error UserSettlementCannotBeCreatedInInactiveEra();\r\n\r\n    /// @notice Thrown when attempting to create user settlement in region which already has maximum amount of allowed settlement\r\n    error UserSettlementCannotBeCreatedInRegionWithMaximumAllowedSettlements();\r\n\r\n    /// @notice Thrown when attempting to create user settlement on position which is not connected to another settlement\r\n    error UserSettlementCannotBeCreatedOnPositionWhichIsNotConnectedToAnotherSettlement();\r\n\r\n    // Functions\r\n\r\n    /// @notice Activates region\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param regionId Region id\r\n    function activateRegion(uint64 regionId) external;\r\n\r\n    /// @notice Restores settlement from previous era by provided position\r\n    /// @dev Any address can restore user settlement\r\n    /// @param position Position\r\n    function restoreUserSettlement(\r\n        uint64 position\r\n    ) external;\r\n\r\n    /// @notice Creates user settlement\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param position Position\r\n    /// @param regionId Region id to which position belongs\r\n    /// @param bannerId Banners token id which will represent to which settlement will be attached to\r\n    /// @return settlementAddress Settlement address\r\n    function createUserSettlement(\r\n        uint64 position,\r\n        uint64 regionId,\r\n        uint256 bannerId\r\n    ) external returns (address settlementAddress);\r\n\r\n    /// @notice Creates settlement by type\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param bannerId Banners token id which will represent to which settlement will be attached to\r\n    /// @param position Position\r\n    /// @param regionId Region id to which position belongs\r\n    /// @param assetTypeId Asset type id\r\n    function createSettlementByType(\r\n        uint256 bannerId,\r\n        uint64 position,\r\n        uint64 regionId,\r\n        bytes32 assetTypeId\r\n    ) external returns (address);\r\n\r\n    /// @notice Increases total cultists\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param value Amount of cultists minted\r\n    function increaseTotalCultists(\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Decreases total cultists\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param value Amount of cultists burned\r\n    function decreaseTotalCultists(\r\n        uint256 value\r\n    ) external;\r\n}\r\n"
    },
    "contracts/core/assets/IWorldAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IWorld.sol\";\r\nimport \"./IWorldAssetFactory.sol\";\r\n\r\ninterface IWorldAsset {\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by mighty creator\r\n    error OnlyMightyCreator();\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by world asset from same era\r\n    error OnlyWorldAssetFromSameEra();\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called in active game (started and not finished)\r\n    error OnlyActiveGame();\r\n\r\n    // Functions\r\n\r\n    /// @notice World\r\n    /// @dev Value is dereferenced from proxy storage\r\n    function world() external view returns (IWorld);\r\n\r\n    /// @notice Registry\r\n    /// @dev Value is dereferenced from world\r\n    function registry() external view returns (IRegistry);\r\n\r\n    /// @notice Era\r\n    /// @dev Value is dereferenced from proxy storage and world\r\n    function era() external view returns (IEra);\r\n\r\n    /// @notice Returns world asset factory from registry\r\n    /// @dev Value is dereferenced from registry\r\n    function worldAssetFactory() external view returns (IWorldAssetFactory);\r\n}\r\n"
    },
    "contracts/core/assets/IWorldAssetFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Army factory interface\r\n/// @notice Contains instance creator function\r\ninterface IWorldAssetFactory {\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by world or world asset\r\n    error OnlyWorldOrWorldAsset();\r\n\r\n    // Functions\r\n\r\n    /// @notice Creates new world asset, sets it into the world and initializes it\r\n    /// @param worldAddress World address\r\n    /// @param eraNumber Era number\r\n    /// @param assetGroupId Asset group id\r\n    /// @param assetTypeId Asset type id\r\n    /// @param initParams Init params\r\n    /// @return worldAssetAddress World asset address\r\n    function create(\r\n        address worldAddress,\r\n        uint256 eraNumber,\r\n        bytes32 assetGroupId,\r\n        bytes32 assetTypeId,\r\n        bytes memory initParams\r\n    ) external returns (address worldAssetAddress);\r\n}\r\n"
    },
    "contracts/core/assets/IWorldAssetStorageAccessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IWorld.sol\";\r\n\r\n/// @title World asset storage accessor interface\r\n/// @notice Contains function to identify world asset group and type\r\ninterface IWorldAssetStorageAccessor {\r\n    // Functions\r\n\r\n    /// @notice Returns world\r\n    /// @dev Reads data from proxy's storage\r\n    /// @return world World\r\n    function world() external view returns (IWorld world);\r\n\r\n    /// @notice Returns era number\r\n    /// @dev Reads data from proxy's storage\r\n    /// @return eraNumber Era number\r\n    function eraNumber() external view returns (uint256 eraNumber);\r\n\r\n    /// @notice Returns world asset group id\r\n    /// @dev Reads data from proxy's storage\r\n    /// @return assetGroupId World asset group id\r\n    function assetGroupId() external view returns (bytes32 assetGroupId);\r\n\r\n    /// @notice Returns world asset type id\r\n    /// @dev Reads data from proxy's storage\r\n    /// @return assetTypeId World asset type id\r\n    function assetTypeId() external view returns (bytes32 assetTypeId);\r\n}\r\n"
    },
    "contracts/core/assets/region/IRegion.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../workersPool/IWorkersPool.sol\";\r\nimport \"../era/IEra.sol\";\r\nimport \"../unitsPool/IUnitsPool.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\nimport \"../settlementsMarket/ISettlementMarket.sol\";\r\n\r\n/// @title Region interface\r\n/// @notice Functions to read state/modify state in order to get current region parameters and/or interact with it\r\ninterface IRegion {\r\n\r\n    // State variables\r\n\r\n    /// @notice Workers pool\r\n    /// @dev Immutable, initialized on the region creation\r\n    function workersPool() external view returns (IWorkersPool);\r\n\r\n    /// @notice Mapping containing units pool for provided unit type id\r\n    /// @dev Immutable, initialized on the region creation\r\n    function unitsPools(bytes32 unitTypeId) external view returns (IUnitsPool);\r\n\r\n    /// @notice Mapping containing units market for provided unit type\r\n    /// @dev Immutable, initialized on the region creation\r\n    function settlementsMarket() external view returns (ISettlementsMarket);\r\n\r\n    /// @notice Cultists settlement of this region\r\n    /// @dev Immutable, initialized on the region creation\r\n    function cultistsSettlement() external view returns (ISettlement);\r\n\r\n    /// @notice Last cultists summon interval number of this region\r\n    /// @dev Updated when #_summonCultists is called\r\n    function lastCultistsSummonIntervalNumber() external view returns (uint256);\r\n\r\n    /// @notice Amount of corruptionIndex in this region\r\n    /// @dev Updated when #increaseCorruptionIndex or #decreaseCorruptionIndex is called\r\n    function corruptionIndex() external view returns (int256);\r\n\r\n    /// @notice Region id\r\n    /// @dev Immutable, initialized on the region creation\r\n    function regionId() external view returns (uint64);\r\n\r\n    /// @notice Last update time\r\n    /// @dev Updated when #updateRegionTime is called\r\n    function lastUpdateTime() external view returns (uint256);\r\n\r\n    /// @notice Last apply state region time\r\n    /// @dev Updated when #updateRegionTime is called\r\n    function lastUpdateRegionTime() external view returns (uint256);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when region initialized\r\n    /// @param workersPoolAddress Workers pool address\r\n    event WorkersPoolCreated(address workersPoolAddress);\r\n\r\n    /// @notice Emitted when region initialized\r\n    /// @param settlementsMarketAddress Settlements market address\r\n    event SettlementsMarketCreated(address settlementsMarketAddress);\r\n\r\n    /// @notice Emitted when region initialized\r\n    /// @param unitsPoolAddress Units pool address\r\n    /// @param unitTypeId Unit type id\r\n    event UnitsPoolCreated(address unitsPoolAddress, bytes32 unitTypeId);\r\n\r\n    /// @notice Emitted when #increaseCorruptionIndex is called\r\n    /// @param settlementAddress An address of settlement which triggered corruptionIndex increase (can be address(0))\r\n    /// @param addedCorruptionIndexAmount Amount of added corruptionIndex\r\n    event CorruptionIndexIncreased(address settlementAddress, uint256 addedCorruptionIndexAmount);\r\n\r\n    /// @notice Emitted when #decreaseCorruptionIndex is called\r\n    /// @param settlementAddress An address of settlement which triggered corruptionIndex decrease (can be address(0))\r\n    /// @param reducedCorruptionIndexAmount Amount of reduced corruptionIndex\r\n    event CorruptionIndexDecreased(address settlementAddress, uint256 reducedCorruptionIndexAmount);\r\n\r\n    /// @notice Emitted when #updateState is called\r\n    /// @param lastUpdateTime Time at which region time changed\r\n    /// @param lastUpdateRegionTime Region time at 'lastUpdateTime'\r\n    event RegionTimeChanged(uint256 lastUpdateTime, uint256 lastUpdateRegionTime);\r\n\r\n    /// @notice Emitted when #handleCultistsSummoned or #handleCultistsDefeated is called\r\n    /// @param newRegionCultistsAmount New region cultists amount\r\n    event RegionCultistsChanged(uint256 newRegionCultistsAmount);\r\n\r\n    /// @notice Emitted when #_summonCultists is called\r\n    /// @param newCultistsSummonIntervalNumber New cultists summon interval number\r\n    event LastCultistsSummonIntervalNumberUpdated(uint256 newCultistsSummonIntervalNumber);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by current era Units\r\n    error OnlyEraUnits();\r\n\r\n    // Functions\r\n\r\n    /// @notice Persists region time upto specified global time\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param globalTime Global time\r\n    function updateRegionTime(uint256 globalTime) external;\r\n\r\n    /// @notice Creates cultists settlement\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param cultistsPosition Cultists position\r\n    function createCultistsSettlement(uint64 cultistsPosition) external;\r\n\r\n    /// @notice Buys specified units for specified amount of tokens in current region\r\n    /// @dev If tokensOwner == address(0) -> tokens will be taken from msg.sender\r\n    /// @dev If tokensOwner != address(0) and tokensOwner has given allowance to msg.sender >= amount of tokens for units -> tokens will be taken from tokensOwner\r\n    /// @param tokensOwner Tokens owner\r\n    /// @param settlementAddress Settlement's address army of which will receive units\r\n    /// @param unitTypeIds Unit type ids\r\n    /// @param unitsAmounts Units amounts\r\n    /// @param maxTokensToSell Maximum amounts of tokens to sell for each unit types\r\n    function buyUnitsBatch(\r\n        address tokensOwner,\r\n        address settlementAddress,\r\n        bytes32[] memory unitTypeIds,\r\n        uint256[] memory unitsAmounts,\r\n        uint256[] memory maxTokensToSell\r\n    ) external;\r\n\r\n    /// @notice Increases corruptionIndex in region\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param settlementAddress An address of the settlement which triggered corruptionIndex increase (address(0) if triggered by non-settlement action)\r\n    /// @param value Amount of corruptionIndex\r\n    function increaseCorruptionIndex(\r\n        address settlementAddress,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Decreases corruptionIndex in region\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param settlementAddress An address of the settlement which triggered corruptionIndex decrease (address(0) if triggered by non-settlement action)\r\n    /// @param value Amount of corruptionIndex\r\n    function decreaseCorruptionIndex(\r\n        address settlementAddress,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Region cultists summon handler\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param value Amount of cultists minted\r\n    function handleCultistsSummoned(\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Region cultists defeat handler\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param value Amount of cultists burned\r\n    function handleCultistsDefeated(\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Calculates penalty according to current cultists count\r\n    /// @dev Uses unit.balanceOf to determine penalty\r\n    /// @return penalty Penalty from cultists\r\n    function getPenaltyFromCultists() external view returns (uint256 penalty);\r\n\r\n    /// @notice Updates region state\r\n    /// @dev This function is called every time when production should be modified\r\n    function updateState() external;\r\n\r\n    /// @notice Calculates region time with provided timestamp\r\n    /// @dev Takes into an account previous value and current cultists penalty and extrapolates to value at provided timestamp\r\n    /// @param timestamp Timestamp\r\n    /// @return regionTime Extrapolated region time\r\n    function getRegionTime(uint256 timestamp) external view returns (uint256 regionTime);\r\n}\r\n"
    },
    "contracts/core/assets/region/Region.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"./IRegion.sol\";\r\nimport \"../unitsPool/IUnitsPool.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../../../const/GameAssetTypes.sol\";\r\n\r\ncontract Region is WorldAsset, IRegion {\r\n    /// @inheritdoc IRegion\r\n    IWorkersPool public override workersPool;\r\n    /// @inheritdoc IRegion\r\n    mapping(bytes32 => IUnitsPool) public override unitsPools;\r\n    /// @inheritdoc IRegion\r\n    ISettlementsMarket public override settlementsMarket;\r\n    /// @inheritdoc IRegion\r\n    ISettlement public override cultistsSettlement;\r\n    /// @inheritdoc IRegion\r\n    uint256 public override lastCultistsSummonIntervalNumber;\r\n    /// @inheritdoc IRegion\r\n    int256 public override corruptionIndex;\r\n    /// @inheritdoc IRegion\r\n    uint64 public override regionId;\r\n    /// @inheritdoc IRegion\r\n    uint256 public override lastUpdateTime;\r\n    /// @inheritdoc IRegion\r\n    uint256 public override lastUpdateRegionTime;\r\n\r\n    /// @dev Only era units modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyEraUnits() {\r\n        _onlyEraUnits();\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        (\r\n            uint64 _regionId\r\n        ) = abi.decode(initParams, (uint64));\r\n\r\n        regionId = _regionId;\r\n        lastUpdateTime = block.timestamp;\r\n        lastUpdateRegionTime = getRegionTime(block.timestamp);\r\n\r\n        IRegistry _registry = registry();\r\n        IWorldAssetFactory factory = worldAssetFactory();\r\n\r\n        // 1. create workers pool\r\n        address workersPoolAddress = factory.create(\r\n            address(world()),\r\n            eraNumber(),\r\n            WORKERS_POOL_GROUP_TYPE_ID,\r\n            BASIC_TYPE_ID,\r\n            abi.encode(address(this))\r\n        );\r\n\r\n        workersPool = IWorkersPool(workersPoolAddress);\r\n        emit WorkersPoolCreated(workersPoolAddress);\r\n\r\n        // 2. create settlements market\r\n        address settlementsMarketAddress = factory.create(\r\n            address(world()),\r\n            eraNumber(),\r\n            SETTLEMENT_MARKET_GROUP_TYPE_ID,\r\n            BASIC_TYPE_ID,\r\n            abi.encode(address(this))\r\n        );\r\n\r\n        settlementsMarket = ISettlementsMarket(settlementsMarketAddress);\r\n        emit SettlementsMarketCreated(settlementsMarketAddress);\r\n\r\n        // 3. create units pool\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n\r\n            address unitsPoolAddress = factory.create(\r\n                address(world()),\r\n                eraNumber(),\r\n                UNITS_POOL_GROUP_TYPE_ID,\r\n                _registry.getUnitPoolType(unitTypeId),\r\n                abi.encode(address(this), unitTypeId)\r\n            );\r\n\r\n            unitsPools[unitTypeId] = IUnitsPool(unitsPoolAddress);\r\n            emit UnitsPoolCreated(unitsPoolAddress, unitTypeId);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IRegion\r\n    function getRegionTime(uint256 timestamp) public override view returns (uint256) {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        uint256 gameBeginTime = world().gameBeginTime();\r\n        if (timestamp < gameBeginTime) {\r\n            timestamp = gameBeginTime;\r\n        }\r\n\r\n        uint256 gameEndTime = world().gameEndTime();\r\n        if (gameEndTime != 0 && timestamp > gameEndTime) {\r\n            timestamp = gameEndTime;\r\n        }\r\n\r\n        uint256 _lastUpdateTime = lastUpdateTime;\r\n        uint256 _lastUpdateRegionTime = lastUpdateRegionTime;\r\n        if (_lastUpdateTime < gameBeginTime) {\r\n            _lastUpdateTime = gameBeginTime;\r\n            _lastUpdateRegionTime = 0;\r\n        }\r\n\r\n        if (timestamp <= _lastUpdateTime) {\r\n            return _lastUpdateRegionTime;\r\n        }\r\n\r\n        uint256 timeDelta = timestamp - _lastUpdateTime;\r\n        uint256 penalty = getPenaltyFromCultists();\r\n\r\n        return _lastUpdateRegionTime + (timeDelta * (1e18 - penalty));\r\n    }\r\n\r\n    /// @inheritdoc IRegion\r\n    function updateState() public override {\r\n        _tryToEndCultistsBattle();\r\n        _tryToSummonCultists();\r\n    }\r\n\r\n    /// @inheritdoc IRegion\r\n    function updateRegionTime(uint256 globalTime) public override onlyWorldAssetFromSameEra {\r\n        if (lastUpdateTime == globalTime) {\r\n            return;\r\n        }\r\n\r\n        lastUpdateRegionTime = getRegionTime(globalTime);\r\n        lastUpdateTime = globalTime;\r\n        emit RegionTimeChanged(lastUpdateTime, lastUpdateRegionTime);\r\n    }\r\n\r\n    /// @inheritdoc IRegion\r\n    function createCultistsSettlement(\r\n        uint64 cultistsPosition\r\n    ) public override onlyWorldAssetFromSameEra {\r\n        address cultistsSettlementAddress = era().createSettlementByType(\r\n            0,\r\n            regionId,\r\n            cultistsPosition,\r\n            CULTISTS_SETTLEMENT_TYPE_ID\r\n        );\r\n\r\n        cultistsSettlement = ISettlement(cultistsSettlementAddress);\r\n\r\n        uint256 penaltyTier = registry().getMaxRegionTier() - world().geography().getRegionTier(regionId);\r\n        uint256 initialCultistsAmount = penaltyTier * registry().getInitialCultistsAmountPerRegionTier();\r\n        _summonCultists(initialCultistsAmount, _getCurrentCultistsSummonIntervalNumber());\r\n\r\n        uint256 initialCorruptionIndexAmount = penaltyTier * registry().getInitialCorruptionIndexAmountPerRegionTier();\r\n        _increaseCorruptionIndex(address(0), initialCorruptionIndexAmount);\r\n    }\r\n\r\n    /// @inheritdoc IRegion\r\n    function buyUnitsBatch(\r\n        address resourcesOwner,\r\n        address settlementAddress,\r\n        bytes32[] memory unitTypeIds,\r\n        uint256[] memory unitsAmounts,\r\n        uint256[] memory maxTokensToSell\r\n    ) public override {\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            unitsPools[unitTypeIds[i]].swapTokensForExactUnitsByRegion(\r\n                resourcesOwner,\r\n                msg.sender,\r\n                settlementAddress,\r\n                unitsAmounts[i],\r\n                maxTokensToSell[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IRegion\r\n    function increaseCorruptionIndex(\r\n        address settlementAddress,\r\n        uint256 value\r\n    ) public override onlyWorldAssetFromSameEra {\r\n        updateState();\r\n\r\n        _increaseCorruptionIndex(\r\n            settlementAddress,\r\n            value\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IRegion\r\n    function decreaseCorruptionIndex(\r\n        address settlementAddress,\r\n        uint256 value\r\n    ) public override onlyWorldAssetFromSameEra {\r\n        updateState();\r\n\r\n        _decreaseCorruptionIndex(\r\n            settlementAddress,\r\n            value\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IRegion\r\n    function handleCultistsSummoned(\r\n        uint256 value\r\n    ) public override onlyEraUnits {\r\n        era().increaseTotalCultists(value);\r\n        emit RegionCultistsChanged(_getCurrentCultistsAmount());\r\n    }\r\n\r\n    /// @inheritdoc IRegion\r\n    function handleCultistsDefeated(\r\n        uint256 value\r\n    ) public override onlyEraUnits {\r\n        era().decreaseTotalCultists(value);\r\n        emit RegionCultistsChanged(_getCurrentCultistsAmount());\r\n    }\r\n\r\n    /// @inheritdoc IRegion\r\n    function getPenaltyFromCultists() public view returns (uint256) {\r\n        uint256 cultistsAmount = _getCurrentCultistsAmount();\r\n        uint256 penalty = cultistsAmount * 1e18 / registry().getMaxCultistsPerRegion();\r\n\r\n        if (penalty > 1e18) {\r\n            return 1e18;\r\n        }\r\n\r\n        return penalty;\r\n    }\r\n\r\n    /// @dev Allows caller to be only current era's units\r\n    function _onlyEraUnits() internal view {\r\n        bytes32 unitTypeId = IUnits(msg.sender).unitTypeId();\r\n        if (address(era().units(unitTypeId)) != msg.sender) revert OnlyEraUnits();\r\n    }\r\n\r\n    /// @dev Tries to end cultists battle (if battle exist)\r\n    function _tryToEndCultistsBattle() internal {\r\n        IBattle cultistsBattle = cultistsSettlement.army().battle();\r\n        if (address(cultistsBattle) != address(0) && !cultistsBattle.isEndedBattle() && cultistsBattle.canEndBattle()) {\r\n            cultistsBattle.endBattle();\r\n        }\r\n    }\r\n\r\n    /// @dev Tries to summons cultists (if conditions are met)\r\n    function _tryToSummonCultists() internal {\r\n        // Cultists are not summoned in inactive era\r\n        if (eraNumber() != world().currentEraNumber()) {\r\n            return;\r\n        }\r\n\r\n        uint256 cultistsSummonIntervalNumberOfCurrenTime = _getCurrentCultistsSummonIntervalNumber();\r\n        if (lastCultistsSummonIntervalNumber >= cultistsSummonIntervalNumberOfCurrenTime) {\r\n            return;\r\n        }\r\n\r\n        uint256 _absCorruptionIndex = corruptionIndex > 0\r\n            ? uint256(corruptionIndex)\r\n            : 0;\r\n\r\n        uint256 cultistsToSummon = 0;\r\n        if (_absCorruptionIndex > 0) {\r\n            uint256 currentCultistsAmount = _getCurrentCultistsAmount();\r\n\r\n            cultistsToSummon = currentCultistsAmount / 2 > _absCorruptionIndex / 10\r\n                ? 0\r\n                : Math.min(\r\n                    MathExtension.roundDownWithPrecision(_absCorruptionIndex / 10 - currentCultistsAmount / 2, 1e18),\r\n                    registry().getMaxCultistsPerRegion() - currentCultistsAmount\r\n                );\r\n        }\r\n\r\n        _summonCultists(cultistsToSummon, cultistsSummonIntervalNumberOfCurrenTime);\r\n    }\r\n\r\n    /// @dev Summons cultists with saving last time cultists were summoned\r\n    function _summonCultists(uint256 cultistsAmountToSummon, uint256 cultistsSummonIntervalNumber) internal {\r\n        era().units(registry().getCultistUnitTypeId()).mint(\r\n            address(cultistsSettlement.army()),\r\n            cultistsAmountToSummon\r\n        );\r\n\r\n        lastCultistsSummonIntervalNumber = cultistsSummonIntervalNumber;\r\n        emit LastCultistsSummonIntervalNumberUpdated(cultistsSummonIntervalNumber);\r\n    }\r\n\r\n    /// @dev Calculates cultists summon interval number of current time\r\n    function _getCurrentCultistsSummonIntervalNumber() internal view returns (uint256) {\r\n        IRegistry _registry = registry();\r\n        uint256 _epochCreationTime = Math.max(era().creationTime(), world().gameBeginTime());\r\n        return block.timestamp > _epochCreationTime\r\n            ? (block.timestamp - _epochCreationTime) / (_registry.getCultistsSummonDelay() / _registry.getGlobalMultiplier())\r\n            : 0;\r\n    }\r\n\r\n    /// @dev Calculates current cultists amount\r\n    function _getCurrentCultistsAmount() internal view returns (uint256) {\r\n        return era().units(registry().getCultistUnitTypeId()).balanceOf(address(cultistsSettlement.army()));\r\n    }\r\n\r\n    /// @dev Increases corruptionIndex\r\n    function _increaseCorruptionIndex(\r\n        address settlementAddress,\r\n        uint256 corruptionIndexAmount\r\n    ) internal {\r\n        // If action is happening in old era, it does not affect corruptionIndex\r\n        if (eraNumber() != world().currentEraNumber()) {\r\n            return;\r\n        }\r\n\r\n        corruptionIndex += int256(corruptionIndexAmount);\r\n        emit CorruptionIndexIncreased(settlementAddress, corruptionIndexAmount);\r\n\r\n        if (settlementAddress != address(0)) {\r\n            ISettlement(settlementAddress).increaseProducedCorruptionIndex(corruptionIndexAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev Decreases corruptionIndex\r\n    function _decreaseCorruptionIndex(\r\n        address settlementAddress,\r\n        uint256 corruptionIndexAmount\r\n    ) internal {\r\n        // If action is happening in old era, it does not affect corruptionIndex\r\n        if (eraNumber() != world().currentEraNumber()) {\r\n            return;\r\n        }\r\n\r\n        corruptionIndex -= int256(corruptionIndexAmount);\r\n        emit CorruptionIndexDecreased(settlementAddress, corruptionIndexAmount);\r\n\r\n        if (settlementAddress != address(0)) {\r\n            ISettlement(settlementAddress).decreaseProducedCorruptionIndex(corruptionIndexAmount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/settlement/CultistsSettlement.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../region/IRegion.sol\";\r\nimport \"./ISettlement.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../../../const/GameAssetTypes.sol\";\r\n\r\ncontract CultistsSettlement is WorldAsset, ISettlement {\r\n    /// @inheritdoc ISettlement\r\n    IRegion public override relatedRegion;\r\n    /// @inheritdoc ISettlement\r\n    IArmy public override army;\r\n    /// @inheritdoc ISettlement\r\n    uint64 public override position;\r\n\r\n    /// @notice Thrown when attempting to call action which is disabled\r\n    error Disabled();\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        (\r\n            uint256 createdWithBannerId,\r\n            address regionAddress,\r\n            uint64 settlementPosition\r\n        ) = abi.decode(initParams, (uint256, address, uint64));\r\n\r\n        relatedRegion = IRegion(regionAddress);\r\n        position = settlementPosition;\r\n\r\n        _createArmy();\r\n    }\r\n\r\n    /// @notice For cultists settlement any provided address is not ruler\r\n    /// @inheritdoc ISettlement\r\n    function isRuler(address potentialRuler) public view override returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    // Stubs for ISettlement\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function getSettlementOwner() public view override returns (address) {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function addGovernor(address governorAddress) public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function removeGovernor(address governorAddress) public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function removeGovernors() public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function swapProsperityForExactWorkers(uint256 workersToBuy, uint256 maxProsperityToSell) public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function bannerId() public view returns (uint256) {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function siege() public view returns (ISiege) {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function producedCorruptionIndex() public view returns (int256) {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function buildings(bytes32 buildingTypeId) public view returns (IBuilding) {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function currentGovernorsGeneration() public view returns (uint256) {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function governors(uint256 era, address isGovernor) public view returns (bool) {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function extendedProsperityAmount() public view returns (uint256) {\r\n        revert Disabled();\r\n    }\r\n\r\n    // Functions\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function assignResourcesAndWorkersToBuilding(\r\n        address resourcesOwner,\r\n        address buildingAddress,\r\n        uint256 workersAmount,\r\n        bytes32[] memory resourceTypeIds,\r\n        uint256[] memory resourcesAmounts\r\n    ) public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function withdrawResources(\r\n        bytes32 resourceTypeId,\r\n        address to,\r\n        uint256 amount\r\n    ) public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function updateFortHealth() public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function updateProsperityAmount() public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function extendProsperity(uint256 prosperityAmount) public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function beginTileCapture(uint64 position, uint256 prosperityStake) public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function cancelTileCapture(uint64 position) public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function giveUpCapturedTile(uint64 position) public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function claimCapturedTile(uint64 position) public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function increaseProducedCorruptionIndex(uint256 amount) public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function decreaseProducedCorruptionIndex(uint256 amount) public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function isRottenSettlement() public view override returns (bool) {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function destroyRottenSettlement() public override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For cultists settlement this function is disabled\r\n    /// @inheritdoc ISettlement\r\n    function payToDecreaseCorruptionIndex(uint256 tokensAmount) public payable override {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @dev Creates settlements army\r\n    function _createArmy() internal {\r\n        address armyAddress = worldAssetFactory().create(\r\n            address(world()),\r\n            eraNumber(),\r\n            ARMY_GROUP_TYPE_ID,\r\n            BASIC_TYPE_ID,\r\n            abi.encode(address(this))\r\n        );\r\n\r\n        army = IArmy(armyAddress);\r\n\r\n        emit ArmyCreated(armyAddress, position);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/settlement/ISettlement.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../building/IBuilding.sol\";\r\nimport \"../army/IArmy.sol\";\r\nimport \"../siege/ISiege.sol\";\r\nimport \"../region/IRegion.sol\";\r\n\r\n/// @title Settlement interface\r\n/// @notice Functions to read state/modify state in order to get current settlement parameters and/or interact with it\r\ninterface ISettlement {\r\n\r\n    // State variables\r\n\r\n    /// @notice Region to which this settlement belongs\r\n    /// @dev Immutable, initialized on the settlement creation\r\n    function relatedRegion() external view returns (IRegion);\r\n\r\n    /// @notice Banner token id to which current settlement belongs\r\n    /// @dev Immutable, initialized on the settlement creation\r\n    function bannerId() external view returns (uint256);\r\n\r\n    /// @notice Siege of the settlement\r\n    /// @dev If any army is besieging settlement not address(0), otherwise address(0)\r\n    function siege() external view returns (ISiege);\r\n\r\n    /// @notice Mapping containing settlements buildings\r\n    /// @dev Types of buildings supported can be queried from registry\r\n    function buildings(bytes32 buildingTypeId) external view returns (IBuilding);\r\n\r\n    /// @notice Current governors generation\r\n    /// @dev Modified when #removeGovernors is called\r\n    function currentGovernorsGeneration() external view returns (uint256);\r\n\r\n    /// @notice Current settlements governors\r\n    /// @dev Modified when #addGovernor or #removeGovernor is called\r\n    function governors(uint256 era, address isGovernor) external view returns (bool);\r\n\r\n    /// @notice Settlements army\r\n    /// Immutable, initialized on the settlement creation\r\n    function army() external view returns (IArmy);\r\n\r\n    /// @notice Amount of extended prosperity (currently gained units liquidation)\r\n    /// @dev Used for determination amount of real prosperity this settlement has\r\n    function extendedProsperityAmount() external view returns (uint256);\r\n\r\n    /// @notice Position on which settlement is created\r\n    /// @dev Immutable, initialized on the settlement creation\r\n    function position() external view returns (uint64);\r\n\r\n    /// @notice Amount of corruptionIndex produced by this settlement\r\n    /// @dev Modified when #increaseProducedCorruptionIndex or #decreaseProducedCorruptionIndex is called\r\n    function producedCorruptionIndex() external view returns (int256);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when new building is placed, all building are placed on settlement creation\r\n    /// @param buildingAddress New building address\r\n    /// @param buildingTypeId Building type id\r\n    event BuildingCreated(address buildingAddress, bytes32 buildingTypeId);\r\n\r\n    /// @notice Emitted when settlements army is created, is it created on settlement creation\r\n    /// @param armyAddress Army address\r\n    /// @param position Position\r\n    event ArmyCreated(address armyAddress, uint64 position);\r\n\r\n    /// @notice Emitted when siege is created on settlement\r\n    /// @param siegeAddress Siege address\r\n    event SiegeCreated(address siegeAddress);\r\n\r\n    /// @notice Emitted when #addGovernor or #removeGovernor is called\r\n    /// @param currentGovernorsGeneration Current governors generation\r\n    /// @param governorAddress Address of the governor event is applicable\r\n    /// @param modifiedByAddress Address which modified governor status\r\n    /// @param newStatus Is governor became active/inactive\r\n    event GovernorStatusChanged(uint256 currentGovernorsGeneration, address governorAddress, address modifiedByAddress, bool newStatus);\r\n\r\n    /// @notice Emitted when #removeGovernors is called\r\n    /// @param newGovernorsGeneration New governors generation\r\n    event GovernorsGenerationChanged(uint256 newGovernorsGeneration);\r\n\r\n    /// @notice Emitted when #destroyRottenSettlement is called\r\n    event Destroyed();\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which can be called only by settlement owner\r\n    error OnlySettlementOwner();\r\n\r\n    /// @notice Thrown when attempting to call action which can be called only by ruler or world asset\r\n    error OnlyRulerOrWorldAsset();\r\n\r\n    /// @notice Thrown when attempting to add governor by address which is neither settlement owner or another governor\r\n    error GovernorCannotBeAddedIfSenderNotSettlementOwnerOrAnotherGovernor();\r\n\r\n    /// @notice Thrown when attempting to destroy settlement but its not rotten\r\n    error SettlementCannotBeDestroyedIfItsNotRotten();\r\n\r\n    /// @notice Thrown when attempting to destroy settlement when it is already rebuilt\r\n    error SettlementCannotBeDestroyedIfItsAlreadyRebuilt();\r\n\r\n    /// @notice Thrown when attempting to transfer workers from settlement with non integer value\r\n    error SettlementCannotSendWorkersWithFractions();\r\n\r\n    /// @notice Thrown when attempting to transfer workers from settlement to building over maximum allowed workers capacity\r\n    error SettlementCannotSendWorkersToBuildingOverMaximumAllowedCapacity();\r\n\r\n    /// @notice Thrown when attempting to decrease corruptionIndex via payment in inactive era\r\n    error SettlementCannotDecreaseCorruptionIndexViaPaymentInInactiveEra();\r\n\r\n    /// @notice Thrown when attempting to specify 'tokensAmount' parameter anything but zero whenever world.erc20ForSettlementPurchase is zero address\r\n    error SettlementCannotDecreaseCorruptionIndexViaPaymentWrongParamProvided();\r\n\r\n    // Functions\r\n\r\n    /// @notice Withdraws resources from settlement to specified address\r\n    /// @dev In case if someone accidentally transfers game resource to the settlement\r\n    /// @param resourceTypeId Resource type id\r\n    /// @param to Address that will receive resources\r\n    /// @param amount Amount to transfer\r\n    function withdrawResources(\r\n        bytes32 resourceTypeId,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /// @notice Transfers game resources from msg.sender and workers from settlement to building\r\n    /// @dev Assigns resources+workers to building in single transaction\r\n    /// @dev If resourcesOwner == address(0) -> resources will be taken from msg.sender\r\n    /// @dev If resourcesOwner != address(0) and resourcesOwner has given allowance to msg.sender >= resourcesAmount -> resources will be taken from resourcesOwner\r\n    /// @param buildingAddress Building address\r\n    /// @param workersAmount Workers amount (in 1e18 precision)\r\n    /// @param resourceTypeIds Resource type ids\r\n    /// @param resourcesAmounts Resources amounts\r\n    function assignResourcesAndWorkersToBuilding(\r\n        address resourcesOwner,\r\n        address buildingAddress,\r\n        uint256 workersAmount,\r\n        bytes32[] memory resourceTypeIds,\r\n        uint256[] memory resourcesAmounts\r\n    ) external;\r\n\r\n    /// @notice Updates settlement health to current block\r\n    /// @dev Can be called by everyone\r\n    function updateFortHealth() external;\r\n\r\n    /// @notice Applies production of every building which produces prosperity\r\n    /// @dev Can be used by everyone\r\n    function updateProsperityAmount() external;\r\n\r\n    /// @notice Calculates current settlement owner\r\n    /// @dev Settlements owner is considered an address, which holds bannerId Nft\r\n    /// @return settlementOwner Settlement owner\r\n    function getSettlementOwner() external view returns (address settlementOwner);\r\n\r\n    /// @notice Adds settlement governor\r\n    /// @dev Settlement owner and other governor can add governor\r\n    /// @param governorAddress Address to add as the governor\r\n    function addGovernor(address governorAddress) external;\r\n\r\n    /// @notice Removes settlement governor\r\n    /// @dev Only settlement owner can remove governor\r\n    /// @param governorAddress Address to remove from governors\r\n    function removeGovernor(address governorAddress) external;\r\n\r\n    /// @notice Removes all settlement governors\r\n    /// @dev Only settlement owner can remove all governors\r\n    function removeGovernors() external;\r\n\r\n    /// @notice Swaps current settlement prosperity for exact workers\r\n    /// @dev Only ruler or world asset can perform swap\r\n    /// @param workersToBuy Exact amount of workers to buy\r\n    /// @param maxProsperityToSell Maximum amount of prosperity to spend for exact workers\r\n    function swapProsperityForExactWorkers(uint256 workersToBuy, uint256 maxProsperityToSell) external;\r\n\r\n    /// @notice Calculates whether provided address is settlement ruler or not\r\n    /// @dev Settlements ruler is an address which owns settlement or an address(es) by which settlement is/are governed\r\n    /// @param potentialRuler Address to check\r\n    /// @return isRuler Banner, whether specified address is ruler or not\r\n    function isRuler(address potentialRuler) external view returns (bool isRuler);\r\n\r\n    /// @notice Extends current settlement prosperity by specified amount\r\n    /// @dev Even though function is opened it can be called only by world or world asset\r\n    /// @param prosperityAmount Amount of prosperity to which extend current prosperity\r\n    function extendProsperity(uint256 prosperityAmount) external;\r\n\r\n    /// @notice Begins tile capture\r\n    /// @param position Position\r\n    /// @param prosperityStake Prosperity stake\r\n    function beginTileCapture(uint64 position, uint256 prosperityStake) external;\r\n\r\n    /// @notice Cancels tile capture\r\n    /// @param position Position\r\n    function cancelTileCapture(uint64 position) external;\r\n\r\n    /// @notice Gives up captured tile\r\n    /// @param position Position\r\n    function giveUpCapturedTile(uint64 position) external;\r\n\r\n    /// @notice Claims captured tile\r\n    /// @param position Position\r\n    function claimCapturedTile(uint64 position) external;\r\n\r\n    /// @notice Increases produced corruptionIndex\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param amount Amount\r\n    function increaseProducedCorruptionIndex(uint256 amount) external;\r\n\r\n    /// @notice Decreases produced corruptionIndex\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param amount Amount\r\n    function decreaseProducedCorruptionIndex(uint256 amount) external;\r\n\r\n    /// @notice Calculates is settlement rotten or not\r\n    /// @return isRottenSettlement Is rotten settlement\r\n    function isRottenSettlement() external returns (bool isRottenSettlement);\r\n\r\n    /// @notice Destroys current settlement\r\n    /// @dev Settlement will be removed only from crossErasMemory in order to give free space to new settlements\r\n    function destroyRottenSettlement() external;\r\n\r\n    /// @notice Lowers settlement corruptionIndex by paying to the reward pool\r\n    /// @dev If world.erc20ForSettlementPurchase is address zero -> function is expected to receive Ether as msg.value in order to decrease corruptionIndex. If not address zero -> 'tokensAmount' parameter is used and it will be taken via 'erc20.transferFrom'\r\n    /// @dev Only settlement in active era can decrease its corruptionIndex\r\n    /// @param tokensAmount Amount of tokens will be taken from sender (if world.erc20ForSettlementPurchase is not address zero)\r\n    function payToDecreaseCorruptionIndex(uint256 tokensAmount) external payable;\r\n}\r\n"
    },
    "contracts/core/assets/settlement/Settlement.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../region/IRegion.sol\";\r\nimport \"./ISettlement.sol\";\r\nimport \"../building/impl/IFort.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../../../const/GameAssetTypes.sol\";\r\nimport \"../../../periphery/ProxyReentrancyGuard.sol\";\r\n\r\ncontract Settlement is WorldAsset, ISettlement, ProxyReentrancyGuard {\r\n    /// @inheritdoc ISettlement\r\n    IRegion public override relatedRegion;\r\n    /// @inheritdoc ISettlement\r\n    uint256 public override bannerId;\r\n    /// @inheritdoc ISettlement\r\n    ISiege public override siege;\r\n    /// @inheritdoc ISettlement\r\n    mapping(bytes32 => IBuilding) public override buildings;\r\n    /// @inheritdoc ISettlement\r\n    uint256 public override currentGovernorsGeneration;\r\n    /// @inheritdoc ISettlement\r\n    mapping(uint256 => mapping(address => bool)) public override governors;\r\n    /// @inheritdoc ISettlement\r\n    IArmy public override army;\r\n    /// @inheritdoc ISettlement\r\n    uint256 public override extendedProsperityAmount;\r\n    /// @inheritdoc ISettlement\r\n    uint64 public override position;\r\n    /// @inheritdoc ISettlement\r\n    int256 public override producedCorruptionIndex;\r\n\r\n    /// @dev Only settlement owner modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlySettlementOwner() {\r\n        _onlySettlementOwner();\r\n        _;\r\n    }\r\n\r\n    /// @dev Only ruler or world asset modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyRulerOrWorldAsset() {\r\n        _onlyRulerOrWorldAsset();\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        (\r\n            uint256 createdWithBannerId,\r\n            address regionAddress,\r\n            uint64 settlementPosition\r\n        ) = abi.decode(initParams, (uint256, address, uint64));\r\n\r\n        relatedRegion = IRegion(regionAddress);\r\n        bannerId = createdWithBannerId;\r\n        position = settlementPosition;\r\n\r\n        _createBuildings();\r\n        _createArmy();\r\n        _createSiege();\r\n        _mintInitialWorkers();\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function getSettlementOwner() public view override returns (address) {\r\n        return world().bannerContract().ownerOf(bannerId);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function updateProsperityAmount() public override {\r\n        bytes32[] memory buildingTypeIds = registry().getBuildingTypeIds();\r\n\r\n        for (uint256 i = 0; i < buildingTypeIds.length; i++) {\r\n            buildings[buildingTypeIds[i]].updateState();\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function withdrawResources(\r\n        bytes32 resourceTypeId,\r\n        address to,\r\n        uint256 amount\r\n    ) public override onlyRulerOrWorldAsset {\r\n        era().resources(resourceTypeId).transfer(to, amount);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function assignResourcesAndWorkersToBuilding(\r\n        address resourcesOwner,\r\n        address buildingAddress,\r\n        uint256 workersAmount,\r\n        bytes32[] memory resourceTypeIds,\r\n        uint256[] memory resourcesAmounts\r\n    ) public override onlyActiveGame onlyRulerOrWorldAsset {\r\n        if (workersAmount > 0) {\r\n            _transferWorkers(buildingAddress, workersAmount);\r\n        }\r\n\r\n        for (uint256 i = 0; i < resourceTypeIds.length; i++) {\r\n            IResource resource = era().resources(resourceTypeIds[i]);\r\n\r\n            if (resourcesOwner == address(0)) {\r\n                resource.transferFrom(msg.sender, buildingAddress, resourcesAmounts[i]);\r\n            } else {\r\n                resource.spendAllowance(resourcesOwner, msg.sender, resourcesAmounts[i]);\r\n                resource.transferFrom(resourcesOwner, buildingAddress, resourcesAmounts[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function updateFortHealth() public override {\r\n        buildings[FORT_TYPE_ID].updateState();\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function addGovernor(address governorAddress) public override onlyActiveGame {\r\n        if (msg.sender != getSettlementOwner() && !governors[currentGovernorsGeneration][msg.sender]) revert GovernorCannotBeAddedIfSenderNotSettlementOwnerOrAnotherGovernor();\r\n        governors[currentGovernorsGeneration][governorAddress] = true;\r\n        emit GovernorStatusChanged(currentGovernorsGeneration, governorAddress, msg.sender, true);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function removeGovernor(address governorAddress) public override onlyActiveGame onlySettlementOwner {\r\n        governors[currentGovernorsGeneration][governorAddress] = false;\r\n        emit GovernorStatusChanged(currentGovernorsGeneration, governorAddress, msg.sender, false);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function removeGovernors() public override onlyActiveGame onlySettlementOwner {\r\n        currentGovernorsGeneration++;\r\n        emit GovernorsGenerationChanged(currentGovernorsGeneration);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function swapProsperityForExactWorkers(uint256 workersToBuy, uint256 maxProsperityToSell)\r\n        public\r\n        override\r\n        onlyActiveGame\r\n        onlyRulerOrWorldAsset\r\n    {\r\n        uint256 newWorkers = relatedRegion.workersPool().swapProsperityForExactWorkers(address(this), workersToBuy, maxProsperityToSell);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function isRuler(address potentialRuler) public view override returns (bool) {\r\n        return getSettlementOwner() == potentialRuler || governors[currentGovernorsGeneration][potentialRuler];\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function extendProsperity(uint256 prosperityAmount) public override onlyWorldAssetFromSameEra {\r\n        era().prosperity().mint(address(this), prosperityAmount);\r\n        extendedProsperityAmount += prosperityAmount;\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function beginTileCapture(uint64 position, uint256 prosperityStake) public override onlyActiveGame onlyRulerOrWorldAsset {\r\n        era().tileCapturingSystem().beginTileCapture(address(this), position, prosperityStake);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function cancelTileCapture(uint64 position) public override onlyActiveGame onlyRulerOrWorldAsset {\r\n        era().tileCapturingSystem().cancelTileCapture(address(this), position);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function giveUpCapturedTile(uint64 position) public override onlyActiveGame onlyRulerOrWorldAsset {\r\n        era().tileCapturingSystem().giveUpCapturedTile(address(this), position);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function claimCapturedTile(uint64 position) public override onlyActiveGame onlyRulerOrWorldAsset {\r\n        era().tileCapturingSystem().claimTileCapture(address(this), position);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function increaseProducedCorruptionIndex(uint256 amount) public override onlyWorldAssetFromSameEra {\r\n        producedCorruptionIndex += int256(amount);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function decreaseProducedCorruptionIndex(uint256 amount) public override onlyWorldAssetFromSameEra {\r\n        producedCorruptionIndex -= int256(amount);\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function isRottenSettlement() public view override returns (bool) {\r\n        uint256 currentActiveEraNumber = world().currentEraNumber();\r\n        if (eraNumber() >= currentActiveEraNumber) {\r\n            return false;\r\n        }\r\n\r\n        if (producedCorruptionIndex <= 0) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function destroyRottenSettlement() public override onlyActiveGame {\r\n        if (!isRottenSettlement()) revert SettlementCannotBeDestroyedIfItsNotRotten();\r\n\r\n        ICrossErasMemory crossErasMemory = world().crossErasMemory();\r\n        if (address(crossErasMemory.settlementByPosition(position)) != address(this)) revert SettlementCannotBeDestroyedIfItsAlreadyRebuilt();\r\n\r\n        // 1. freshRegion.settlementMarket.updateState() in order to persist current price\r\n        IEra currentActiveEra = world().eras(world().currentEraNumber());\r\n        IRegion sameRegionOfCurrentActiveEra = currentActiveEra.regions(relatedRegion.regionId());\r\n        ISettlementsMarket settlementMarket = sameRegionOfCurrentActiveEra.settlementsMarket();\r\n        settlementMarket.updateState();\r\n\r\n        // 2.\r\n        // - remove from CEM.settlements & CEM.userSettlements (in order to free up map slot, free up banner)\r\n        // (it will cause -> oldEra.settlements[pos] oldEra.userSettlements[nftId] will have data but CEM will not)\r\n        // - decrement CEM.regionSettlementsCount\r\n        crossErasMemory.removeUserSettlement(address(this));\r\n\r\n        emit Destroyed();\r\n    }\r\n\r\n    /// @inheritdoc ISettlement\r\n    function payToDecreaseCorruptionIndex(uint256 tokensAmount)\r\n        public\r\n        payable\r\n        override\r\n        onlyActiveGame\r\n        nonReentrant\r\n    {\r\n        if (eraNumber() != world().currentEraNumber()) revert SettlementCannotDecreaseCorruptionIndexViaPaymentInInactiveEra();\r\n\r\n        IERC20 erc20ForSettlementPurchase = world().erc20ForSettlementPurchase();\r\n        bool isNativeCurrency = address(erc20ForSettlementPurchase) == address(0);\r\n\r\n        if (isNativeCurrency && tokensAmount != 0) revert SettlementCannotDecreaseCorruptionIndexViaPaymentWrongParamProvided();\r\n\r\n        uint256 _tokensAmount = isNativeCurrency\r\n            ? msg.value\r\n            : tokensAmount;\r\n\r\n        if (isNativeCurrency) {\r\n            Address.sendValue(payable(address(world().rewardPool())), _tokensAmount);\r\n        } else {\r\n            SafeERC20.safeTransferFrom(\r\n                erc20ForSettlementPurchase,\r\n                msg.sender,\r\n                address(world().rewardPool()),\r\n                _tokensAmount\r\n            );\r\n        }\r\n\r\n        uint256 currentRewardPoolTokenPrice = world().rewardPool().getCurrentPrice();\r\n        uint256 ingotsEquivalentOfTokensAmount = _tokensAmount * currentRewardPoolTokenPrice / 1e18;\r\n        uint256 corruptionIndexEquivalentOfIngots = ingotsEquivalentOfTokensAmount * registry().getCorruptionIndexByResource(INGOT_TYPE_ID) / 1e18;\r\n        uint256 corruptionIndexForTokensAmount = corruptionIndexEquivalentOfIngots * registry().getSettlementPayToDecreaseCorruptionIndexPenaltyMultiplier() / 1e18;\r\n\r\n        relatedRegion.decreaseCorruptionIndex(address(this), corruptionIndexForTokensAmount);\r\n    }\r\n\r\n    /// @dev Allows caller to be settlement owner\r\n    function _onlySettlementOwner() internal view {\r\n        if (msg.sender != getSettlementOwner()) revert OnlySettlementOwner();\r\n    }\r\n\r\n    /// @dev Allows caller to be settlement ruler or world asset\r\n    function _onlyRulerOrWorldAsset() internal view {\r\n        if (!isRuler(msg.sender) && world().worldAssets(eraNumber(), msg.sender) == bytes32(0)) revert OnlyRulerOrWorldAsset();\r\n    }\r\n\r\n    /// @dev Transfers workers to specified building address\r\n    function _transferWorkers(\r\n        address buildingAddress,\r\n        uint256 workersAmount\r\n    ) internal {\r\n        if (!MathExtension.isIntegerWithPrecision(workersAmount, 1e18)) revert SettlementCannotSendWorkersWithFractions();\r\n\r\n        uint256 newWorkersAmount = IBuilding(buildingAddress).getAssignedWorkers() + workersAmount;\r\n        uint256 availableForAdvancedProductionWorkersCapacity = IBuilding(buildingAddress).getAvailableForAdvancedProductionWorkersCapacity();\r\n        if (newWorkersAmount > availableForAdvancedProductionWorkersCapacity) revert SettlementCannotSendWorkersToBuildingOverMaximumAllowedCapacity();\r\n\r\n        era().workers().transfer(buildingAddress, workersAmount);\r\n    }\r\n\r\n    /// @dev Mints initial settlement workers\r\n    function _mintInitialWorkers() internal {\r\n        era().workers().mint(address(this), 7e18);\r\n    }\r\n\r\n    /// @dev Creates settlements buildings\r\n    function _createBuildings() internal {\r\n        bytes32[] memory buildingTypeIds = registry().getBuildingTypeIds();\r\n        for (uint256 i = 0; i < buildingTypeIds.length; i++) {\r\n            _createBuilding(buildingTypeIds[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Creates settlements army\r\n    function _createArmy() internal {\r\n        address newArmyAddress = worldAssetFactory().create(\r\n            address(world()),\r\n            eraNumber(),\r\n            ARMY_GROUP_TYPE_ID,\r\n            BASIC_TYPE_ID,\r\n            abi.encode(address(this))\r\n        );\r\n\r\n        army = IArmy(newArmyAddress);\r\n\r\n        emit ArmyCreated(newArmyAddress, position);\r\n    }\r\n\r\n    /// @dev Creates building\r\n    function _createBuilding(bytes32 buildingTypeId) internal {\r\n        address newBuildingAddress = worldAssetFactory().create(\r\n            address(world()),\r\n            eraNumber(),\r\n            BUILDING_GROUP_TYPE_ID,\r\n            buildingTypeId,\r\n            abi.encode(address(this), buildingTypeId)\r\n        );\r\n\r\n        buildings[buildingTypeId] = IBuilding(newBuildingAddress);\r\n\r\n        emit BuildingCreated(newBuildingAddress, buildingTypeId);\r\n    }\r\n\r\n    /// @dev Creates new siege\r\n    function _createSiege() internal {\r\n        address newSiegeAddress = worldAssetFactory().create(\r\n            address(world()),\r\n            eraNumber(),\r\n            SIEGE_GROUP_TYPE_ID,\r\n            BASIC_TYPE_ID,\r\n            abi.encode(address(this))\r\n        );\r\n\r\n        siege = ISiege(newSiegeAddress);\r\n\r\n        emit SiegeCreated(newSiegeAddress);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/settlementsMarket/ISettlementMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../region/IRegion.sol\";\r\n\r\n/// @title Region settlements market interface\r\n/// @notice Functions to read state/modify state in order to buy settlement\r\ninterface ISettlementsMarket {\r\n\r\n    // State variables\r\n\r\n    /// @notice Region to which this market belongs\r\n    /// @dev Immutable, initialized on the market creation\r\n    function relatedRegion() external view returns (IRegion);\r\n\r\n    /// @notice Time at which market was created\r\n    /// @dev Immutable, initialized on the market creation\r\n    function marketCreationTime() external view returns (uint256);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when #buySettlement is called\r\n    /// @param settlementAddress Settlement address\r\n    /// @param settlementCost Settlement cost\r\n    event SettlementBought(address settlementAddress, uint256 settlementCost);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to buy settlement for free by mighty creator after game began\r\n    error SettlementCannotBeBoughtForFreeAfterGameBegan();\r\n\r\n    /// @notice Thrown when attempting to buy settlement for specified banner nft id and not owning it\r\n    error SettlementCannotBeBoughtForNotOwnerBannerNft();\r\n\r\n    /// @notice Thrown when attempting to buy settlement on non existent position\r\n    error SettlementCannotBeBoughtOnNonExistentPosition();\r\n\r\n    /// @notice Thrown when attempting to buy settlement on position which is not related to this settlement market\r\n    error SettlementCannotBeBoughtOnPositionWhichIsNotRelatedToThisSettlementMarket();\r\n\r\n    /// @notice Thrown when attempting to buy settlement due to new settlement cost is higher than max tokens to use specified\r\n    error SettlementCannotBeBoughtDueToCostIsHigherThanMaxTokensToUseSpecified();\r\n\r\n    /// @notice Thrown when attempting to buy settlement due to insufficient value sent (only if world.erc20ForSettlementPurchase == address(0), which is equivalent of native token)\r\n    error SettlementCannotBeBoughtDueInsufficientValueSent();\r\n\r\n    // Functions\r\n\r\n    /// @notice Updates settlement market state to the current block\r\n    /// @dev Called on every action which are based on settlement market state\r\n    function updateState() external;\r\n\r\n    /// @notice Buys settlement in region\r\n    /// @dev Even though function is opened, it can only be called by mighty creator and only before game begin time\r\n    /// @param position Position\r\n    /// @param bannerId MithraeumBanners token id which will represent to which settlement will be attached to\r\n    function buySettlementForFreeByMightyCreator(\r\n        uint64 position,\r\n        uint256 bannerId\r\n    ) external;\r\n\r\n    /// @notice Buys settlement in region\r\n    /// @dev Tokens will be deducted from msg.sender\r\n    /// @param position Position\r\n    /// @param bannerId MithraeumBanners token id which will represent to which settlement will be attached to\r\n    /// @param maxTokensToUse Maximum amount of tokens to be withdrawn for settlement\r\n    function buySettlement(\r\n        uint64 position,\r\n        uint256 bannerId,\r\n        uint256 maxTokensToUse\r\n    ) external payable;\r\n\r\n    /// @notice Returns amount of tokens new settlement will cost\r\n    /// @dev Calculates cost of placing new settlement in tokens\r\n    /// @param timestamp Time at which calculate new settlement cost. If timestamp=0 -> calculates as block.timestamp\r\n    /// @return cost Amount of tokens new settlement will cost\r\n    function getNewSettlementCost(uint256 timestamp) external view returns (uint256 cost);\r\n}\r\n"
    },
    "contracts/core/assets/settlementsMarket/SettlementMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./ISettlementMarket.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../../../libraries/ABDKMath64x64.sol\";\r\nimport \"../../../periphery/ProxyReentrancyGuard.sol\";\r\n\r\ncontract SettlementsMarket is WorldAsset, ISettlementsMarket, ProxyReentrancyGuard {\r\n    /// @inheritdoc ISettlementsMarket\r\n    IRegion public override relatedRegion;\r\n    /// @inheritdoc ISettlementsMarket\r\n    uint256 public override marketCreationTime;\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        (address regionAddress) = abi.decode(initParams, (address));\r\n\r\n        relatedRegion = IRegion(regionAddress);\r\n        marketCreationTime = block.timestamp;\r\n    }\r\n\r\n    /// @inheritdoc ISettlementsMarket\r\n    function updateState() public override {\r\n        uint64 regionId = relatedRegion.regionId();\r\n\r\n        ICrossErasMemory crossErasMemory = world().crossErasMemory();\r\n\r\n        uint256 currentTime = _getCurrentTime();\r\n        if (crossErasMemory.regionSettlementPriceUpdateTime(regionId) == currentTime) {\r\n            return;\r\n        }\r\n\r\n        crossErasMemory.changeRegionSettlementPrice(\r\n            regionId,\r\n            getNewSettlementCost(currentTime),\r\n            currentTime\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc ISettlementsMarket\r\n    function buySettlementForFreeByMightyCreator(\r\n        uint64 position,\r\n        uint256 bannerId\r\n    ) public override onlyMightyCreator {\r\n        updateState();\r\n\r\n        if (block.timestamp >= world().gameBeginTime()) revert SettlementCannotBeBoughtForFreeAfterGameBegan();\r\n\r\n        address owner = world().bannerContract().ownerOf(bannerId);\r\n        if (msg.sender != owner) revert SettlementCannotBeBoughtForNotOwnerBannerNft();\r\n\r\n        IGeography geography = world().geography();\r\n        (uint64 regionId, bool isPositionExist) = geography.getRegionIdByPosition(position);\r\n\r\n        if (!isPositionExist) revert SettlementCannotBeBoughtOnNonExistentPosition();\r\n        if (regionId != relatedRegion.regionId()) revert SettlementCannotBeBoughtOnPositionWhichIsNotRelatedToThisSettlementMarket();\r\n\r\n        uint256 newSettlementCost = getNewSettlementCost(block.timestamp);\r\n\r\n        address settlementAddress = era().createUserSettlement(\r\n            position,\r\n            regionId,\r\n            bannerId\r\n        );\r\n\r\n        // Bump settlement price after purchase\r\n        uint256 bumpedSettlementPrice = newSettlementCost * registry().getNewSettlementPriceIncreaseMultiplier() / 1e18;\r\n        world().crossErasMemory().changeRegionSettlementPrice(\r\n            relatedRegion.regionId(),\r\n            bumpedSettlementPrice,\r\n            block.timestamp\r\n        );\r\n\r\n        emit SettlementBought(settlementAddress, 0);\r\n    }\r\n\r\n    /// @inheritdoc ISettlementsMarket\r\n    function buySettlement(\r\n        uint64 position,\r\n        uint256 bannerId,\r\n        uint256 maxTokensToUse\r\n    ) public payable override onlyActiveGame nonReentrant {\r\n        updateState();\r\n\r\n        address owner = world().bannerContract().ownerOf(bannerId);\r\n        if (msg.sender != owner) revert SettlementCannotBeBoughtForNotOwnerBannerNft();\r\n\r\n        IGeography geography = world().geography();\r\n        (uint64 regionId, bool isPositionExist) = geography.getRegionIdByPosition(position);\r\n\r\n        if (!isPositionExist) revert SettlementCannotBeBoughtOnNonExistentPosition();\r\n        if (regionId != relatedRegion.regionId()) revert SettlementCannotBeBoughtOnPositionWhichIsNotRelatedToThisSettlementMarket();\r\n\r\n        uint256 newSettlementCost = getNewSettlementCost(block.timestamp);\r\n        if (maxTokensToUse < newSettlementCost) revert SettlementCannotBeBoughtDueToCostIsHigherThanMaxTokensToUseSpecified();\r\n\r\n        uint256 amountOfTokensGoingToRegionOwner = newSettlementCost * world().registry().getRegionOwnerSettlementPurchasePercent(geography.getRegionTier(regionId)) / 1e18;\r\n        uint256 amountOfTokensGoingToRewardPool = newSettlementCost - amountOfTokensGoingToRegionOwner;\r\n\r\n        IERC20 erc20ForSettlementPurchase = world().erc20ForSettlementPurchase();\r\n        if (address(erc20ForSettlementPurchase) == address(0)) {\r\n            if (msg.value < newSettlementCost) revert SettlementCannotBeBoughtDueInsufficientValueSent();\r\n            uint256 valueToSendBack = msg.value > newSettlementCost ? msg.value - newSettlementCost : 0;\r\n\r\n            if (valueToSendBack > 0) {\r\n                Address.sendValue(payable(msg.sender), valueToSendBack);\r\n            }\r\n\r\n            Address.sendValue(payable(address(world().rewardPool())), amountOfTokensGoingToRewardPool);\r\n            Address.sendValue(payable(address(geography.getRegionOwner(regionId))), amountOfTokensGoingToRegionOwner);\r\n        } else {\r\n            SafeERC20.safeTransferFrom(\r\n                erc20ForSettlementPurchase,\r\n                msg.sender,\r\n                address(world().rewardPool()),\r\n                amountOfTokensGoingToRewardPool\r\n            );\r\n\r\n            SafeERC20.safeTransferFrom(\r\n                erc20ForSettlementPurchase,\r\n                msg.sender,\r\n                address(geography.getRegionOwner(regionId)),\r\n                amountOfTokensGoingToRegionOwner\r\n            );\r\n        }\r\n\r\n        address settlementAddress = era().createUserSettlement(\r\n            position,\r\n            regionId,\r\n            bannerId\r\n        );\r\n\r\n        // Bump settlement price after purchase\r\n        uint256 bumpedSettlementPrice = newSettlementCost * registry().getNewSettlementPriceIncreaseMultiplier() / 1e18;\r\n        world().crossErasMemory().changeRegionSettlementPrice(\r\n            relatedRegion.regionId(),\r\n            bumpedSettlementPrice,\r\n            block.timestamp\r\n        );\r\n\r\n        emit SettlementBought(settlementAddress, newSettlementCost);\r\n    }\r\n\r\n    /// @inheritdoc ISettlementsMarket\r\n    function getNewSettlementCost(\r\n        uint256 timestamp\r\n    ) public view override returns (uint256) {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        uint64 regionId = relatedRegion.regionId();\r\n\r\n        ICrossErasMemory crossErasMemory = world().crossErasMemory();\r\n        uint256 userSettlementsCount = crossErasMemory.regionUserSettlementsCount(regionId);\r\n        uint256 priceUpdateTime = crossErasMemory.regionSettlementPriceUpdateTime(regionId);\r\n\r\n        uint256 priceDecayBeginTime = _getPriceDecayBeginTime(world().gameBeginTime(), marketCreationTime, priceUpdateTime);\r\n        uint256 priceDecayEndTime = _getPriceDecayEndTime(timestamp, world().gameEndTime());\r\n\r\n        uint256 newSettlementStartingPrice = 0;\r\n        if (priceUpdateTime == 0) {\r\n            uint256 regionTier = world().geography().getRegionTier(regionId);\r\n            newSettlementStartingPrice = registry().getNewSettlementStartingPrice() * (registry().getSettlementPriceMultiplierPerIncreasedRegionTier() ** (regionTier - 1));\r\n        } else {\r\n            newSettlementStartingPrice = crossErasMemory.regionSettlementPrice(regionId);\r\n        }\r\n\r\n        if (priceDecayBeginTime >= priceDecayEndTime) {\r\n            return newSettlementStartingPrice;\r\n        }\r\n\r\n        uint256 secondsPassed = priceDecayEndTime - priceDecayBeginTime;\r\n        uint256 hoursPassed = secondsPassed / 3600;\r\n\r\n        // 10/100 = 0.1 price drop per hour\r\n        // 11/10 = 1.1 price drop slowdown per settlement\r\n        int128 hourPriceDrop64 = ABDKMath64x64.sub(\r\n            ABDKMath64x64.fromUInt(1),\r\n            ABDKMath64x64.div(\r\n                ABDKMath64x64.divu(10, 100),\r\n                ABDKMath64x64.pow(ABDKMath64x64.divu(11, 10), userSettlementsCount)\r\n            )\r\n        );\r\n\r\n        int128 closestHourPriceDrop64 = ABDKMath64x64.pow(hourPriceDrop64, hoursPassed);\r\n        int128 nextHourPriceDrop64 = ABDKMath64x64.pow(hourPriceDrop64, hoursPassed + 1);\r\n        int128 currentHourPercentPassed = ABDKMath64x64.divu(secondsPassed % 3600, 3600);\r\n\r\n        int128 priceDrop64 = ABDKMath64x64.sub(\r\n            closestHourPriceDrop64,\r\n            ABDKMath64x64.mul(ABDKMath64x64.sub(closestHourPriceDrop64, nextHourPriceDrop64), currentHourPercentPassed)\r\n        );\r\n\r\n        return uint256(ABDKMath64x64.muli(priceDrop64, int256(newSettlementStartingPrice)));\r\n    }\r\n\r\n    /// @dev Calculates price decay begin time based on provided params\r\n    function _getPriceDecayBeginTime(\r\n        uint256 gameBeginTime,\r\n        uint256 marketCreationTime,\r\n        uint256 priceUpdateTime\r\n    ) internal pure returns (uint256) {\r\n        if (priceUpdateTime == 0) {\r\n            return Math.max(marketCreationTime, gameBeginTime);\r\n        } else {\r\n            return Math.max(gameBeginTime, priceUpdateTime);\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates price decay end time based on provided params\r\n    function _getPriceDecayEndTime(\r\n        uint256 timestamp,\r\n        uint256 gameEndTime\r\n    ) internal pure returns (uint256) {\r\n        if (gameEndTime != 0) {\r\n            return Math.min(timestamp, gameEndTime);\r\n        }\r\n\r\n        return timestamp;\r\n    }\r\n\r\n    /// @dev Calculates current game time, taking into an account game end time\r\n    function _getCurrentTime() internal view returns (uint256) {\r\n        uint256 gameBeginTime = world().gameBeginTime();\r\n        uint256 gameEndTime = world().gameEndTime();\r\n        uint256 timestamp = block.timestamp;\r\n\r\n        if (timestamp < gameBeginTime) {\r\n            timestamp = gameBeginTime;\r\n        }\r\n\r\n        if (gameEndTime == 0) {\r\n            return timestamp;\r\n        }\r\n\r\n        return Math.min(timestamp, gameEndTime);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/siege/ISiege.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../settlement/ISettlement.sol\";\r\n\r\n/// @title Siege interface\r\n/// @notice Functions to read state/modify state in order to get current siege parameters and/or interact with it\r\ninterface ISiege {\r\n    struct ArmyInfo {\r\n        uint256 robberyMultiplier;\r\n        uint256 pointsDebt;\r\n        uint256 points;\r\n    }\r\n\r\n    // State variables\r\n\r\n    /// @notice Settlement address to which this siege belongs\r\n    /// @dev Immutable, initialized on the siege creation\r\n    function relatedSettlement() external view returns (ISettlement);\r\n\r\n    /// @notice Mapping containing army information related to current siege\r\n    /// @dev Updated when #modifyArmySiege, #swapRobberyPointsForResourceFromBuildingTreasury is called\r\n    function armyInfo(address armyAddress) external view returns (\r\n        uint256 robberyMultiplier,\r\n        uint256 pointsDebt,\r\n        uint256 points\r\n    );\r\n\r\n    /// @notice Mapping containing amount of stored units in siege for specified army\r\n    /// @dev Updated when #modifyArmySiege is called\r\n    function besiegingArmyUnitsByType(address armyAddress, bytes32 unitTypeId) external view returns (uint256);\r\n\r\n    /// @notice Total siege power\r\n    /// @dev Updated when #modifyArmySiege is called\r\n    function totalSiegePower() external view returns (uint256);\r\n\r\n    /// @notice Amount of robbery point per one damage\r\n    /// @dev Updated when siege parameters related to armies were changed\r\n    function robberyPointsPerOneDamage() external view returns (uint256);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when #modifyArmySiege is called\r\n    /// @param armyAddress Army address\r\n    /// @param unitTypeIds Unit type ids\r\n    /// @param toAddIndication Indication array whether units where added or withdrawn (added = true, withdrawn = false)\r\n    /// @param unitsAmounts Units amounts\r\n    /// @param newRobberyMultiplier New robbery multiplier\r\n    /// @param newTotalSiegePower New total siege power\r\n    event ArmySiegeModified(\r\n        address armyAddress,\r\n        bytes32[] unitTypeIds,\r\n        bool[] toAddIndication,\r\n        uint256[] unitsAmounts,\r\n        uint256 newRobberyMultiplier,\r\n        uint256 newTotalSiegePower\r\n    );\r\n\r\n    /// @notice Emitted when army robbery points updated\r\n    /// @param armyAddress Army address\r\n    /// @param buildingAddress Building address\r\n    /// @param stolenAmount Amount of resources stolen\r\n    /// @param burnedAmount Burned amount of resources\r\n    /// @param pointsSpent Amount of points spent\r\n    /// @param newRobberyPointsAmount New robbery points amount\r\n    event BuildingRobbed(\r\n        address armyAddress,\r\n        address buildingAddress,\r\n        uint256 stolenAmount,\r\n        uint256 burnedAmount,\r\n        uint256 pointsSpent,\r\n        uint256 newRobberyPointsAmount\r\n    );\r\n\r\n    /// @notice Emitted when #liquidate is called\r\n    /// @param armyAddress Army address which was liquidated\r\n    event ArmyLiquidated(address armyAddress);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to liquidate army from siege when it is not liquidatable\r\n    error SiegeCannotLiquidateArmy();\r\n\r\n    /// @notice Thrown when attempting to modify siege units with invalid units amount specified\r\n    error SiegeCannotBeModifiedDueToInvalidUnitsAmountSpecified();\r\n\r\n    /// @notice Thrown when attempting to swap robbery points with wrong building address specified\r\n    error RobberyPointsSwapNotAllowedDueToSpecifiedBuildingAddressIsNotPartOfEra();\r\n\r\n    /// @notice Thrown when attempting to swap robbery points with wrong max points to spend specified\r\n    error RobberyPointsSwapNotAllowedDueToWrongMaxPointsToSpendSpecified();\r\n\r\n    /// @notice Thrown when attempting to swap robbery points with specified building address not belonging to the settlement of this siege\r\n    error RobberyPointsSwapNotAllowedDueToSpecifiedBuildingAddressDoesNotBelongToSettlementOfThisSiege();\r\n\r\n    /// @notice Thrown when attempting to swap robbery points in result of which zero resources was stolen and burned\r\n    error RobberyPointsSwapNotAllowedDueToNothingWasStolenAndBurned();\r\n\r\n    // Functions\r\n\r\n    /// @notice Swaps army robbery points for resources from building in related settlement\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param buildingAddress Address of building to rob\r\n    /// @param pointsToSpend Amount of points to spend for robbing\r\n    function swapRobberyPointsForResourceFromBuildingTreasury(address buildingAddress, uint256 pointsToSpend) external;\r\n\r\n    /// @notice Updates siege with new amount of damage fort has taken\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param damage Damage which has been done to the settlement\r\n    function applyDamage(uint256 damage) external;\r\n\r\n    /// @notice Modifies army robbery multiplier\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param armyAddress Army address\r\n    /// @param unitTypeIds Unit type ids\r\n    /// @param toAddIndication Indication array whether to add units or to withdraw (add = true, withdraw = false)\r\n    /// @param unitsAmounts Units amounts\r\n    /// @param newRobberyMultiplier New robbery multiplier\r\n    function modifyArmySiege(\r\n        address armyAddress,\r\n        bytes32[] calldata unitTypeIds,\r\n        bool[] calldata toAddIndication,\r\n        uint256[] calldata unitsAmounts,\r\n        uint256 newRobberyMultiplier\r\n    ) external;\r\n\r\n    /// @notice Calculates if besieging units of provided army can be liquidated from current siege\r\n    /// @dev Does not take into an account if army's battle is ended and army isn't left the battle\r\n    /// @param armyAddress Address of the army\r\n    /// @return canLiquidate Can army be liquidated from current siege\r\n    function canLiquidateArmyBesiegingUnits(address armyAddress) external view returns (bool canLiquidate);\r\n\r\n    /// @notice Calculates amount of robbery points army will have at specified time\r\n    /// @dev If timestamp=0, returns value as if timestamp=block.timestamp\r\n    /// @param armyAddress Address of the army\r\n    /// @param timestamp Time at which calculate points\r\n    /// @return robberyPoints Amount of robbery points army will have at specified time\r\n    function getArmyRobberyPoints(address armyAddress, uint256 timestamp) external view returns (uint256 robberyPoints);\r\n\r\n    /// @notice Returns amount of besieging units for specified army in siege\r\n    /// @dev Function returns only amounts without types, index in returned array for each unit type is same as in 'registry.getUnits'\r\n    /// @param armyAddress Address of the army\r\n    /// @return unitsAmounts Amount of units that army has in siege\r\n    function getArmyBesiegingUnitsAmounts(address armyAddress) external view returns (uint256[] memory unitsAmounts);\r\n\r\n    /// @notice Liquidates army\r\n    /// @dev Can be called by anyone, caller will receive a reward\r\n    /// @param armyAddress Address of army to liquidate\r\n    function liquidate(address armyAddress) external;\r\n\r\n    /// @notice Calculates army units siege power\r\n    /// @dev Value are calculated for specified army that is present in siege\r\n    /// @param armyAddress Address of army\r\n    /// @return armySiegePower Army units siege power\r\n    function calculateArmyUnitsSiegePower(address armyAddress) external returns (uint256 armySiegePower);\r\n\r\n    /// @notice Calculates army total siege power (including its current robbery multiplier)\r\n    /// @dev Value are calculated for specified army that is present in siege\r\n    /// @param armyAddress Army address\r\n    /// @return armyTotalSiegePower Army total siege power\r\n    function calculateArmyTotalSiegePower(address armyAddress) external returns (uint256 armyTotalSiegePower);\r\n}\r\n"
    },
    "contracts/core/assets/siege/Siege.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"./ISiege.sol\";\r\nimport \"../battle/IBattle.sol\";\r\nimport \"../building/IBuilding.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../building/impl/IFort.sol\";\r\nimport \"../../../const/GameAssetTypes.sol\";\r\n\r\ncontract Siege is WorldAsset, ISiege {\r\n    /// @inheritdoc ISiege\r\n    ISettlement public override relatedSettlement;\r\n    /// @inheritdoc ISiege\r\n    mapping(address => ArmyInfo) public override armyInfo;\r\n    /// @inheritdoc ISiege\r\n    mapping(address => mapping(bytes32 => uint256)) public override besiegingArmyUnitsByType;\r\n    /// @inheritdoc ISiege\r\n    uint256 public override robberyPointsPerOneDamage;\r\n    /// @inheritdoc ISiege\r\n    uint256 public override totalSiegePower;\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        (address settlementAddress) = abi.decode(initParams, (address));\r\n\r\n        relatedSettlement = ISettlement(settlementAddress);\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function canLiquidateArmyBesiegingUnits(address armyAddress) public view override returns (bool) {\r\n        uint256 armyUnitsSiegePower = calculateArmyUnitsSiegePower(armyAddress);\r\n        return (IArmy(armyAddress).getTotalSiegeSupport() < armyUnitsSiegePower);\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function liquidate(address armyAddress) public override onlyActiveGame {\r\n        relatedSettlement.updateFortHealth();\r\n\r\n        IArmy army = IArmy(armyAddress);\r\n        army.updateState();\r\n\r\n        if (!canLiquidateArmyBesiegingUnits(armyAddress)) revert SiegeCannotLiquidateArmy();\r\n\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n        bool[] memory toAddIndication = new bool[](unitTypeIds.length);\r\n        uint256[] memory unitsToLiquidate = new uint256[](unitTypeIds.length);\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            toAddIndication[i] = false;\r\n            unitsToLiquidate[i] = besiegingArmyUnitsByType[armyAddress][unitTypeIds[i]];\r\n        }\r\n\r\n        this.modifyArmySiege(\r\n            armyAddress,\r\n            unitTypeIds,\r\n            toAddIndication,\r\n            unitsToLiquidate,\r\n            0\r\n        );\r\n\r\n        army.liquidateUnits(unitTypeIds, unitsToLiquidate);\r\n\r\n        emit ArmyLiquidated(armyAddress);\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function modifyArmySiege(\r\n        address armyAddress,\r\n        bytes32[] calldata unitTypeIds,\r\n        bool[] calldata toAddIndication,\r\n        uint256[] calldata unitsAmounts,\r\n        uint256 newRobberyMultiplier\r\n    ) public override onlyWorldAssetFromSameEra {\r\n        _updateArmySiegeProgress(armyAddress);\r\n\r\n        uint256 oldArmyTotalSiegePower = calculateArmyTotalSiegePower(armyAddress);\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            uint256 unitsAmount = unitsAmounts[i];\r\n            if (unitsAmount == 0) {\r\n                continue;\r\n            }\r\n\r\n            if (!MathExtension.isIntegerWithPrecision(unitsAmount, 1e18)) revert SiegeCannotBeModifiedDueToInvalidUnitsAmountSpecified();\r\n\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n            IUnits units = era().units(unitTypeId);\r\n\r\n            if (toAddIndication[i]) {\r\n                besiegingArmyUnitsByType[armyAddress][unitTypeId] += unitsAmount;\r\n                units.transferFrom(armyAddress, address(this), unitsAmount);\r\n            } else {\r\n                besiegingArmyUnitsByType[armyAddress][unitTypeId] -= unitsAmount;\r\n                units.transferFrom(address(this), armyAddress, unitsAmount);\r\n            }\r\n        }\r\n\r\n        ArmyInfo storage currentArmyInfo = armyInfo[armyAddress];\r\n        currentArmyInfo.robberyMultiplier = newRobberyMultiplier;\r\n\r\n        uint256 armyUnitsSiegePower = calculateArmyUnitsSiegePower(armyAddress);\r\n        uint256 newArmyTotalSiegePower = _calculateArmyTotalSiegePower(armyUnitsSiegePower, newRobberyMultiplier);\r\n\r\n        currentArmyInfo.pointsDebt = newArmyTotalSiegePower * robberyPointsPerOneDamage;\r\n\r\n        if (newArmyTotalSiegePower == 0) {\r\n            currentArmyInfo.robberyMultiplier = 0;\r\n        }\r\n\r\n        if (oldArmyTotalSiegePower != newArmyTotalSiegePower) {\r\n            totalSiegePower = totalSiegePower + newArmyTotalSiegePower - oldArmyTotalSiegePower;\r\n\r\n            // In case if last army leaves the siege, reset 'robberyPointsPerOneDamage'\r\n            if (totalSiegePower == 0) {\r\n                robberyPointsPerOneDamage = 0;\r\n            }\r\n        }\r\n\r\n        emit ArmySiegeModified(\r\n            armyAddress,\r\n            unitTypeIds,\r\n            toAddIndication,\r\n            unitsAmounts,\r\n            newRobberyMultiplier,\r\n            totalSiegePower\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function calculateArmyUnitsSiegePower(address armyAddress) public view override returns (uint256) {\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n\r\n        uint256 armyUnitsSiegePower = 0;\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n            uint256 besiegingUnitsAmount = besiegingArmyUnitsByType[armyAddress][unitTypeId];\r\n            if (besiegingUnitsAmount == 0) {\r\n                continue;\r\n            }\r\n\r\n            IRegistry.UnitStats memory unitStats = registry().getUnitStats(unitTypeId);\r\n\r\n            armyUnitsSiegePower += (besiegingUnitsAmount * unitStats.siegePower) / 1e18;\r\n        }\r\n\r\n        return armyUnitsSiegePower;\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function calculateArmyTotalSiegePower(address armyAddress) public view override returns (uint256) {\r\n        uint256 armyUnitsSiegePower = calculateArmyUnitsSiegePower(armyAddress);\r\n\r\n        return _calculateArmyTotalSiegePower(\r\n            armyUnitsSiegePower,\r\n            armyInfo[armyAddress].robberyMultiplier\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function applyDamage(uint256 damage) public override onlyWorldAssetFromSameEra {\r\n        uint256 additionalRobberyPointsPerOneDamageByDamage = _calculateAdditionalRobberyPointsPerOneDamage(damage, totalSiegePower);\r\n\r\n        if (additionalRobberyPointsPerOneDamageByDamage == 0) {\r\n            return;\r\n        }\r\n\r\n        robberyPointsPerOneDamage += additionalRobberyPointsPerOneDamageByDamage;\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function getArmyRobberyPoints(\r\n        address armyAddress,\r\n        uint256 timestamp\r\n    ) public view override returns (uint256) {\r\n        IFort fort = IFort(address(relatedSettlement.buildings(FORT_TYPE_ID)));\r\n        uint256 damageDone = fort.calculateDamageDone(timestamp);\r\n\r\n        uint256 siegePower = totalSiegePower;\r\n        if (siegePower == 0) {\r\n            return 0;\r\n        }\r\n\r\n        ArmyInfo storage currentArmyInfo = armyInfo[armyAddress];\r\n        uint256 armyUnitsSiegePower = calculateArmyUnitsSiegePower(armyAddress);\r\n        uint256 armyTotalSiegePower = _calculateArmyTotalSiegePower(armyUnitsSiegePower, currentArmyInfo.robberyMultiplier);\r\n\r\n        uint256 additionalRobberyPointsPerOneDamageByDamage = _calculateAdditionalRobberyPointsPerOneDamage(damageDone, siegePower);\r\n        uint256 newRobberyPointsPerOneDamage = robberyPointsPerOneDamage + additionalRobberyPointsPerOneDamageByDamage;\r\n        uint256 pendingPoints = armyTotalSiegePower * newRobberyPointsPerOneDamage - currentArmyInfo.pointsDebt;\r\n\r\n        return currentArmyInfo.points + pendingPoints;\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function swapRobberyPointsForResourceFromBuildingTreasury(\r\n        address buildingAddress,\r\n        uint256 maxPointsToSpend\r\n    ) public override onlyWorldAssetFromSameEra {\r\n        address armyAddress = msg.sender;\r\n        _updateArmySiegeProgress(armyAddress);\r\n\r\n        IArmy army = IArmy(armyAddress);\r\n        ArmyInfo storage currentArmyInfo = armyInfo[armyAddress];\r\n\r\n        if (world().worldAssets(eraNumber(), buildingAddress) != BUILDING_GROUP_TYPE_ID) revert RobberyPointsSwapNotAllowedDueToSpecifiedBuildingAddressIsNotPartOfEra();\r\n        if (currentArmyInfo.points < maxPointsToSpend) revert RobberyPointsSwapNotAllowedDueToWrongMaxPointsToSpendSpecified();\r\n\r\n        IBuilding producingResourceBuilding = IBuilding(buildingAddress);\r\n\r\n        if (address(relatedSettlement) != address(producingResourceBuilding.relatedSettlement())) revert RobberyPointsSwapNotAllowedDueToSpecifiedBuildingAddressDoesNotBelongToSettlementOfThisSiege();\r\n\r\n        uint256 robberyPointsToResourceMultiplier = registry().getRobberyPointsToResourceMultiplier(\r\n            producingResourceBuilding.getProducingResourceTypeId()\r\n        );\r\n        uint256 amountOfResourcesToStealAndBurn = (maxPointsToSpend * robberyPointsToResourceMultiplier) / 1e18;\r\n\r\n        producingResourceBuilding.updateState();\r\n\r\n        (uint256 stolenAmount, uint256 burnedAmount) = producingResourceBuilding.stealTreasury(\r\n            address(army.relatedSettlement()),\r\n            amountOfResourcesToStealAndBurn\r\n        );\r\n        if (stolenAmount == 0 && burnedAmount == 0) revert RobberyPointsSwapNotAllowedDueToNothingWasStolenAndBurned();\r\n\r\n        uint256 pointsSpent = ((stolenAmount + burnedAmount) * 1e18) / robberyPointsToResourceMultiplier;\r\n        currentArmyInfo.points -= pointsSpent;\r\n\r\n        emit BuildingRobbed(\r\n            armyAddress,\r\n            buildingAddress,\r\n            stolenAmount,\r\n            burnedAmount,\r\n            pointsSpent,\r\n            currentArmyInfo.points\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc ISiege\r\n    function getArmyBesiegingUnitsAmounts(address armyAddress) public view override returns (uint256[] memory) {\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n        uint256[] memory unitsAmounts = new uint256[](unitTypeIds.length);\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            unitsAmounts[i] = besiegingArmyUnitsByType[armyAddress][unitTypeIds[i]];\r\n        }\r\n\r\n        return unitsAmounts;\r\n    }\r\n\r\n    /// @dev Updates army siege progress\r\n    function _updateArmySiegeProgress(address armyAddress) internal {\r\n        relatedSettlement.updateFortHealth();\r\n\r\n        ArmyInfo storage currentArmyInfo = armyInfo[armyAddress];\r\n        uint256 armyUnitsSiegePower = calculateArmyUnitsSiegePower(armyAddress);\r\n        uint256 armyTotalSiegePower = _calculateArmyTotalSiegePower(armyUnitsSiegePower, currentArmyInfo.robberyMultiplier);\r\n        uint256 totalArmyRobberyPoints = armyTotalSiegePower * robberyPointsPerOneDamage;\r\n        uint256 pendingRobberyPoints = totalArmyRobberyPoints - currentArmyInfo.pointsDebt;\r\n\r\n        if (pendingRobberyPoints > 0) {\r\n            currentArmyInfo.points = currentArmyInfo.points + pendingRobberyPoints;\r\n        }\r\n\r\n        currentArmyInfo.pointsDebt = totalArmyRobberyPoints;\r\n    }\r\n\r\n    /// @dev Calculates additional robbery points per one damage by damage and total siege power\r\n    function _calculateAdditionalRobberyPointsPerOneDamage(uint256 damage, uint256 siegePower) internal view returns (uint256) {\r\n        if (damage == 0 || siegePower == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return ((damage * registry().getRobberyPointsPerDamageMultiplier()) / 1e18) / siegePower;\r\n    }\r\n\r\n    /// @dev Calculates army total siege power by armySiegePower from units and robberyMultiplier\r\n    function _calculateArmyTotalSiegePower(uint256 armyUnitsSiegePower, uint256 robberyMultiplier) internal pure returns (uint256) {\r\n        return armyUnitsSiegePower * robberyMultiplier / 1e18;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/tileCapturingSystem/ITileCapturingSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Tile capturing system interface\r\n/// @notice Functions to read state/modify state in order to get current system parameters and/or interact with it\r\ninterface ITileCapturingSystem {\r\n    struct TileInfo {\r\n        address ownerSettlementAddress;\r\n        address usurperSettlementAddress;\r\n        uint256 usurperProsperityStake;\r\n        uint64 usurperCaptureBeginTime;\r\n        uint64 usurperCaptureEndTime;\r\n    }\r\n\r\n    // State variables\r\n\r\n    /// @notice Mapping containing settlements' current capturing tile\r\n    /// @dev Updated when #beginTileCaptureBySettlement or #claimTileCaptureBySettlement, #cancelTileCaptureBySettlement is called\r\n    function settlementCapturingTile(address settlementAddress) external view returns (uint64);\r\n\r\n    /// @notice Mapping containing tile info by provided position\r\n    /// @dev Updated when #beginTileCaptureBySettlement or #claimTileCaptureBySettlement, #cancelTileCaptureBySettlement is called\r\n    function tilesInfo(uint64 position) external view returns (\r\n        address ownerSettlementAddress,\r\n        address usurperSettlementAddress,\r\n        uint256 usurperProsperityStake,\r\n        uint64 usurperCaptureBeginTime,\r\n        uint64 usurperCaptureEndTime\r\n    );\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when #beginTileCaptureBySettlement is called\r\n    /// @param previousUsurperAddress Previous usurper address\r\n    /// @param position Position\r\n    /// @param settlementAddress Settlement address\r\n    /// @param prosperityStake Prosperity stake\r\n    /// @param captureBeginTime Capture begin time\r\n    /// @param captureEndTime Capture end time\r\n    event TileCapturingBegan(\r\n        address previousUsurperAddress,\r\n        uint64 position,\r\n        address settlementAddress,\r\n        uint256 prosperityStake,\r\n        uint64 captureBeginTime,\r\n        uint64 captureEndTime\r\n    );\r\n\r\n    /// @notice Emitted when #cancelTileCaptureBySettlement\r\n    /// @param position Position\r\n    /// @param settlementAddress Settlement address\r\n    event TileCapturingCancelled(\r\n        uint64 position,\r\n        address settlementAddress\r\n    );\r\n\r\n    /// @notice Emitted when #claimTileCaptureBySettlement\r\n    /// @param previousSettlementOwnerAddress Previous settlement owner address\r\n    /// @param position Position\r\n    /// @param settlementAddress Settlement address\r\n    /// @param prosperityStake Prosperity stake\r\n    event CapturedTileClaimed(\r\n        address previousSettlementOwnerAddress,\r\n        uint64 position,\r\n        address settlementAddress,\r\n        uint256 prosperityStake\r\n    );\r\n\r\n    /// @notice Emitted when #giveUpCapturedTile\r\n    /// @param position Position\r\n    /// @param settlementAddress Settlement address\r\n    event CapturedTileGivenUp(\r\n        uint64 position,\r\n        address settlementAddress\r\n    );\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to begin tile capture of non existent position\r\n    error CannotBeginTileCaptureDueToNonExistentPositionSpecified();\r\n\r\n    /// @notice Thrown when attempting to begin tile capture of position on not activated region\r\n    error CannotBeginTileCaptureOnNotActivatedRegion();\r\n\r\n    /// @notice Thrown when attempting to begin tile capture on position with settlement on it\r\n    error CannotBeginTileCaptureOnPositionWithSettlement();\r\n\r\n    /// @notice Thrown when attempting to begin tile capture by settlement which is already capturing tile\r\n    error CannotBeginTileCaptureBySettlementWhichIsAlreadyCapturingTile();\r\n\r\n    /// @notice Thrown when attempting to begin tile capture by settlement which already has maximum allowed tiles with same bonus as specified tile\r\n    error CannotBeginTileCaptureBySettlementAlreadyHavingMaximumCapturedTilesWithSameBonus();\r\n\r\n    /// @notice Thrown when attempting to begin tile capture of position without tile bonus\r\n    error CannotBeginTileCaptureOfPositionWithoutBonus();\r\n\r\n    /// @notice Thrown when attempting to begin tile capture with not having specified amount of prosperity\r\n    error CannotBeginTileCaptureDueToNotHavingSpecifiedProsperity();\r\n\r\n    /// @notice Thrown when attempting to begin tile capture with prosperity stake lower than next minimum prosperity stake\r\n    error CannotBeginTileCaptureDueToNotReachedNextMinimumProsperityStake();\r\n\r\n    /// @notice Thrown when attempting to cancel tile capture by settlement which is not currently capturing specified tile\r\n    error TileCaptureCannotBeCancelledBySettlementWhichIsNotCurrentTileUsurper();\r\n\r\n    /// @notice Thrown when attempting to give up captured tile by settlement which is not owner of specified tile\r\n    error CapturedTileCannotBeGivenUpByNonSettlementOwner();\r\n\r\n    /// @notice Thrown when attempting to claim captured tile by settlement which was not capturing specified tile\r\n    error ClaimTileCaptureCannotBeDoneByNonUsurperSettlement();\r\n\r\n    /// @notice Thrown when attempting to claim captured tile at this time (it is still capturing)\r\n    error ClaimTileCaptureCannotBeDoneAtThisTime();\r\n\r\n    /// @notice Thrown when attempting to claim captured tile without necessary prosperity in settlement\r\n    error ClaimTileCaptureCannotBeDoneWithoutNecessaryProsperity();\r\n\r\n    /// @notice Thrown when attempting to apply or remove tile bonus. It should not be thrown ever, if it does this will indicate logic error\r\n    error UnknownTileBonus();\r\n\r\n    // Functions\r\n\r\n    /// @notice Begins tile capturing\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param settlementAddress Settlement address\r\n    /// @param position Position\r\n    function beginTileCapture(address settlementAddress, uint64 position, uint256 prosperityStake) external;\r\n\r\n    /// @notice Cancels tile capturing\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param settlementAddress Settlement address\r\n    /// @param position Position\r\n    function cancelTileCapture(address settlementAddress, uint64 position) external;\r\n\r\n    /// @notice Gives up captured tile\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param settlementAddress Settlement address\r\n    /// @param position Position\r\n    function giveUpCapturedTile(address settlementAddress, uint64 position) external;\r\n\r\n    /// @notice Claims captured tile\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param settlementAddress Settlement address\r\n    /// @param position Position\r\n    function claimTileCapture(address settlementAddress, uint64 position) external;\r\n\r\n    /// @notice Returns positions of captured tiles for provided settlement address\r\n    /// @dev Returns only claimed tiles\r\n    /// @param settlementAddress Settlement address\r\n    /// @param tileBonusType Tile bonus type\r\n    /// @return positions Positions of captured tiles\r\n    function getCapturedTilesBySettlementAddress(address settlementAddress, uint8 tileBonusType) external view returns (uint64[] memory positions);\r\n\r\n    /// @notice New settlement handler\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    /// @param position Position\r\n    function handleSettlementCreatedOnPosition(uint64 position) external;\r\n}\r\n"
    },
    "contracts/core/assets/tileCapturingSystem/TileCapturingSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"./ITileCapturingSystem.sol\";\r\nimport \"../../../const/GameAssetTypes.sol\";\r\n\r\ncontract TileCapturingSystem is WorldAsset, ITileCapturingSystem {\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n    /// @dev Mapping containing captured tiles by provided settlement address\r\n    mapping(address => mapping(IGeography.TileBonusType => EnumerableSet.UintSet)) private settlementCapturedTiles;\r\n\r\n    /// @inheritdoc ITileCapturingSystem\r\n    mapping(address => uint64) public override settlementCapturingTile;\r\n    /// @inheritdoc ITileCapturingSystem\r\n    mapping(uint64 => TileInfo) public override tilesInfo;\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n\r\n    }\r\n\r\n    /// @inheritdoc ITileCapturingSystem\r\n    function beginTileCapture(\r\n        address settlementAddress,\r\n        uint64 position,\r\n        uint256 prosperityStake\r\n    )\r\n        public\r\n        override\r\n        onlyWorldAssetFromSameEra\r\n    {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n\r\n        // Update callers' settlement prosperity\r\n        settlement.updateProsperityAmount();\r\n\r\n        (uint64 regionId, bool isPositionExist) = world().geography().getRegionIdByPosition(position);\r\n        if (!isPositionExist) revert CannotBeginTileCaptureDueToNonExistentPositionSpecified();\r\n\r\n        IGeography.TileBonus memory tileBonus = _getTileBonus(regionId, position);\r\n\r\n        if (address(era().regions(regionId)) == address(0)) revert CannotBeginTileCaptureOnNotActivatedRegion();\r\n        if (address(world().crossErasMemory().settlementByPosition(position)) != address(0)) revert CannotBeginTileCaptureOnPositionWithSettlement();\r\n        if (settlementCapturingTile[settlementAddress] != 0) revert CannotBeginTileCaptureBySettlementWhichIsAlreadyCapturingTile();\r\n        if (settlementCapturedTiles[settlementAddress][tileBonus.tileBonusType].length() == registry().getMaxCapturedTilesForSettlement(uint8(tileBonus.tileBonusType))) revert CannotBeginTileCaptureBySettlementAlreadyHavingMaximumCapturedTilesWithSameBonus();\r\n        if (tileBonus.tileBonusType == IGeography.TileBonusType.NO_BONUS) revert CannotBeginTileCaptureOfPositionWithoutBonus();\r\n        if (era().prosperity().balanceOf(settlementAddress) < prosperityStake) revert CannotBeginTileCaptureDueToNotHavingSpecifiedProsperity();\r\n\r\n        TileInfo storage tileInfo = tilesInfo[position];\r\n        address previousUsurperSettlementAddress = tileInfo.usurperSettlementAddress;\r\n\r\n        uint256 previousUsurperProsperityStake = previousUsurperSettlementAddress != address(0)\r\n            ? tileInfo.usurperProsperityStake\r\n            : 0;\r\n\r\n        uint256 distanceBetweenSettlementAndTile = world().geography().getDistanceBetweenPositions(\r\n            position,\r\n            settlement.position()\r\n        );\r\n\r\n        if (prosperityStake < _calculateNextMinProsperityStake(previousUsurperProsperityStake, distanceBetweenSettlementAndTile)) revert CannotBeginTileCaptureDueToNotReachedNextMinimumProsperityStake();\r\n\r\n        if (previousUsurperSettlementAddress != address(0)) {\r\n            settlementCapturingTile[previousUsurperSettlementAddress] = 0;\r\n\r\n            // Update usurper settlement prosperity\r\n            ISettlement(previousUsurperSettlementAddress).updateProsperityAmount();\r\n\r\n            // And remove 25% prosperity of old stake\r\n            era().prosperity().spend(\r\n                previousUsurperSettlementAddress,\r\n                previousUsurperProsperityStake * registry().getTileCaptureCancellationFee() / 1e18\r\n            );\r\n        }\r\n\r\n        uint64 captureBeginTime = uint64(block.timestamp);\r\n        uint64 captureEndTime = uint64(block.timestamp + distanceBetweenSettlementAndTile * registry().getCaptureTileDurationPerTile() / registry().getGlobalMultiplier());\r\n\r\n        tileInfo.usurperProsperityStake = prosperityStake;\r\n        tileInfo.usurperSettlementAddress = settlementAddress;\r\n        tileInfo.usurperCaptureBeginTime = captureBeginTime;\r\n        tileInfo.usurperCaptureEndTime = captureEndTime;\r\n\r\n        settlementCapturingTile[settlementAddress] = position;\r\n\r\n        emit TileCapturingBegan(\r\n            previousUsurperSettlementAddress,\r\n            position,\r\n            settlementAddress,\r\n            prosperityStake,\r\n            captureBeginTime,\r\n            captureEndTime\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc ITileCapturingSystem\r\n    function cancelTileCapture(address settlementAddress, uint64 position)\r\n        public\r\n        override\r\n        onlyWorldAssetFromSameEra\r\n    {\r\n        TileInfo storage tileInfo = tilesInfo[position];\r\n\r\n        if (tileInfo.usurperSettlementAddress != settlementAddress) revert TileCaptureCannotBeCancelledBySettlementWhichIsNotCurrentTileUsurper();\r\n\r\n        // Has cancellation penalty\r\n        if (uint64(block.timestamp) < tileInfo.usurperCaptureEndTime) {\r\n            // Update callers' settlement prosperity\r\n            ISettlement(settlementAddress).updateProsperityAmount();\r\n\r\n            era().prosperity().spend(\r\n                settlementAddress,\r\n                tileInfo.usurperProsperityStake * registry().getTileCaptureCancellationFee() / 1e18\r\n            );\r\n        }\r\n\r\n        tileInfo.usurperProsperityStake = 0;\r\n        tileInfo.usurperSettlementAddress = address(0);\r\n        tileInfo.usurperCaptureBeginTime = 0;\r\n        tileInfo.usurperCaptureEndTime = 0;\r\n\r\n        settlementCapturingTile[settlementAddress] = 0;\r\n\r\n        emit TileCapturingCancelled(position, settlementAddress);\r\n    }\r\n\r\n    /// @inheritdoc ITileCapturingSystem\r\n    function giveUpCapturedTile(address settlementAddress, uint64 position)\r\n        public\r\n        override\r\n        onlyWorldAssetFromSameEra\r\n    {\r\n        TileInfo storage tileInfo = tilesInfo[position];\r\n\r\n        if (tileInfo.ownerSettlementAddress != settlementAddress) revert CapturedTileCannotBeGivenUpByNonSettlementOwner();\r\n\r\n        (uint64 regionId, ) = world().geography().getRegionIdByPosition(position);\r\n        IGeography.TileBonus memory tileBonus = _getTileBonus(regionId, position);\r\n        settlementCapturedTiles[settlementAddress][tileBonus.tileBonusType].remove(position);\r\n        _removeTileBonus(tileBonus, settlementAddress);\r\n\r\n        tileInfo.ownerSettlementAddress = address(0);\r\n\r\n        emit CapturedTileGivenUp(position, settlementAddress);\r\n    }\r\n\r\n    /// @inheritdoc ITileCapturingSystem\r\n    function claimTileCapture(\r\n        address settlementAddress,\r\n        uint64 position\r\n    )\r\n        public\r\n        override\r\n        onlyWorldAssetFromSameEra\r\n    {\r\n        // Update callers' settlement prosperity\r\n        ISettlement(settlementAddress).updateProsperityAmount();\r\n\r\n        TileInfo storage tileInfo = tilesInfo[position];\r\n\r\n        (uint64 regionId, ) = world().geography().getRegionIdByPosition(position);\r\n        IGeography.TileBonus memory tileBonus = _getTileBonus(regionId, position);\r\n\r\n        if (tileInfo.usurperSettlementAddress != settlementAddress) revert ClaimTileCaptureCannotBeDoneByNonUsurperSettlement();\r\n        if (uint64(block.timestamp) < tileInfo.usurperCaptureEndTime) revert ClaimTileCaptureCannotBeDoneAtThisTime();\r\n\r\n        uint256 usurperProsperityStake = tileInfo.usurperProsperityStake;\r\n\r\n        uint256 necessaryProsperityForClaiming = usurperProsperityStake * registry().getNecessaryProsperityPercentForClaimingTileCapture() / 1e18;\r\n        if (era().prosperity().balanceOf(settlementAddress) < necessaryProsperityForClaiming) revert ClaimTileCaptureCannotBeDoneWithoutNecessaryProsperity();\r\n\r\n        address previousSettlementOwnerAddress = tileInfo.ownerSettlementAddress;\r\n\r\n        if (previousSettlementOwnerAddress != address(0)) {\r\n            settlementCapturedTiles[previousSettlementOwnerAddress][tileBonus.tileBonusType].remove(position);\r\n            _removeTileBonus(tileBonus, previousSettlementOwnerAddress);\r\n        }\r\n\r\n        tileInfo.ownerSettlementAddress = settlementAddress;\r\n\r\n        tileInfo.usurperProsperityStake = 0;\r\n        tileInfo.usurperSettlementAddress = address(0);\r\n        tileInfo.usurperCaptureBeginTime = 0;\r\n        tileInfo.usurperCaptureEndTime = 0;\r\n\r\n        settlementCapturingTile[settlementAddress] = 0;\r\n\r\n        _applyTileBonus(tileBonus, settlementAddress);\r\n        settlementCapturedTiles[settlementAddress][tileBonus.tileBonusType].add(position);\r\n\r\n        emit CapturedTileClaimed(previousSettlementOwnerAddress, position, settlementAddress, usurperProsperityStake);\r\n    }\r\n\r\n    /// @inheritdoc ITileCapturingSystem\r\n    function getCapturedTilesBySettlementAddress(address settlementAddress, uint8 tileBonusType) public view override returns (uint64[] memory) {\r\n        uint256[] memory positions = settlementCapturedTiles[settlementAddress][IGeography.TileBonusType(tileBonusType)].values();\r\n        uint64[] memory result = new uint64[](positions.length);\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            result[i] = uint64(positions[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /// @inheritdoc ITileCapturingSystem\r\n    function handleSettlementCreatedOnPosition(\r\n        uint64 position\r\n    ) public override onlyWorldAssetFromSameEra {\r\n        (uint64 regionId, ) = world().geography().getRegionIdByPosition(position);\r\n        IGeography.TileBonus memory tileBonus = _getTileBonus(regionId, position);\r\n\r\n        if (tileBonus.tileBonusType == IGeography.TileBonusType.NO_BONUS) {\r\n            return;\r\n        }\r\n\r\n        TileInfo storage tileInfo = tilesInfo[position];\r\n        if (tileInfo.ownerSettlementAddress != address(0)) {\r\n            settlementCapturedTiles[tileInfo.ownerSettlementAddress][tileBonus.tileBonusType].remove(position);\r\n            _removeTileBonus(tileBonus, tileInfo.ownerSettlementAddress);\r\n        }\r\n\r\n        if (tileInfo.usurperSettlementAddress != address(0)) {\r\n            settlementCapturingTile[tileInfo.usurperSettlementAddress] = 0;\r\n        }\r\n\r\n        tileInfo.ownerSettlementAddress = address(0);\r\n\r\n        tileInfo.usurperProsperityStake = 0;\r\n        tileInfo.usurperSettlementAddress = address(0);\r\n        tileInfo.usurperCaptureBeginTime = 0;\r\n        tileInfo.usurperCaptureEndTime = 0;\r\n    }\r\n\r\n    /// @dev Returns tile bonus by position\r\n    function _getTileBonus(\r\n        uint64 regionId,\r\n        uint64 position\r\n    ) internal view returns (IGeography.TileBonus memory) {\r\n        IWorld _world = world();\r\n        IGeography geography = _world.geography();\r\n        uint256 regionTier = geography.getRegionTier(regionId);\r\n        uint256 chanceForTileWithBonus = registry().getChanceForTileWithBonusByRegionTier(regionTier);\r\n        bytes32 tileBonusesSeed = _world.getTileBonusesSeed();\r\n\r\n        return geography.getTileBonus(tileBonusesSeed, chanceForTileWithBonus, position);\r\n    }\r\n\r\n    /// @dev Calculates next min prosperity stake\r\n    function _calculateNextMinProsperityStake(\r\n        uint256 previousUsurperProsperityStake,\r\n        uint256 distanceBetweenSettlementAndTile\r\n    ) internal view returns (uint256) {\r\n        if (previousUsurperProsperityStake == 0) {\r\n            return registry().getInitialCaptureProsperityBasicValue() +\r\n                distanceBetweenSettlementAndTile * registry().getInitialCaptureProsperityPerTileValue();\r\n        }\r\n\r\n        uint256 nextCaptureProsperityThreshold = registry().getNextCaptureProsperityBasicThreshold() +\r\n            distanceBetweenSettlementAndTile * registry().getNextCaptureProsperityPerTileThreshold();\r\n\r\n        uint256 nextMinProsperityStake = previousUsurperProsperityStake * nextCaptureProsperityThreshold / 1e18;\r\n        return nextMinProsperityStake;\r\n    }\r\n\r\n    /// @dev Applies tile bonus to\r\n    function _applyTileBonus(\r\n        IGeography.TileBonus memory tileBonus,\r\n        address settlementAddress\r\n    ) internal {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n\r\n        if (tileBonus.tileBonusType == IGeography.TileBonusType.ADVANCED_PRODUCTION) {\r\n            (bytes32 buildingTypeId, uint256 capacityAmount) = registry().getAdvancedProductionTileBonusByVariation(tileBonus.tileBonusVariation);\r\n            settlement.buildings(buildingTypeId).increaseAdditionalWorkersCapacityMultiplier(capacityAmount);\r\n            return;\r\n        }\r\n\r\n        if (tileBonus.tileBonusType == IGeography.TileBonusType.ARMY_BATTLE_STATS) {\r\n            (bytes32 unitTypeId, uint256 unitBattleMultiplier) = registry().getUnitBattleMultiplierTileBonusByVariation(tileBonus.tileBonusVariation);\r\n            settlement.army().increaseUnitBattleMultiplier(unitTypeId, unitBattleMultiplier);\r\n            return;\r\n        }\r\n\r\n        revert UnknownTileBonus();\r\n    }\r\n\r\n    /// @dev Removes tile bonus\r\n    function _removeTileBonus(\r\n        IGeography.TileBonus memory tileBonus,\r\n        address settlementAddress\r\n    ) internal {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n\r\n        if (tileBonus.tileBonusType == IGeography.TileBonusType.ADVANCED_PRODUCTION) {\r\n            (bytes32 buildingTypeId, uint256 capacityAmount) = registry().getAdvancedProductionTileBonusByVariation(tileBonus.tileBonusVariation);\r\n            settlement.buildings(buildingTypeId).decreaseAdditionalWorkersCapacityMultiplier(capacityAmount);\r\n            return;\r\n        }\r\n\r\n        if (tileBonus.tileBonusType == IGeography.TileBonusType.ARMY_BATTLE_STATS) {\r\n            (bytes32 unitTypeId, uint256 unitBattleMultiplier) = registry().getUnitBattleMultiplierTileBonusByVariation(tileBonus.tileBonusVariation);\r\n            settlement.army().decreaseUnitBattleMultiplier(unitTypeId, unitBattleMultiplier);\r\n            return;\r\n        }\r\n\r\n        revert UnknownTileBonus();\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/tokens/prosperity/IProsperity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../../../../token/IERC20Burnable.sol\";\r\nimport \"../../../../token/IERC20Int.sol\";\r\n\r\n/// @title Resource interface\r\n/// @notice Functions to read state/modify state in order to get current prosperity parameters and/or interact with it\r\ninterface IProsperity is IERC20Int, IERC20Burnable {\r\n    // State variables\r\n\r\n    /// @notice Mapping containing amount of prosperity spend for workers buying\r\n    /// @dev Only settlements can spend prosperity for workers\r\n    /// @param settlementAddress Address of settlement\r\n    /// @return amount Amount of prosperity spend for workers buying\r\n    function prosperitySpent(address settlementAddress) external view returns (uint256 amount);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which is disabled\r\n    error Disabled();\r\n\r\n    // Functions\r\n\r\n    /// @notice Spends prosperity for specified settlement address\r\n    /// @dev Called for settlement when settlement is buying workers\r\n    /// @param settlementAddress Address of settlement\r\n    /// @param amount Amount of prosperity spend for workers buying\r\n    function spend(address settlementAddress, uint256 amount) external;\r\n\r\n    /// @notice Mints prosperity to specified address\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param to Address which will receive prosperity\r\n    /// @param amount Amount of prosperity to mint\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/assets/tokens/prosperity/Prosperity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"../../../../token/ERC20IntBurnable.sol\";\r\nimport \"../../workersPool/IWorkersPool.sol\";\r\nimport \"../../WorldAsset.sol\";\r\n\r\ncontract Prosperity is ERC20IntBurnable, IProsperity, WorldAsset {\r\n    /// @inheritdoc IProsperity\r\n    mapping(address => uint256) public override prosperitySpent;\r\n\r\n    /// @dev Removes error for compiling, default constructor does nothing because its a proxy\r\n    constructor() ERC20Int(\"\", \"\") public {\r\n\r\n    }\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n\r\n    }\r\n\r\n    /// @inheritdoc IERC20Metadata\r\n    function name() public view override returns (string memory) {\r\n        return string.concat(\"Prosperity @\", Strings.toString(eraNumber()));\r\n    }\r\n\r\n    /// @inheritdoc IERC20Metadata\r\n    function symbol() public view override returns (string memory) {\r\n        return string.concat(\"PRS @\", Strings.toString(eraNumber()));\r\n    }\r\n\r\n    /// @inheritdoc IProsperity\r\n    function mint(address to, uint256 amount) public override onlyWorldAssetFromSameEra {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    /// @inheritdoc IProsperity\r\n    function spend(address from, uint256 amount) public override onlyWorldAssetFromSameEra {\r\n        prosperitySpent[from] += amount;\r\n        _burn(from, amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burnFrom(address account, uint256 amount) public override(ERC20IntBurnable, IERC20Burnable) {\r\n        if (_isWorldAsset(msg.sender)) {\r\n            _burn(account, amount);\r\n        } else {\r\n            ERC20IntBurnable.burnFrom(account, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice For prosperity default ERC20.transfer is disabled\r\n    function transfer(address to, uint256 amount) public override(ERC20Int, IERC20) returns (bool success) {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice For prosperity default ERC20.transferFrom is disabled\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override(ERC20Int, IERC20) returns (bool success) {\r\n        if (_isWorldAsset(msg.sender)) {\r\n            _transfer(from, to, amount);\r\n            return true;\r\n        } else {\r\n            revert Disabled();\r\n        }\r\n    }\r\n\r\n    /// @dev Checks if provided address is world or world asset\r\n    function _isWorldAsset(address addressToCheck) internal view returns (bool) {\r\n        return addressToCheck == address(world()) || world().worldAssets(eraNumber(), addressToCheck) != bytes32(0);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/tokens/resources/IResource.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../../../../token/IERC20Burnable.sol\";\r\n\r\n/// @title Resource interface\r\n/// @notice Functions to read state/modify state in order to get current resource parameters and/or interact with it\r\ninterface IResource is IERC20Burnable, IERC20 {\r\n    // State variables\r\n\r\n    /// @notice Token name\r\n    /// @dev Immutable, initialized on creation\r\n    function tokenName() external returns (string memory);\r\n\r\n    /// @notice Token symbol\r\n    /// @dev Immutable, initialized on creation\r\n    function tokenSymbol() external returns (string memory);\r\n\r\n    /// @notice Resource type id\r\n    /// @dev Immutable, initialized on creation\r\n    function resourceTypeId() external returns (bytes32);\r\n\r\n    // Functions\r\n\r\n    /// @notice Thrown when attempting to call action which only possible to be called by world asset or reward pool\r\n    error OnlyWorldAssetFromSameEraOrRewardPool();\r\n\r\n    /// @notice Thrown when attempting to transfer resources to building which does not use this resource\r\n    error ResourceNotAcceptable();\r\n\r\n    /// @notice Returns state balance for specified token owner\r\n    /// @dev Current function returns value of balances 'as is', without recalculation (same as 'balanceOf' you would expect)\r\n    /// @param tokensOwner Tokens owner\r\n    /// @return balance Balance for token owner\r\n    function stateBalanceOf(address tokensOwner) external view returns (uint256 balance);\r\n\r\n    /// @notice Mints resource to specified address\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param to Address which will receive resources\r\n    /// @param amount Amount of resources to mint\r\n    function mint(address to, uint256 amount) external;\r\n\r\n    /// @notice Spends allowance (same as ERC20._spendAllowance)\r\n    /// @dev Even though function is opened, it can be called only by world asset\r\n    function spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) external;\r\n}\r\n"
    },
    "contracts/core/assets/tokens/resources/Resource.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\nimport \"./IResource.sol\";\r\nimport \"../../building/IBuilding.sol\";\r\nimport \"../../unitsPool/IUnitsPool.sol\";\r\nimport \"../../WorldAsset.sol\";\r\nimport \"../../../../const/GameAssetTypes.sol\";\r\n\r\ncontract Resource is ERC20Burnable, IResource, WorldAsset {\r\n    /// @inheritdoc IResource\r\n    string public tokenName;\r\n    /// @inheritdoc IResource\r\n    string public tokenSymbol;\r\n    /// @inheritdoc IResource\r\n    bytes32 public resourceTypeId;\r\n\r\n    /// @dev Only world asset from same era or reward pool modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyWorldAssetFromSameEraOrRewardPool() {\r\n        _onlyWorldAssetFromSameEraOrRewardPool();\r\n        _;\r\n    }\r\n\r\n    /// @dev Removes error for compiling, default constructor does nothing because its a proxy\r\n    constructor() ERC20(\"\", \"\") public {\r\n\r\n    }\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        (\r\n            string memory _tokenName,\r\n            string memory _tokenSymbol,\r\n            bytes32 _resourceTypeId\r\n        ) = abi.decode(initParams, (string, string, bytes32));\r\n\r\n        tokenName = _tokenName;\r\n        tokenSymbol = _tokenSymbol;\r\n        resourceTypeId = _resourceTypeId;\r\n    }\r\n\r\n    /// @inheritdoc IERC20Metadata\r\n    function name() public view override returns (string memory) {\r\n        return string.concat(string.concat(tokenName, \" @\"), Strings.toString(eraNumber()));\r\n    }\r\n\r\n    /// @inheritdoc IERC20Metadata\r\n    function symbol() public view override returns (string memory) {\r\n        return string.concat(string.concat(tokenSymbol, \" @\"), Strings.toString(eraNumber()));\r\n    }\r\n\r\n    /// @inheritdoc IResource\r\n    function mint(address to, uint256 amount) public override onlyWorldAssetFromSameEra {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burn(uint256 amount) public override(ERC20Burnable, IERC20Burnable) {\r\n        ERC20Burnable.burn(amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burnFrom(address account, uint256 amount) public override(ERC20Burnable, IERC20Burnable) {\r\n        if (_isWorldAsset(msg.sender)) {\r\n            _burn(account, amount);\r\n        } else {\r\n            ERC20Burnable.burnFrom(account, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Transferred disabled if trying to transfer to the game building which does not use this resource\r\n    /// @inheritdoc IERC20\r\n    function transfer(address to, uint256 amount) public override(ERC20, IERC20) returns (bool success) {\r\n        if (world().worldAssets(eraNumber(), to) == BUILDING_GROUP_TYPE_ID && !IBuilding(to).isResourceAcceptable(resourceTypeId)) {\r\n            revert ResourceNotAcceptable();\r\n        }\r\n\r\n        return ERC20.transfer(to, amount);\r\n    }\r\n\r\n    /// @notice Transferred disabled if trying to transfer to the game building which does not use this resource\r\n    /// @inheritdoc IERC20\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override(ERC20, IERC20) returns (bool success) {\r\n        if (world().worldAssets(eraNumber(), to) == BUILDING_GROUP_TYPE_ID && !IBuilding(to).isResourceAcceptable(resourceTypeId)) {\r\n            revert ResourceNotAcceptable();\r\n        }\r\n\r\n        if (_isWorldAsset(msg.sender) || _isRewardPool(msg.sender)) {\r\n            _transfer(from, to, amount);\r\n            return true;\r\n        } else {\r\n            return ERC20.transferFrom(from, to, amount);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IResource\r\n    function spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) public override onlyWorldAssetFromSameEraOrRewardPool {\r\n        _spendAllowance(owner, spender, amount);\r\n    }\r\n\r\n    /// @notice If called for building then it returns amount of resource as if building state was applied\r\n    /// @inheritdoc IERC20\r\n    function balanceOf(address tokenOwner) public view override(ERC20, IERC20) returns (uint256) {\r\n        if (world().worldAssets(eraNumber(), tokenOwner) == BUILDING_GROUP_TYPE_ID) {\r\n            return IBuilding(tokenOwner).getResourcesAmount(resourceTypeId, block.timestamp);\r\n        }\r\n\r\n        return ERC20.balanceOf(tokenOwner);\r\n    }\r\n\r\n    /// @inheritdoc IResource\r\n    function stateBalanceOf(address tokenOwner) public view override returns (uint256 balance) {\r\n        return ERC20.balanceOf(tokenOwner);\r\n    }\r\n\r\n    /// @dev Allows caller to be only world or world asset or reward pool\r\n    function _onlyWorldAssetFromSameEraOrRewardPool() internal view {\r\n        if (msg.sender != address(world()) &&\r\n            world().worldAssets(eraNumber(), msg.sender) == bytes32(0) &&\r\n            msg.sender != address(world().rewardPool())) revert OnlyWorldAssetFromSameEraOrRewardPool();\r\n    }\r\n\r\n    /// @dev Checks if provided resource is required for building production\r\n    function _isRequiredForBuildingProduction(\r\n        bytes32 resourceTypeId,\r\n        address buildingAddress,\r\n        bool isProducingResource\r\n    ) internal view returns (bool) {\r\n        IBuilding.ProductionConfigItem[] memory productionConfigItems = IBuilding(buildingAddress).getConfig();\r\n        for (uint256 i = 0; i < productionConfigItems.length; i++) {\r\n            if (productionConfigItems[i].isProducing == isProducingResource && resourceTypeId == productionConfigItems[i].resourceTypeId) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Checks if provided address is reward pool\r\n    function _isRewardPool(address addressToCheck) internal view returns (bool) {\r\n        return address(world().rewardPool()) == addressToCheck;\r\n    }\r\n\r\n    /// @dev Checks if provided address is world or world asset\r\n    function _isWorldAsset(address addressToCheck) internal view returns (bool) {\r\n        return addressToCheck == address(world()) || world().worldAssets(eraNumber(), addressToCheck) != bytes32(0);\r\n    }\r\n\r\n    /// @notice Behaves same as default ERC20._transfer, however if resource is transferred to the building part of the resource is burned according to cultists balance\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        bool isTransferringFromBuilding = world().worldAssets(eraNumber(), from) == BUILDING_GROUP_TYPE_ID;\r\n        bool isTransferringToBuilding = world().worldAssets(eraNumber(), to) == BUILDING_GROUP_TYPE_ID;\r\n        bool isResourceProducedAtFromBuilding = isTransferringFromBuilding ? _isRequiredForBuildingProduction(resourceTypeId, from, true) : false;\r\n        bool isResourceProducedAtToBuilding = isTransferringToBuilding ? _isRequiredForBuildingProduction(resourceTypeId, to, true) : false;\r\n\r\n        //before\r\n        if (isTransferringFromBuilding) {\r\n            IBuilding(from).updateState();\r\n        }\r\n\r\n        if (isTransferringToBuilding) {\r\n            IBuilding(to).updateState();\r\n        }\r\n\r\n        //transfer\r\n        if (isTransferringFromBuilding && isTransferringToBuilding && isResourceProducedAtFromBuilding && isResourceProducedAtToBuilding) {\r\n            ERC20._transfer(from, to, amount);\r\n        } else if (isTransferringToBuilding && isResourceProducedAtToBuilding) {\r\n            ERC20._transfer(from, to, 0);\r\n        } else if (isTransferringToBuilding) {\r\n            ISettlement settlementOfBuilding = IBuilding(to).relatedSettlement();\r\n            uint256 penalty = settlementOfBuilding.relatedRegion().getPenaltyFromCultists();\r\n\r\n            uint256 amountToBeBurned = amount * penalty / 1e18;\r\n            uint256 amountToBeSent = amount - amountToBeBurned;\r\n\r\n            ERC20._transfer(from, to, amountToBeSent);\r\n\r\n            if (amountToBeBurned > 0) {\r\n                ERC20._burn(from, amountToBeBurned);\r\n            }\r\n        } else {\r\n            ERC20._transfer(from, to, amount);\r\n        }\r\n\r\n        //after\r\n        if (isTransferringFromBuilding) {\r\n            IBuilding(from).handleProductionResourcesChanged();\r\n\r\n            bool isResourceRequiredForProductionAtFromBuilding = _isRequiredForBuildingProduction(resourceTypeId, from, false);\r\n\r\n            // If anyone takes resource required for production from building -> we consider them as unlocked and increase region corruptionIndex\r\n            if (isResourceRequiredForProductionAtFromBuilding) {\r\n                ISettlement settlementOfBuilding = IBuilding(from).relatedSettlement();\r\n                settlementOfBuilding.relatedRegion().increaseCorruptionIndex(\r\n                    address(settlementOfBuilding),\r\n                    registry().getCorruptionIndexByResource(resourceTypeId) * amount / 1e18\r\n                );\r\n            }\r\n        }\r\n\r\n        if (isTransferringToBuilding) {\r\n            IBuilding(to).handleProductionResourcesChanged();\r\n\r\n            bool isResourceRequiredForProductionAtToBuilding = _isRequiredForBuildingProduction(resourceTypeId, to, false);\r\n\r\n            // If anyone sends resource required for production to building -> we consider them as locked and we should lower its region corruptionIndex\r\n            if (isResourceRequiredForProductionAtToBuilding) {\r\n                ISettlement settlementOfBuilding = IBuilding(to).relatedSettlement();\r\n                settlementOfBuilding.relatedRegion().decreaseCorruptionIndex(\r\n                    address(settlementOfBuilding),\r\n                    registry().getCorruptionIndexByResource(resourceTypeId) * amount / 1e18\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Behaves same as default ERC20._mint, however if resource is minted to building's production (non producing resource) cultists penalty should be applied\r\n    function _mint(address to, uint256 amount) internal override {\r\n        bool isMintingToBuilding = world().worldAssets(eraNumber(), to) == BUILDING_GROUP_TYPE_ID;\r\n        bool isResourceProducedAtToBuilding = isMintingToBuilding ? _isRequiredForBuildingProduction(resourceTypeId, to, true) : false;\r\n\r\n        //before\r\n        if (isMintingToBuilding) {\r\n            IBuilding(to).updateState();\r\n        }\r\n\r\n        //transfer\r\n        if (isMintingToBuilding && !isResourceProducedAtToBuilding) {\r\n            // Same as at _transfer, however since there are no resources no need to burn and there is a need to mint instead of transfer\r\n            ISettlement settlementOfBuilding = IBuilding(to).relatedSettlement();\r\n            uint256 penalty = settlementOfBuilding.relatedRegion().getPenaltyFromCultists();\r\n\r\n            uint256 amountToBeBurned = amount * penalty / 1e18;\r\n            uint256 amountToBeMinted = amount - amountToBeBurned;\r\n\r\n            ERC20._mint(to, amountToBeMinted);\r\n        } else {\r\n            ERC20._mint(to, amount);\r\n        }\r\n\r\n        //after\r\n        if (isMintingToBuilding) {\r\n            IBuilding(to).handleProductionResourcesChanged();\r\n\r\n            bool isResourceRequiredForProductionAtToBuilding = _isRequiredForBuildingProduction(resourceTypeId, to, false);\r\n\r\n            if (isResourceRequiredForProductionAtToBuilding) {\r\n                ISettlement settlementOfBuilding = IBuilding(to).relatedSettlement();\r\n                settlementOfBuilding.relatedRegion().decreaseCorruptionIndex(\r\n                    address(settlementOfBuilding),\r\n                    registry().getCorruptionIndexByResource(resourceTypeId) * amount / 1e18\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Behaves same as default ERC20._burn\r\n    function _burn(address from, uint256 amount) internal override {\r\n        bool isBurningFromBuilding = world().worldAssets(eraNumber(), from) == BUILDING_GROUP_TYPE_ID;\r\n\r\n        //before\r\n        if (isBurningFromBuilding) {\r\n            IBuilding(from).updateState();\r\n        }\r\n\r\n        //transfer\r\n        ERC20._burn(from, amount);\r\n\r\n        //after\r\n        if (isBurningFromBuilding) {\r\n            IBuilding(from).handleProductionResourcesChanged();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/tokens/units/IUnits.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../../../../token/IERC20Burnable.sol\";\r\n\r\n/// @title Units interface\r\n/// @notice Functions to read state/modify state in order to get current unit parameters and/or interact with it\r\ninterface IUnits is IERC20Burnable, IERC20 {\r\n    // State variables\r\n\r\n    /// @notice Token name\r\n    /// @dev Immutable, initialized on creation\r\n    function tokenName() external view returns (string memory);\r\n\r\n    /// @notice Token symbol\r\n    /// @dev Immutable, initialized on creation\r\n    function tokenSymbol() external view returns (string memory);\r\n\r\n    /// @notice Unit type id\r\n    /// @dev Immutable, initialized on creation\r\n    function unitTypeId() external view returns (bytes32);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which is disabled\r\n    error Disabled();\r\n\r\n    // Functions\r\n\r\n    /// @notice Mints units to specified address\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param to Address which will receive units\r\n    /// @param amount Amount of units to mint\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/assets/tokens/units/Units.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\nimport \"./IUnits.sol\";\r\nimport \"../../building/IBuilding.sol\";\r\nimport \"../../unitsPool/IUnitsPool.sol\";\r\nimport \"../../WorldAsset.sol\";\r\nimport \"../../../../const/GameAssetTypes.sol\";\r\n\r\ncontract Units is ERC20Burnable, IUnits, WorldAsset {\r\n    /// @inheritdoc IUnits\r\n    string public tokenName;\r\n    /// @inheritdoc IUnits\r\n    string public tokenSymbol;\r\n    /// @inheritdoc IUnits\r\n    bytes32 public override unitTypeId;\r\n\r\n    /// @dev Removes error for compiling, default constructor does nothing because its a proxy\r\n    constructor() ERC20(\"\", \"\") public {\r\n\r\n    }\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        (\r\n            string memory _tokenName,\r\n            string memory _tokenSymbol,\r\n            bytes32 _unitTypeId\r\n        ) = abi.decode(initParams, (string, string, bytes32));\r\n\r\n        tokenName = _tokenName;\r\n        tokenSymbol = _tokenSymbol;\r\n        unitTypeId = _unitTypeId;\r\n    }\r\n\r\n    /// @inheritdoc IERC20Metadata\r\n    function name() public view override returns (string memory) {\r\n        return string.concat(string.concat(tokenName, \" @\"), Strings.toString(eraNumber()));\r\n    }\r\n\r\n    /// @inheritdoc IERC20Metadata\r\n    function symbol() public view override returns (string memory) {\r\n        return string.concat(string.concat(tokenSymbol, \" @\"), Strings.toString(eraNumber()));\r\n    }\r\n\r\n    /// @inheritdoc IUnits\r\n    function mint(address to, uint256 amount) public override onlyWorldAssetFromSameEra {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burn(uint256 amount) public override(ERC20Burnable, IERC20Burnable) {\r\n        ERC20Burnable.burn(amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burnFrom(address account, uint256 amount) public override(ERC20Burnable, IERC20Burnable) {\r\n        if (_isWorldAsset(msg.sender)) {\r\n            _burn(account, amount);\r\n        } else {\r\n            ERC20Burnable.burnFrom(account, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfer is disabled\r\n    /// @inheritdoc IERC20\r\n    function transfer(address to, uint256 amount) public override(ERC20, IERC20) returns (bool success) {\r\n        revert Disabled();\r\n    }\r\n\r\n    /// @notice Transfer from is disabled\r\n    /// @inheritdoc IERC20\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override(ERC20, IERC20) returns (bool success) {\r\n        if (_isWorldAsset(msg.sender)) {\r\n            _transfer(from, to, amount);\r\n            return true;\r\n        } else {\r\n            revert Disabled();\r\n        }\r\n    }\r\n\r\n    /// @dev Checks if provided settlement cultists settlement or not\r\n    function _isCultistsSettlement(ISettlement settlement) internal view returns (bool) {\r\n        return IWorldAssetStorageAccessor(address(settlement)).assetTypeId() == CULTISTS_SETTLEMENT_TYPE_ID;\r\n    }\r\n\r\n    /// @dev Checks if provided address is world or world asset\r\n    function _isWorldAsset(address addressToCheck) internal view returns (bool) {\r\n        return addressToCheck == address(world()) || world().worldAssets(eraNumber(), addressToCheck) != bytes32(0);\r\n    }\r\n\r\n    /// @dev ERC20 _beforeTokenTransfer hook\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        //1. If Cultists is minted/burned -> updateState in region (in order to apply workers before cultists penalty is applied)\r\n        // Mint units\r\n        if (from == address(0) && world().worldAssets(eraNumber(), to) == ARMY_GROUP_TYPE_ID) {\r\n            ISettlement relatedSettlement = IArmy(to).relatedSettlement();\r\n            if (_isCultistsSettlement(relatedSettlement)) {\r\n                // Minting cultists means we have to update region time according to cultists amount before actual mint, and to this moment exactly (block.timestamp)\r\n                relatedSettlement.relatedRegion().updateRegionTime(block.timestamp);\r\n            }\r\n        }\r\n\r\n        // Burn units\r\n        if (to == address(0) && world().worldAssets(eraNumber(), from) == ARMY_GROUP_TYPE_ID) {\r\n            IArmy army = IArmy(from);\r\n            ISettlement relatedSettlement = army.relatedSettlement();\r\n            if (_isCultistsSettlement(relatedSettlement)) {\r\n                // Burning cultists units means we have to update region time according to cultists amount before actual burn, but cultists burning could only be done at battle exiting\r\n                // (we need to get battle end time and update time up to it)\r\n                IBattle cultistsBattle = army.battle();\r\n                (,, uint64 battleEndTime) = cultistsBattle.battleTimeInfo();\r\n                relatedSettlement.relatedRegion().updateRegionTime(battleEndTime);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev ERC20 _afterTokenTransfer hook\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        // Minting\r\n        if (from == address(0) && world().worldAssets(eraNumber(), to) == ARMY_GROUP_TYPE_ID) {\r\n            ISettlement relatedSettlement = IArmy(to).relatedSettlement();\r\n            if (_isCultistsSettlement(relatedSettlement)) {\r\n                relatedSettlement.relatedRegion().handleCultistsSummoned(amount);\r\n            }\r\n        }\r\n\r\n        // Burning\r\n        if (to == address(0) && world().worldAssets(eraNumber(), from) == ARMY_GROUP_TYPE_ID) {\r\n            ISettlement relatedSettlement = IArmy(from).relatedSettlement();\r\n            if (_isCultistsSettlement(relatedSettlement)) {\r\n                relatedSettlement.relatedRegion().handleCultistsDefeated(amount);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/tokens/workers/IWorkers.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../../../../token/IERC20Burnable.sol\";\r\n\r\n/// @title Workers interface\r\n/// @notice Functions to read state/modify state in order to get current unit parameters and/or interact with it\r\ninterface IWorkers is IERC20Burnable, IERC20 {\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to transfer workers with invalid from/to combinations (only specific contract combinations are allowed)\r\n    error WorkersTransferInvalidParams();\r\n\r\n    // Functions\r\n\r\n    /// @notice Mints workers to specified address\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param to Address which will receive workers\r\n    /// @param amount Amount of units to mint\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/core/assets/tokens/workers/Workers.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\nimport \"../../building/IBuilding.sol\";\r\nimport \"../../workersPool/IWorkersPool.sol\";\r\nimport \"./IWorkers.sol\";\r\nimport \"../../WorldAsset.sol\";\r\nimport \"../../../../const/GameAssetTypes.sol\";\r\n\r\ncontract Workers is ERC20Burnable, IWorkers, WorldAsset {\r\n\r\n    /// @dev Removes error for compiling, default constructor does nothing because its a proxy\r\n    constructor() ERC20(\"\", \"\") public {\r\n\r\n    }\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n\r\n    }\r\n\r\n    /// @inheritdoc IERC20Metadata\r\n    function name() public view override returns (string memory) {\r\n        return string.concat(\"Workers @\", Strings.toString(eraNumber()));\r\n    }\r\n\r\n    /// @inheritdoc IERC20Metadata\r\n    function symbol() public view override returns (string memory) {\r\n        return string.concat(\"WRK @\", Strings.toString(eraNumber()));\r\n    }\r\n\r\n    /// @inheritdoc IWorkers\r\n    function mint(address to, uint256 amount) public override onlyWorldAssetFromSameEra {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burnFrom(address from, uint256 amount) public override(ERC20Burnable, IERC20Burnable) {\r\n        if (_isWorldAsset(msg.sender)) {\r\n            _burn(from, amount);\r\n        } else {\r\n            ERC20Burnable.burnFrom(from, amount);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IERC20Burnable\r\n    function burn(uint256 amount) public override(ERC20Burnable, IERC20Burnable) {\r\n        ERC20Burnable.burn(amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override(ERC20, IERC20) returns (bool) {\r\n        if (_isWorldAsset(msg.sender)) {\r\n            _transfer(from, to, amount);\r\n            return true;\r\n        } else {\r\n            return ERC20.transferFrom(from, to, amount);\r\n        }\r\n    }\r\n\r\n    /// @dev Checks if provided address is world or world asset\r\n    function _isWorldAsset(address addressToCheck) internal view returns (bool) {\r\n        return addressToCheck == address(world()) || world().worldAssets(eraNumber(), addressToCheck) != bytes32(0);\r\n    }\r\n\r\n    /// @dev Returns this buildings settlement\r\n    function _getSettlementByBuilding(address buildingAddress) internal view returns (address) {\r\n        return address(IBuilding(buildingAddress).relatedSettlement());\r\n    }\r\n\r\n    /// @dev ERC20 _beforeTokenTransfer hook\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        IWorld world = world();\r\n        uint256 eraNumber = eraNumber();\r\n\r\n        bool isFromWorkersPool = world.worldAssets(eraNumber, from) == WORKERS_POOL_GROUP_TYPE_ID;\r\n        bool isFromSettlement = world.worldAssets(eraNumber, from) == SETTLEMENT_GROUP_TYPE_ID;\r\n        bool isFromBuilding = world.worldAssets(eraNumber, from) == BUILDING_GROUP_TYPE_ID;\r\n\r\n        //From can be address(0) or settlement or building\r\n        if (from != address(0) && !isFromWorkersPool && !isFromSettlement && !isFromBuilding) revert WorkersTransferInvalidParams();\r\n\r\n        bool isToSettlement = world.worldAssets(eraNumber, to) == SETTLEMENT_GROUP_TYPE_ID;\r\n        bool isToBuilding = world.worldAssets(eraNumber, to) == BUILDING_GROUP_TYPE_ID;\r\n\r\n        //To can be address(0) or settlement or building\r\n        if (to != address(0) && !isToSettlement && !isToBuilding) revert WorkersTransferInvalidParams();\r\n\r\n        //Workers can be minted to settlement\r\n        //Workers can be transferred from settlement to building\r\n        //Workers can be transferred from building to settlement\r\n        //Workers can be transferred from building to building\r\n        //Everything else is disabled\r\n\r\n        if (to == address(0)) {\r\n            return;\r\n        }\r\n\r\n        if (from == address(0) && isToSettlement) {\r\n            return;\r\n        }\r\n\r\n        if (isFromSettlement && isToBuilding && _getSettlementByBuilding(to) == from) {\r\n            IBuilding(to).updateState();\r\n            return;\r\n        }\r\n\r\n        if (isFromBuilding && isToSettlement && _getSettlementByBuilding(from) == to) {\r\n            IBuilding(from).updateState();\r\n            return;\r\n        }\r\n\r\n        if (isFromBuilding && isToBuilding && _getSettlementByBuilding(from) == _getSettlementByBuilding(to)) {\r\n            IBuilding(from).updateState();\r\n            IBuilding(to).updateState();\r\n            return;\r\n        }\r\n\r\n        revert WorkersTransferInvalidParams();\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/unitsPool/IngotsUnitsPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../unitsPool/IUnitsPool.sol\";\r\nimport \"../building/impl/IFort.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../../../libraries/ABDKMath64x64.sol\";\r\nimport \"../../../const/GameAssetTypes.sol\";\r\n\r\ncontract IngotsUnitsPool is WorldAsset, IUnitsPool {\r\n    /// @inheritdoc IUnitsPool\r\n    IRegion public override relatedRegion;\r\n    /// @inheritdoc IUnitsPool\r\n    uint256 public override lastPurchaseTime;\r\n    /// @inheritdoc IUnitsPool\r\n    bytes32 public override unitTypeId;\r\n    /// @inheritdoc IUnitsPool\r\n    uint256 public override unitPrice;\r\n\r\n    /// @dev Only related region modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyRelatedRegion() {\r\n        _onlyRelatedRegion();\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        (\r\n            address _regionAddress,\r\n            bytes32 _unitTypeId\r\n        ) = abi.decode(initParams, (address, bytes32));\r\n\r\n        relatedRegion = IRegion(_regionAddress);\r\n        unitTypeId = _unitTypeId;\r\n        lastPurchaseTime = block.timestamp;\r\n        unitPrice = 10e18;\r\n    }\r\n\r\n    /// @inheritdoc IUnitsPool\r\n    function calculateTokensForExactUnits(uint256 unitsToBuy) public view override returns (uint256, uint256) {\r\n        (uint256 numerator, uint256 denominator) = registry().getUnitPriceIncreaseForEachUnit();\r\n        int128 priceIncreasePerUnit64 = ABDKMath64x64.divu(numerator, denominator);\r\n        return _calculatePriceShiftForUnits(unitsToBuy, priceIncreasePerUnit64);\r\n    }\r\n\r\n    /// @inheritdoc IUnitsPool\r\n    function swapTokensForExactUnits(\r\n        address tokensOwner,\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxTokensToSell\r\n    ) public override onlyActiveGame returns (uint256) {\r\n        return _swapIngotsForExactUnits(tokensOwner, msg.sender, settlementAddress, unitsToBuy, maxTokensToSell);\r\n    }\r\n\r\n    /// @inheritdoc IUnitsPool\r\n    function swapTokensForExactUnitsByRegion(\r\n        address tokensOwner,\r\n        address msgSender,\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxTokensToSell\r\n    ) public override onlyActiveGame onlyRelatedRegion returns (uint256) {\r\n        return _swapIngotsForExactUnits(tokensOwner, msgSender, settlementAddress, unitsToBuy, maxTokensToSell);\r\n    }\r\n\r\n    /// @dev Allows caller to be only related region\r\n    function _onlyRelatedRegion() internal view {\r\n        if (msg.sender != address(relatedRegion)) revert OnlyRelatedRegion();\r\n    }\r\n\r\n    /// @dev Returns ingots\r\n    function _ingots() internal view returns (IResource) {\r\n        return era().resources(INGOT_TYPE_ID);\r\n    }\r\n\r\n    /// @dev Returns units by pool unit type\r\n    function _units() internal view returns (IUnits) {\r\n        return era().units(unitTypeId);\r\n    }\r\n\r\n    /// @dev Calculates dropped price of unit after last purchase time\r\n    function _getUnitDroppedPrice() internal view returns (int128) {\r\n        uint256 timestamp = block.timestamp;\r\n        uint256 gameBeginTime = world().gameBeginTime();\r\n        if (timestamp < gameBeginTime) {\r\n            timestamp = gameBeginTime;\r\n        }\r\n\r\n        uint256 gameEndTime = world().gameEndTime();\r\n        if (gameEndTime != 0) {\r\n            timestamp = Math.min(timestamp, gameEndTime);\r\n        }\r\n\r\n        uint256 _lastPurchaseTime = lastPurchaseTime;\r\n        if (_lastPurchaseTime < gameBeginTime) {\r\n            _lastPurchaseTime = gameBeginTime;\r\n        }\r\n\r\n        int128 unitPrice64 = ABDKMath64x64.divu(unitPrice, 1e18);\r\n\r\n        if (_lastPurchaseTime >= timestamp) {\r\n            return unitPrice64;\r\n        }\r\n\r\n        uint256 secondsPassed = timestamp - _lastPurchaseTime;\r\n\r\n        (uint256 numerator, uint256 denominator) = registry().getUnitPriceDropByUnitTypeId(unitTypeId);\r\n        int128 priceDropPerSecond64 = ABDKMath64x64.divu(numerator, denominator);\r\n        int128 priceDrop64 = ABDKMath64x64.pow(priceDropPerSecond64, secondsPassed);\r\n        return ABDKMath64x64.mul(unitPrice64, priceDrop64);\r\n    }\r\n\r\n    /// @dev Calculates amount of ingots and new unit price according to amount of units and price shift per unit interaction with the pool\r\n    function _calculatePriceShiftForUnits(\r\n        uint256 amountOfUnits,\r\n        int128 priceShiftPerUnit64\r\n    ) internal view returns (uint256, uint256) {\r\n        int128 droppedPrice = _getUnitDroppedPrice();\r\n        int128 lastUnitPriceShift64 = ABDKMath64x64.pow(\r\n            priceShiftPerUnit64,\r\n            amountOfUnits\r\n        );\r\n\r\n        int128 sumOfPriceShifts64 = ABDKMath64x64.div(\r\n            ABDKMath64x64.sub(\r\n                lastUnitPriceShift64,\r\n                ABDKMath64x64.fromUInt(1)\r\n            ),\r\n            ABDKMath64x64.ln(priceShiftPerUnit64)\r\n        );\r\n\r\n        int128 ingotsForPriceShift64 = ABDKMath64x64.mul(droppedPrice, sumOfPriceShifts64);\r\n        int128 newUnitPrice64 = ABDKMath64x64.mul(droppedPrice, lastUnitPriceShift64);\r\n\r\n        uint256 ingotsForPriceShift = uint256(ABDKMath64x64.muli(ingotsForPriceShift64, 1e18));\r\n        uint256 newUnitPrice = uint256(ABDKMath64x64.muli(newUnitPrice64, 1e18));\r\n\r\n        return (ingotsForPriceShift, newUnitPrice);\r\n    }\r\n\r\n    /// @dev Core logic related to swapping ingots for exact units\r\n    function _swapIngotsForExactUnits(\r\n        address resourcesOwner,\r\n        address msgSender,\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxIngotsToSell\r\n    ) internal returns (uint256) {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n        IArmy army = settlement.army();\r\n\r\n        settlement.updateFortHealth();\r\n        army.updateState();\r\n\r\n        if (army.isManeuvering()) revert CannotHireUnitsWhileArmyIsManeuvering();\r\n        if (!army.isAtHomePosition()) revert CannotHireUnitsWhileArmyIsNotOnHomePosition();\r\n        if (unitsToBuy == 0 || !MathExtension.isIntegerWithPrecision(unitsToBuy, 1e18)) revert CannotHireUnitsInvalidUnitsToBuySpecified();\r\n        if (address(settlement.relatedRegion()) != address(relatedRegion)) revert CannotHireUnitsForArmyWhichSettlementDoesNotBelongToRelatedRegion();\r\n        if (unitsToBuy > _getMaxAllowedToBuy(settlement, army)) revert CannotHireUnitsExceedingArmyUnitsLimit();\r\n        if (unitsToBuy > registry().getMaxAllowedUnitsToBuyPerTransaction()) revert CannotHireUnitsExceedingTransactionLimit();\r\n\r\n        (uint256 ingotsToSell, uint256 newUnitPrice) = calculateTokensForExactUnits(unitsToBuy / 1e18);\r\n\r\n        if (ingotsToSell > maxIngotsToSell) revert CannotHireUnitsDueToTheirCostIsHigherThanMaxTokensToSellSpecified();\r\n\r\n        (, uint64 stunEndTime) = army.stunInfo();\r\n        if (stunEndTime != 0) revert CannotHireUnitsWhileArmyIsStunned();\r\n\r\n        IResource ingots = _ingots();\r\n        if (resourcesOwner == address(0)) {\r\n            ingots.burnFrom(msgSender, ingotsToSell);\r\n        } else {\r\n            ingots.spendAllowance(resourcesOwner, msgSender, ingotsToSell);\r\n            ingots.burnFrom(resourcesOwner, ingotsToSell);\r\n        }\r\n\r\n        relatedRegion.decreaseCorruptionIndex(\r\n            settlementAddress,\r\n            registry().getCorruptionIndexByResource(INGOT_TYPE_ID) * ingotsToSell / 1e18\r\n        );\r\n\r\n        _units().mint(address(army), unitsToBuy);\r\n\r\n        unitPrice = newUnitPrice;\r\n        lastPurchaseTime = block.timestamp;\r\n\r\n        emit UnitsBought(\r\n            msgSender,\r\n            address(army),\r\n            unitsToBuy,\r\n            ingotsToSell,\r\n            newUnitPrice\r\n        );\r\n\r\n        return unitsToBuy;\r\n    }\r\n\r\n    /// @dev Returns fort health and its level coefficient\r\n    function _getFortHealthAndLevelCoefficient(ISettlement settlement) internal view returns (uint256, uint256) {\r\n        IFort fort = IFort(address(settlement.buildings(FORT_TYPE_ID)));\r\n        return (fort.health(), fort.getBuildingCoefficient(fort.getBuildingLevel()));\r\n    }\r\n\r\n    /// @dev Calculates army total units\r\n    function _getArmyTotalUnits(IArmy army) internal view returns (uint256) {\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n\r\n        uint256 totalUnits = 0;\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            totalUnits += era().units(unitTypeIds[i]).balanceOf(address(army));\r\n        }\r\n\r\n        return totalUnits;\r\n    }\r\n\r\n    /// @dev Calculates maximum allowed extra units that can be bought and placed into army given its total units count and fort health\r\n    function _getMaxAllowedToBuy(ISettlement settlement, IArmy army) internal view returns (uint256) {\r\n        (uint256 health, uint256 fortLevelCoefficient) = _getFortHealthAndLevelCoefficient(settlement);\r\n        uint256 currentUnits = _getArmyTotalUnits(army);\r\n\r\n        uint256 maxAllowedUnits = MathExtension.roundDownWithPrecision(\r\n            (health * registry().getUnitHiringFortHpMultiplier() / 1e18) / fortLevelCoefficient,\r\n            1e18\r\n        );\r\n\r\n        if (currentUnits >= maxAllowedUnits) {\r\n            return 0;\r\n        }\r\n\r\n        return maxAllowedUnits - currentUnits;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/unitsPool/IUnitsPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../tokens/units/IUnits.sol\";\r\nimport \"../region/IRegion.sol\";\r\n\r\n/// @title Region units pool interface\r\n/// @notice Functions to read state/modify state in order to mint units/swap tokens for units\r\ninterface IUnitsPool {\r\n\r\n    // State variables\r\n\r\n    /// @notice Region to which this pool belongs\r\n    /// @dev Immutable, initialized on the region creation\r\n    function relatedRegion() external view returns (IRegion);\r\n\r\n    /// @notice Unit type id\r\n    /// @dev Immutable, initialized on the region creation\r\n    function unitTypeId() external view returns (bytes32);\r\n\r\n    /// @notice Time at which last purchase is performed\r\n    /// @dev Updated every time when #swapTokensForExactUnits or #swapTokensForExactUnitsByRegion is called\r\n    function lastPurchaseTime() external view returns (uint256);\r\n\r\n    /// @notice Unit price\r\n    /// @dev Updated every time when #swapTokensForExactUnits or #swapTokensForExactUnitsByRegion is called\r\n    function unitPrice() external view returns (uint256);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when #swapTokensForExactUnits or #swapTokensForExactUnitsByRegion is called\r\n    /// @param spender The address which payed tokens\r\n    /// @param armyAddress The address of the army which received units\r\n    /// @param boughtUnitsAmount Amount of units bought\r\n    /// @param spentTokensAmount Spent tokens amount\r\n    event UnitsBought(\r\n        address spender,\r\n        address armyAddress,\r\n        uint256 boughtUnitsAmount,\r\n        uint256 spentTokensAmount,\r\n        uint256 newUnitPrice\r\n    );\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by related region\r\n    error OnlyRelatedRegion();\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by ruler or world asset\r\n    error OnlyRulerOrWorldAsset();\r\n\r\n    /// @notice Thrown when attempting to hire units while army is maneuvering\r\n    error CannotHireUnitsWhileArmyIsManeuvering();\r\n\r\n    /// @notice Thrown when attempting to hire units while army is stunned\r\n    error CannotHireUnitsWhileArmyIsStunned();\r\n\r\n    /// @notice Thrown when attempting to hire units while army is not on home position\r\n    error CannotHireUnitsWhileArmyIsNotOnHomePosition();\r\n\r\n    /// @notice Thrown when attempting to hire units with invalid units to buy specified\r\n    error CannotHireUnitsInvalidUnitsToBuySpecified();\r\n\r\n    /// @notice Thrown when attempting to hire units in wrong units pool\r\n    error CannotHireUnitsForArmyWhichSettlementDoesNotBelongToRelatedRegion();\r\n\r\n    /// @notice Thrown when attempting to hire more units than army limit allows\r\n    error CannotHireUnitsExceedingArmyUnitsLimit();\r\n\r\n    /// @notice Thrown when attempting to hire more units than transaction limit\r\n    error CannotHireUnitsExceedingTransactionLimit();\r\n\r\n    /// @notice Thrown when attempting to hire units due to their cost is being higher than max tokens to sell specified\r\n    error CannotHireUnitsDueToTheirCostIsHigherThanMaxTokensToSellSpecified();\r\n\r\n    // Functions\r\n\r\n    /// @notice Swaps tokens for units\r\n    /// @dev If tokensOwner == address(0) -> tokens will be taken from msg.sender\r\n    /// @dev If tokensOwner != address(0) and tokensOwner has given allowance to msg.sender >= amount of tokens for units -> tokens will be taken from tokensOwner\r\n    /// @param tokensOwner Tokens owner\r\n    /// @param settlementAddress Settlement address, army of which, will receive units\r\n    /// @param unitsToBuy Exact amount of units\r\n    /// @param maxTokensToSell Maximum amount of tokens to be taken for exact amount of units\r\n    /// @return unitsAmount Amount of units bought by tokens\r\n    function swapTokensForExactUnits(\r\n        address tokensOwner,\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxTokensToSell\r\n    ) external returns (uint256 unitsAmount);\r\n\r\n    /// @notice Swaps tokens for units by region\r\n    /// @dev Even though function is opened it can be called only by region\r\n    /// @dev If tokensOwner == address(0) -> tokens will be taken from msg.sender\r\n    /// @dev If tokensOwner != address(0) and tokensOwner has given allowance to msg.sender >= amount of tokens for units -> tokens will be taken from tokensOwner\r\n    /// @param tokensOwner Tokens owner\r\n    /// @param msgSender msg.sender from region call\r\n    /// @param settlementAddress Settlement address, army of which, will receive units\r\n    /// @param unitsToBuy Exact amount of units\r\n    /// @param maxTokensToSell Maximum amount of tokens to be taken for exact amount of units\r\n    /// @return unitsAmount Amount of units bought by tokens\r\n    function swapTokensForExactUnitsByRegion(\r\n        address tokensOwner,\r\n        address msgSender,\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxTokensToSell\r\n    ) external returns (uint256 unitsAmount);\r\n\r\n    /// @notice Calculates input of tokens based on output whole amount of units\r\n    /// @dev Returns valid output only for integer unitsToBuy value (in 1e0 precision)\r\n    /// @param unitsToBuy Amount of units to buy\r\n    /// @return tokensToSell Amount of tokens needed for unitsToBuy\r\n    /// @return newUnitPrice New unit price\r\n    function calculateTokensForExactUnits(uint256 unitsToBuy) external view returns (uint256 tokensToSell, uint256 newUnitPrice);\r\n}\r\n"
    },
    "contracts/core/assets/unitsPool/WorkersUnitsPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"../unitsPool/IUnitsPool.sol\";\r\nimport \"../building/impl/IFort.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../../../libraries/ABDKMath64x64.sol\";\r\nimport \"../../../const/GameAssetTypes.sol\";\r\n\r\ncontract WorkersUnitsPool is WorldAsset, IUnitsPool {\r\n    /// @inheritdoc IUnitsPool\r\n    IRegion public override relatedRegion;\r\n    /// @inheritdoc IUnitsPool\r\n    uint256 public override lastPurchaseTime;\r\n    /// @inheritdoc IUnitsPool\r\n    bytes32 public override unitTypeId;\r\n    /// @inheritdoc IUnitsPool\r\n    uint256 public override unitPrice;\r\n\r\n    /// @dev Only region modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyRelatedRegion() {\r\n        _onlyRelatedRegion();\r\n        _;\r\n    }\r\n\r\n    /// @dev Only ruler or world asset modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyRulerOrWorldAsset(address msgSender, address settlementAddress) {\r\n        _onlyRulerOrWorldAsset(msgSender, settlementAddress);\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        (\r\n            address _regionAddress,\r\n            bytes32 _unitTypeId\r\n        ) = abi.decode(initParams, (address, bytes32));\r\n\r\n        relatedRegion = IRegion(_regionAddress);\r\n        unitTypeId = _unitTypeId;\r\n        lastPurchaseTime = block.timestamp;\r\n        unitPrice = 1e18;\r\n    }\r\n\r\n    /// @inheritdoc IUnitsPool\r\n    function calculateTokensForExactUnits(uint256 unitsToBuy) public view override returns (uint256, uint256) {\r\n        return (unitsToBuy * unitPrice, unitPrice);\r\n    }\r\n\r\n    /// @inheritdoc IUnitsPool\r\n    function swapTokensForExactUnits(\r\n        address tokensOwner,\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxTokensToSell\r\n    ) public override onlyActiveGame onlyRulerOrWorldAsset(msg.sender, settlementAddress) returns (uint256) {\r\n        return _swapWorkersForExactUnits(tokensOwner, msg.sender, settlementAddress, unitsToBuy, maxTokensToSell);\r\n    }\r\n\r\n    /// @inheritdoc IUnitsPool\r\n    function swapTokensForExactUnitsByRegion(\r\n        address tokensOwner,\r\n        address msgSender,\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxTokensToSell\r\n    ) public override onlyActiveGame onlyRelatedRegion onlyRulerOrWorldAsset(msgSender, settlementAddress) returns (uint256) {\r\n        return _swapWorkersForExactUnits(tokensOwner, msgSender, settlementAddress, unitsToBuy, maxTokensToSell);\r\n    }\r\n\r\n    /// @dev Allows caller to be only region\r\n    function _onlyRelatedRegion() internal view {\r\n        if (msg.sender != address(relatedRegion)) revert OnlyRelatedRegion();\r\n    }\r\n\r\n    /// @dev Allows caller to be settlement ruler or world asset\r\n    function _onlyRulerOrWorldAsset(address msgSender, address settlementAddress) internal view {\r\n        if (!ISettlement(settlementAddress).isRuler(msgSender) && world().worldAssets(eraNumber(), msgSender) == bytes32(0)) revert OnlyRulerOrWorldAsset();\r\n    }\r\n\r\n    /// @dev Returns workers\r\n    function _workers() internal view returns (IWorkers) {\r\n        return era().workers();\r\n    }\r\n\r\n    /// @dev Returns units by pool unit type\r\n    function _units() internal view returns (IUnits) {\r\n        return era().units(unitTypeId);\r\n    }\r\n\r\n    /// @dev Core logic related to swapping ingots for exact units\r\n    function _swapWorkersForExactUnits(\r\n        address resourcesOwner,\r\n        address msgSender,\r\n        address settlementAddress,\r\n        uint256 unitsToBuy,\r\n        uint256 maxWorkersToSell\r\n    ) internal returns (uint256) {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n        IArmy army = settlement.army();\r\n\r\n        settlement.updateFortHealth();\r\n        army.updateState();\r\n\r\n        if (army.isManeuvering()) revert CannotHireUnitsWhileArmyIsManeuvering();\r\n        if (!army.isAtHomePosition()) revert CannotHireUnitsWhileArmyIsNotOnHomePosition();\r\n        if (unitsToBuy == 0 || !MathExtension.isIntegerWithPrecision(unitsToBuy, 1e18)) revert CannotHireUnitsInvalidUnitsToBuySpecified();\r\n        if (address(settlement.relatedRegion()) != address(relatedRegion)) revert CannotHireUnitsForArmyWhichSettlementDoesNotBelongToRelatedRegion();\r\n        if (unitsToBuy > _getMaxAllowedToBuy(settlement, army)) revert CannotHireUnitsExceedingArmyUnitsLimit();\r\n        if (unitsToBuy > registry().getMaxAllowedUnitsToBuyPerTransaction()) revert CannotHireUnitsExceedingTransactionLimit();\r\n\r\n        (uint256 workersToSell, uint256 newUnitPrice) = calculateTokensForExactUnits(unitsToBuy / 1e18);\r\n\r\n        if (workersToSell > maxWorkersToSell) revert CannotHireUnitsDueToTheirCostIsHigherThanMaxTokensToSellSpecified();\r\n\r\n        (, uint64 stunEndTime) = army.stunInfo();\r\n        if (stunEndTime != 0) revert CannotHireUnitsWhileArmyIsStunned();\r\n\r\n        IWorkers workers = _workers();\r\n        workers.burnFrom(settlementAddress, workersToSell);\r\n\r\n        _units().mint(address(army), unitsToBuy);\r\n\r\n        unitPrice = newUnitPrice;\r\n        lastPurchaseTime = block.timestamp;\r\n\r\n        emit UnitsBought(\r\n            msgSender,\r\n            address(army),\r\n            unitsToBuy,\r\n            workersToSell,\r\n            newUnitPrice\r\n        );\r\n\r\n        return unitsToBuy;\r\n    }\r\n\r\n    /// @dev Returns fort health and its level coefficient\r\n    function _getFortHealthAndLevelCoefficient(ISettlement settlement) internal view returns (uint256, uint256) {\r\n        IFort fort = IFort(address(settlement.buildings(FORT_TYPE_ID)));\r\n        return (fort.health(), fort.getBuildingCoefficient(fort.getBuildingLevel()));\r\n    }\r\n\r\n    /// @dev Calculates army total units\r\n    function _getArmyTotalUnits(IArmy army) internal view returns (uint256) {\r\n        bytes32[] memory unitTypeIds = registry().getUnitTypeIds();\r\n\r\n        uint256 totalUnits = 0;\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            totalUnits += era().units(unitTypeIds[i]).balanceOf(address(army));\r\n        }\r\n\r\n        return totalUnits;\r\n    }\r\n\r\n    /// @dev Calculates maximum allowed extra units that can be bought and placed into army given its total units count and fort health\r\n    function _getMaxAllowedToBuy(ISettlement settlement, IArmy army) internal view returns (uint256) {\r\n        (uint256 health, uint256 fortLevelCoefficient) = _getFortHealthAndLevelCoefficient(settlement);\r\n        uint256 currentUnits = _getArmyTotalUnits(army);\r\n\r\n        uint256 maxAllowedUnits = MathExtension.roundDownWithPrecision(\r\n            (health * registry().getUnitHiringFortHpMultiplier() / 1e18) / fortLevelCoefficient,\r\n            1e18\r\n        );\r\n\r\n        if (currentUnits >= maxAllowedUnits) {\r\n            return 0;\r\n        }\r\n\r\n        return maxAllowedUnits - currentUnits;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/workersPool/IWorkersPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../region/IRegion.sol\";\r\nimport \"../tokens/workers/IWorkers.sol\";\r\nimport \"../tokens/prosperity/IProsperity.sol\";\r\n\r\n/// @title Region workers pool interface\r\n/// @notice Functions to read state/modify state in order to mint workers/swap prosperity for workers\r\ninterface IWorkersPool {\r\n\r\n    // State variables\r\n\r\n    /// @notice Region to which this pool belongs\r\n    /// @dev Immutable, initialized on the region creation\r\n    function relatedRegion() external view returns (IRegion);\r\n\r\n    /// @notice Time at which last purchase is performed\r\n    /// @dev Updated every time when #swapProsperityForExactWorkers is called\r\n    function lastPurchaseTime() external view returns (uint256);\r\n\r\n    /// @notice Worker price\r\n    /// @dev Updated every time when #swapProsperityForExactWorkers is called\r\n    function workerPrice() external view returns (uint256);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when #swapProsperityForExactWorkers is called\r\n    /// @param buyerSettlementAddress Address of the settlement which bought workers\r\n    /// @param boughtWorkersAmount Amount of workers bought\r\n    /// @param spentProsperityAmount Amount of prosperity spent\r\n    event WorkersBought(\r\n        address buyerSettlementAddress,\r\n        uint256 boughtWorkersAmount,\r\n        uint256 spentProsperityAmount\r\n    );\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to hire workers with invalid workers to buy specified\r\n    error CannotHireWorkersInvalidWorkersToBuySpecified();\r\n\r\n    /// @notice Thrown when attempting to hire worker due to their cost is being higher than max prosperity to sell specified\r\n    error CannotHireWorkersDueToTheirCostIsHigherThanMaxProsperityToSellSpecified();\r\n\r\n    /// @notice Thrown when attempting to hire workers due to not having enough prosperity in settlement for the purchase\r\n    error CannotHireWorkersDueToNotEnoughProsperityInSettlement();\r\n\r\n    /// @notice Thrown when attempting to hire more workers than transaction limit\r\n    error CannotHireWorkersExceedingTransactionLimit();\r\n\r\n    // Functions\r\n\r\n    /// @notice Swaps prosperity for exact workers\r\n    /// @dev Even though function is opened, it can only be called by world asset\r\n    /// @param settlementAddress Settlement address\r\n    /// @param workersToBuy Exact amount of workers\r\n    /// @param maxProsperityToSell Maximum amount of prosperity to be taken for exact amount of workers\r\n    /// @return workersCount Amount of workers bought by prosperity\r\n    function swapProsperityForExactWorkers(\r\n        address settlementAddress,\r\n        uint256 workersToBuy,\r\n        uint256 maxProsperityToSell\r\n    ) external returns (uint256 workersCount);\r\n\r\n    /// @notice Calculates input of prosperity based on output whole amount of workers\r\n    /// @dev Returns valid output only for integer workersToBuy value (in 1e0 precision)\r\n    /// @param workersToBuy Amount of workers to buy\r\n    /// @return prosperityToSell Amount of prosperity needed for workersToBuy\r\n    /// @return newWorkerPrice New worker price\r\n    function calculateProsperityForExactWorkers(uint256 workersToBuy) external returns (uint256 prosperityToSell, uint256 newWorkerPrice);\r\n}\r\n"
    },
    "contracts/core/assets/workersPool/WorkersPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../../../libraries/MathExtension.sol\";\r\nimport \"./IWorkersPool.sol\";\r\nimport \"../settlement/ISettlement.sol\";\r\nimport \"../../IRegistry.sol\";\r\nimport \"../../IWorld.sol\";\r\nimport \"../region/IRegion.sol\";\r\nimport \"../WorldAsset.sol\";\r\nimport \"../../../libraries/ABDKMath64x64.sol\";\r\n\r\ncontract WorkersPool is WorldAsset, IWorkersPool {\r\n    /// @inheritdoc IWorkersPool\r\n    IRegion public override relatedRegion;\r\n    /// @inheritdoc IWorkersPool\r\n    uint256 public override lastPurchaseTime;\r\n    /// @inheritdoc IWorkersPool\r\n    uint256 public override workerPrice;\r\n\r\n    /// @inheritdoc WorldAsset\r\n    function init(bytes memory initParams) public override initializer {\r\n        (\r\n            address regionAddress\r\n        ) = abi.decode(initParams, (address));\r\n\r\n        relatedRegion = IRegion(regionAddress);\r\n        lastPurchaseTime = block.timestamp;\r\n        workerPrice = 10e18;\r\n    }\r\n\r\n    /// @inheritdoc IWorkersPool\r\n    function calculateProsperityForExactWorkers(uint256 unitsToBuy) public view override returns (uint256, uint256) {\r\n        (uint256 numerator, uint256 denominator) = registry().getWorkerPriceIncreaseForEachWorker();\r\n        int128 priceIncreasePerWorker64 = ABDKMath64x64.divu(numerator, denominator);\r\n        return _calculatePriceShiftForUnits(unitsToBuy, priceIncreasePerWorker64);\r\n    }\r\n\r\n    /// @inheritdoc IWorkersPool\r\n    function swapProsperityForExactWorkers(\r\n        address settlementAddress,\r\n        uint256 workersToBuy,\r\n        uint256 maxProsperityToSell\r\n    )\r\n        public\r\n        override\r\n        onlyWorldAssetFromSameEra\r\n        returns (uint256)\r\n    {\r\n        if (workersToBuy == 0 || !MathExtension.isIntegerWithPrecision(workersToBuy, 1e18)) revert CannotHireWorkersInvalidWorkersToBuySpecified();\r\n\r\n        ISettlement(settlementAddress).updateProsperityAmount();\r\n\r\n        if (workersToBuy > registry().getMaxAllowedWorkersToBuyPerTransaction()) revert CannotHireWorkersExceedingTransactionLimit();\r\n\r\n        (uint256 prosperityToSell, uint256 newWorkerPrice) = calculateProsperityForExactWorkers(workersToBuy / 1e18);\r\n\r\n        if (prosperityToSell > maxProsperityToSell) revert CannotHireWorkersDueToTheirCostIsHigherThanMaxProsperityToSellSpecified();\r\n\r\n        IProsperity prosperity = era().prosperity();\r\n        IWorkers workers = era().workers();\r\n\r\n        if (prosperity.balanceOf(settlementAddress) < prosperityToSell) revert CannotHireWorkersDueToNotEnoughProsperityInSettlement();\r\n\r\n        prosperity.spend(settlementAddress, prosperityToSell);\r\n        workers.mint(settlementAddress, workersToBuy);\r\n\r\n        workerPrice = newWorkerPrice;\r\n        lastPurchaseTime = block.timestamp;\r\n\r\n        emit WorkersBought(\r\n            settlementAddress,\r\n            workersToBuy,\r\n            prosperityToSell\r\n        );\r\n\r\n        return workersToBuy;\r\n    }\r\n\r\n    /// @dev Calculates dropped worker price after last purchase time\r\n    function _getDroppedWorkerPrice() internal view returns (int128) {\r\n        uint256 timestamp = block.timestamp;\r\n        uint256 gameBeginTime = world().gameBeginTime();\r\n        if (timestamp < gameBeginTime) {\r\n            timestamp = gameBeginTime;\r\n        }\r\n\r\n        uint256 gameEndTime = world().gameEndTime();\r\n        if (gameEndTime != 0) {\r\n            timestamp = Math.min(timestamp, gameEndTime);\r\n        }\r\n\r\n        uint256 _lastPurchaseTime = lastPurchaseTime;\r\n        if (_lastPurchaseTime < gameBeginTime) {\r\n            _lastPurchaseTime = gameBeginTime;\r\n        }\r\n\r\n        int128 workerPrice64 = ABDKMath64x64.divu(workerPrice, 1e18);\r\n\r\n        if (_lastPurchaseTime >= timestamp) {\r\n            return workerPrice64;\r\n        }\r\n\r\n        uint256 secondsPassed = timestamp - _lastPurchaseTime;\r\n\r\n        (uint256 numerator, uint256 denominator) = registry().getWorkerPriceDrop();\r\n        int128 priceDropPerSecond64 = ABDKMath64x64.divu(numerator, denominator);\r\n        int128 priceDrop64 = ABDKMath64x64.pow(priceDropPerSecond64, secondsPassed);\r\n        return ABDKMath64x64.mul(workerPrice64, priceDrop64);\r\n    }\r\n\r\n    /// @dev Calculates amount of prosperity and new worker price according to amount of workers and price shift per worker interaction with the pool\r\n    function _calculatePriceShiftForUnits(\r\n        uint256 amountOfWorkers,\r\n        int128 priceShiftPerWorker64\r\n    ) internal view returns (uint256, uint256) {\r\n        int128 droppedPrice = _getDroppedWorkerPrice();\r\n        int128 lastWorkerPriceShift64 = ABDKMath64x64.pow(\r\n            priceShiftPerWorker64,\r\n            amountOfWorkers\r\n        );\r\n\r\n        int128 sumOfPriceShifts64 = ABDKMath64x64.div(\r\n            ABDKMath64x64.sub(\r\n                lastWorkerPriceShift64,\r\n                ABDKMath64x64.fromUInt(1)\r\n            ),\r\n            ABDKMath64x64.ln(priceShiftPerWorker64)\r\n        );\r\n\r\n        int128 prosperityForPriceShift64 = ABDKMath64x64.mul(droppedPrice, sumOfPriceShifts64);\r\n        int128 newWorkerPrice64 = ABDKMath64x64.mul(droppedPrice, lastWorkerPriceShift64);\r\n\r\n        uint256 prosperityForPriceShift = uint256(ABDKMath64x64.muli(prosperityForPriceShift64, 1e18));\r\n        uint256 newWorkerPrice = uint256(ABDKMath64x64.muli(newWorkerPrice64, 1e18));\r\n\r\n        return (prosperityForPriceShift, newWorkerPrice);\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/WorldAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"../IWorld.sol\";\r\nimport \"./IWorldAsset.sol\";\r\nimport \"./WorldAssetStorageAccessorWithPush0.sol\";\r\n\r\n/// @title Abstract world asset\r\n/// @notice World asset must inherit this basic contract\r\n/// @dev IMPORTANT: be aware of proxy type of world asset deployed in 'WorldAssetFactory'\r\n/// @dev Different network is optimized differently for contract deployment\r\n/// @dev In order to support most of them it is required to recompile 'WorldAsset' contracts with 'WorldAssetStorageAccessorXXX' type specified in 'WorldAssetFactory'\r\nabstract contract WorldAsset is IWorldAsset, WorldAssetStorageAccessorWithPush0, Initializable {\r\n    /// @dev Only mighty creator modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyMightyCreator() {\r\n        _onlyMightyCreator();\r\n        _;\r\n    }\r\n\r\n    /// @dev Only world asset from same era modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyWorldAssetFromSameEra() {\r\n        _onlyWorldAssetFromSameEra();\r\n        _;\r\n    }\r\n\r\n    /// @dev Only active game modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyActiveGame() {\r\n        _onlyActiveGame();\r\n        _;\r\n    }\r\n\r\n    /// @dev World asset initializer\r\n    /// @param initParams Encoded init params (every world asset has own knowledge how to extract data from it)\r\n    function init(bytes memory initParams) public virtual;\r\n\r\n    /// @inheritdoc IWorldAsset\r\n    function world() public view override(IWorldAsset, WorldAssetStorageAccessorWithPush0) returns (IWorld) {\r\n        return WorldAssetStorageAccessorWithPush0.world();\r\n    }\r\n\r\n    /// @inheritdoc IWorldAsset\r\n    function registry() public view override returns (IRegistry) {\r\n        return world().registry();\r\n    }\r\n\r\n    /// @inheritdoc IWorldAsset\r\n    function era() public view override returns (IEra) {\r\n        return world().eras(eraNumber());\r\n    }\r\n\r\n    /// @inheritdoc IWorldAsset\r\n    function worldAssetFactory() public view override returns (IWorldAssetFactory) {\r\n        return registry().worldAssetFactory();\r\n    }\r\n\r\n    /// @dev Allows caller to be only mighty creator\r\n    function _onlyMightyCreator() internal view {\r\n        if (msg.sender != registry().mightyCreator()) revert OnlyMightyCreator();\r\n    }\r\n\r\n    /// @dev Allows caller to be only world or world asset\r\n    function _onlyWorldAssetFromSameEra() internal view {\r\n        if (msg.sender != address(world()) &&\r\n            world().worldAssets(WorldAssetStorageAccessorWithPush0.eraNumber(), msg.sender) == bytes32(0)) revert OnlyWorldAssetFromSameEra();\r\n    }\r\n\r\n    /// @dev Allows function to be callable only while game is active\r\n    function _onlyActiveGame() internal view {\r\n        uint256 _gameBeginTime = world().gameBeginTime();\r\n        uint256 _gameEndTime = world().gameEndTime();\r\n        if (_gameBeginTime == 0 || block.timestamp < _gameBeginTime) revert OnlyActiveGame();\r\n        if (_gameEndTime != 0 && block.timestamp >= _gameEndTime) revert OnlyActiveGame();\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/WorldAssetFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IWorld.sol\";\r\nimport \"./WorldAsset.sol\";\r\nimport \"./WorldAssetProxy.sol\";\r\nimport \"./IWorldAssetFactory.sol\";\r\n\r\n/// @title World asset factory\r\n/// @notice Any world asset factory should inherit this abstract factory containing common method to create and set world asset\r\ncontract WorldAssetFactory is IWorldAssetFactory {\r\n    /// @dev Only world or world asset modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyWorldOrWorldAsset(address worldAddress, uint256 eraNumber) {\r\n        _onlyWorldOrWorldAsset(worldAddress, eraNumber);\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetFactory\r\n    function create(\r\n        address worldAddress,\r\n        uint256 eraNumber,\r\n        bytes32 assetGroupId,\r\n        bytes32 assetTypeId,\r\n        bytes memory initParams\r\n    ) public override returns (address) {\r\n        WorldAsset worldAsset = WorldAsset(createAndSet(worldAddress, eraNumber, assetGroupId, assetTypeId));\r\n        worldAsset.init(initParams);\r\n        return address(worldAsset);\r\n    }\r\n\r\n    /// @dev Creates new world asset proxy with specified world asset params and adds newly created asset to the world\r\n    function createAndSet(\r\n        address worldAddress,\r\n        uint256 eraNumber,\r\n        bytes32 assetGroupId,\r\n        bytes32 assetTypeId\r\n    ) internal onlyWorldOrWorldAsset(worldAddress, eraNumber) returns (address) {\r\n        // Beware of world asset proxy type is deployed based on desired network\r\n        address newProxyAddress = createNewWorldAssetProxyWithPush0(worldAddress, eraNumber, assetGroupId, assetTypeId);\r\n        IWorld(worldAddress).addWorldAsset(eraNumber, newProxyAddress, assetGroupId);\r\n        return newProxyAddress;\r\n    }\r\n\r\n    /// @dev Creates new world asset proxy via bytes concatenation in order to achieve minimal bytecode size and call size (implemented with PUSH0 opcode)\r\n    function createNewWorldAssetProxyWithPush0(\r\n        address worldAddress,\r\n        uint256 eraNumber,\r\n        bytes32 assetGroupId,\r\n        bytes32 assetTypeId\r\n    ) internal returns (address) {\r\n        bytes28 assetId = bytes28(keccak256(abi.encodePacked(assetGroupId, assetTypeId)));\r\n\r\n        // High level description of what happens on opcode level\r\n        // Contract is created with <creationCode><worldAssetCode>\r\n        // - creationCode is code which returns worldAssetCode (aka stores it on the blockchain)\r\n        // - worldAssetCode is world asset execution proxy code\r\n\r\n        ///// CREATION CODE START\r\n        //\r\n        //    PUSH1 0xba //size of worldAssetCode below (186 bytes => 0xBA)\r\n        //    DUP1\r\n        //    PUSH1 0x09 //size of creation code\r\n        //    PUSH0\r\n        //    CODECOPY\r\n        //    PUSH0\r\n        //    RETURN\r\n        //\r\n        ///// CREATION CODE END\r\n\r\n        ///// WORLD ASSET CODE START\r\n        //\r\n        //    1. Prepare stack for STATICCALL operation. We are going to the 'worldAddress' and requesting implementation\r\n        //       of this world asset, in the process we are storing 'worldAddress' and 'assetId' in bytecode\r\n        //       (Effectively doing IWorld(worldAddress).implementations(assetId) but in minimal bytecode possible)\r\n        //       AssetId is bytes28 exactly for purpose to minimally construct calldata for this operation.\r\n        //\r\n        //    PUSH32 0xbb993a5855555555555555555555555555555555555555555555555555555555 // <bytes4(keccak256(\"implementations(bytes28)\"))><assetId>\r\n        //    PUSH0\r\n        //    MSTORE\r\n        //    PUSH1 0x20    // retSize,      32 bytes\r\n        //    PUSH0         // retOffset,    it will be stored at memory offset 0\r\n        //    PUSH1 0x24    // argsSize,     since solidity functions require 4 bytes for function identifier, and minimal function param is 32 bytes => 4+32 = 36 = 0x24\r\n        //    PUSH0         // argsOffset,   input calldata located at memory offset 0\r\n        //    PUSH20 0x1111111111111111111111111111111111111111 // world address\r\n        //    GAS           // amount of gas to forward\r\n        //    STATICCALL\r\n        //\r\n        //    2. Prepare stack for DELEGATECALL\r\n        //       After previous step (STATICCALL) we've got\r\n        //       - worldAsset implementation address at memory (offset: 0, size: 64)\r\n        //       - '1' on stack after successful STATICCALL\r\n        //       We are assuming STATICCALL result is always '1' because if we've got to the point of deploying worldAssetProxy\r\n        //       worldAddress cannot be invalid, by doing so we are reducing contract size and its execution cost\r\n        //\r\n        //    2.1. We need to move worldAsset implementation address to the stack (from memory) in order to prepare stack\r\n        //          to DELEGATECALL\r\n        //\r\n        //    ISZERO    // remove '1' from stack, and push0 via one command (make stack 1 -> 0)\r\n        //    MLOAD     // load implementation address from memory to stack\r\n        //\r\n        //    2.2. Copy original calldata to memory at offset: 0\r\n        //\r\n        //    CALLDATASIZE\r\n        //    PUSH0\r\n        //    PUSH0\r\n        //    CALLDATACOPY\r\n        //\r\n        //    2.3. Stack preparation\r\n        //\r\n        //    PUSH0         // retOffset, 0\r\n        //    CALLDATASIZE  // argSize, calldata size\r\n        //    PUSH0         // argsOffset, 0\r\n        //    PUSH0         // retSize, will be swapped to address by next opcode\r\n        //    SWAP4         // swaps worldAsset implementation address with 'retSize'\r\n        //    GAS           // amount of gas to forward\r\n        //    DELEGATECALL\r\n        //\r\n        //    3. Copy DELEGATECALL result, check for revert, return result\r\n        //\r\n        //    3.1. Copy DELEGATECALL result to memory\r\n        //\r\n        //    RETURNDATASIZE\r\n        //    PUSH0\r\n        //    PUSH0\r\n        //    RETURNDATACOPY\r\n        //\r\n        //    3.2. Check for revert and return\r\n        //\r\n        //    PUSH0\r\n        //    RETURNDATASIZE\r\n        //    SWAP2\r\n        //    PUSH1 0x58    // opcode address of next 'JUMPDEST'\r\n        //    JUMPI\r\n        //    REVERT\r\n        //    JUMPDEST\r\n        //    RETURN\r\n        //\r\n        //    3.3. Next bytecode section is stored 'groupTypeId', 'assetTypeId', 'eraNumber'\r\n        //         Since these worldAsset parameters are always immutable it is much cheaper to store them as contract\r\n        //         code rather than storing them to the storage and also it is much cheaper to query them via\r\n        //         'EXTCODECOPY' (100 base gas) vs 'CALL + SLOAD' (200 base gas)\r\n        //\r\n        //    0x2222222222222222222222222222222222222222222222222222222222222222 // groupTypeId\r\n        //    0x3333333333333333333333333333333333333333333333333333333333333333 // assetTypeId\r\n        //    0x4444444444444444444444444444444444444444444444444444444444444444 // eraNumber\r\n        //\r\n        ///// WORLD ASSET CODE END\r\n\r\n        bytes memory _code = abi.encodePacked(\r\n            hex\"60ba8060095f395ff37fbb993a58\",\r\n            assetId,\r\n            hex\"5f5260205f60245f73\",\r\n            worldAddress,\r\n            hex\"5afa1551365f5f375f365f5f935af43d5f5f3e5f3d91605857fd5bf3\",\r\n            assetGroupId,\r\n            assetTypeId,\r\n            eraNumber\r\n        );\r\n\r\n        address proxy;\r\n        assembly {\r\n            proxy := create(0, add(_code, 0x20), mload(_code))\r\n        }\r\n\r\n        return proxy;\r\n    }\r\n\r\n    /// @dev Creates new world asset proxy via bytes concatenation in order to achieve minimal bytecode size and call size (implemented without PUSH0 opcode -> more contract size, more gas cost)\r\n    function createNewWorldAssetProxyWithoutPush0(\r\n        address worldAddress,\r\n        uint256 eraNumber,\r\n        bytes32 assetGroupId,\r\n        bytes32 assetTypeId\r\n    ) internal returns (address) {\r\n        bytes28 assetId = bytes28(keccak256(abi.encodePacked(assetGroupId, assetTypeId)));\r\n\r\n        // High level description of what happens on opcode level\r\n        // Contract is created with <creationCode><worldAssetCode>\r\n        // - creationCode is code which returns worldAssetCode (aka stores it on the blockchain)\r\n        // - worldAssetCode is world asset execution proxy code\r\n\r\n        ///// CREATION CODE START\r\n        //\r\n        //    PUSH1 0xbb //size of worldAssetCode below (187 bytes => 0xbb)\r\n        //    DUP1\r\n        //    PUSH1 0x09 //size of creation code\r\n        //    RETURNDATASIZE\r\n        //    CODECOPY\r\n        //    RETURNDATASIZE\r\n        //    RETURN\r\n        //\r\n        ///// CREATION CODE END\r\n\r\n        ///// WORLD ASSET CODE START\r\n        //\r\n        //    1. Prepare stack for STATICCALL operation. We are going to the 'worldAddress' and requesting implementation\r\n        //       of this world asset, in the process we are storing 'worldAddress' and 'assetId' in bytecode\r\n        //       (Effectively doing IWorld(worldAddress).implementations(assetId) but in minimal bytecode possible)\r\n        //       AssetId is bytes28 exactly for purpose to minimally construct calldata for this operation.\r\n        //\r\n        //    PUSH32 0xbb993a5855555555555555555555555555555555555555555555555555555555 // <bytes4(keccak256(\"implementations(bytes28)\"))><assetId>\r\n        //    RETURNDATASIZE\r\n        //    MSTORE\r\n        //    PUSH1 0x20    // retSize,      32 bytes\r\n        //    RETURNDATASIZE// retOffset,    it will be stored at memory offset 0\r\n        //    PUSH1 0x24    // argsSize,     since solidity functions require 4 bytes for function identifier, and minimal function param is 32 bytes => 4+32 = 36 = 0x24\r\n        //    DUP2          // argsOffset,   input calldata located at memory offset 0\r\n        //    PUSH20 0x1111111111111111111111111111111111111111 // world address\r\n        //    GAS           // amount of gas to forward\r\n        //    STATICCALL\r\n        //\r\n        //    // 2. Prepare stack for DELEGATECALL\r\n        //    //    After previous step (STATICCALL) we've got\r\n        //    //    - worldAsset implementation address at memory (offset: 0, size: 64)\r\n        //    //    - '1' on stack after successful STATICCALL\r\n        //    //    We are assuming STATICCALL result is always '1' because if we've got to the point of deploying worldAssetProxy\r\n        //    //    worldAddress cannot be invalid, by doing so we are reducing contract size and its execution cost\r\n        //\r\n        //    // 2.1. We need to move worldAsset implementation address to the stack (from memory) in order to prepare stack\r\n        //    //       to DELEGATECALL\r\n        //\r\n        //    ISZERO    // remove '1' from stack, and push0 via one command (make stack 1 -> 0) // 0\r\n        //    DUP1                                                                      // 0 0\r\n        //    MLOAD     // load implementation address from memory to stack             // mload 0\r\n        //\r\n        //    // 2.2. Copy original calldata to memory at offset: 0\r\n        //\r\n        //    CALLDATASIZE // cds mload 0\r\n        //    DUP3         // 0 cds mload 0\r\n        //    DUP1         // 0 0 cds mload 0\r\n        //    CALLDATACOPY // mload 0\r\n        //\r\n        //    // 2.3. Stack preparation\r\n        //\r\n        //    DUP2          // retOffset, 0                                             // 0 mload 0\r\n        //    CALLDATASIZE  // argSize, calldata size                                   // cds 0 mload 0\r\n        //    DUP2          // argsOffset, 0                                            // 0 cds 0 mload 0\r\n        //    DUP1          // retSize, will be swapped to address by next opcode       // 0 0 cds 0 mload 0\r\n        //    SWAP4         // swaps worldAsset implementation address with 'retSize'   // mload 0 cds 0 0 0\r\n        //    GAS           // amount of gas to forward                                 // gas mload 0 cds 0 0 0\r\n        //    DELEGATECALL                                                              // success 0\r\n        //\r\n        //    // 3. Copy DELEGATECALL result, check for revert, return result\r\n        //\r\n        //    // 3.1. Copy DELEGATECALL result to memory\r\n        //\r\n        //    RETURNDATASIZE                                                            // rds success 0\r\n        //    DUP3                                                                      // 0 rds success 0\r\n        //    DUP1                                                                      // 0 0 rds success 0\r\n        //    RETURNDATACOPY                                                            // success 0\r\n        //\r\n        //    // 3.2. Check for revert and return\r\n        //\r\n        //    SWAP1                                                                     // 0 success\r\n        //    RETURNDATASIZE                                                            // rds 0 success\r\n        //    SWAP2                                                                     // success 0 rds\r\n        //    PUSH1 0x59    // opcode address of next 'JUMPDEST'                        // 0x59 success 0 rds\r\n        //    JUMPI                                                                     // 0 rds\r\n        //    REVERT\r\n        //    JUMPDEST\r\n        //    RETURN\r\n        //\r\n        //    3.3. Next bytecode section is stored 'groupTypeId', 'assetTypeId', 'eraNumber'\r\n        //         Since these worldAsset parameters are always immutable it is much cheaper to store them as contract\r\n        //         code rather than storing them to the storage and also it is much cheaper to query them via\r\n        //         'EXTCODECOPY' (100 base gas) vs 'CALL + SLOAD' (200 base gas)\r\n        //\r\n        //    0x2222222222222222222222222222222222222222222222222222222222222222 // groupTypeId\r\n        //    0x3333333333333333333333333333333333333333333333333333333333333333 // assetTypeId\r\n        //    0x4444444444444444444444444444444444444444444444444444444444444444 // eraNumber\r\n        //\r\n        ///// WORLD ASSET CODE END\r\n\r\n        bytes memory _code = abi.encodePacked(\r\n            hex\"60bb8060093d393df3\",\r\n            hex\"7fbb993a58\",\r\n            assetId,\r\n            hex\"3d5260203d60248173\",\r\n            worldAddress,\r\n            hex\"5afa1580513682803781368180935af43d82803e903d91605957fd5bf3\",\r\n            assetGroupId,\r\n            assetTypeId,\r\n            eraNumber\r\n        );\r\n\r\n        address proxy;\r\n        assembly {\r\n            proxy := create(0, add(_code, 0x20), mload(_code))\r\n        }\r\n\r\n        return proxy;\r\n    }\r\n\r\n    /// @dev Creates new world asset proxy with static contract code (world proxy variables are stored in storage instead of code, making it most expensive version of proxy however it is most optimized for zk evm)\r\n    function createNewWorldAssetProxyWithStaticContractCode(\r\n        address worldAddress,\r\n        uint256 eraNumber,\r\n        bytes32 assetGroupId,\r\n        bytes32 assetTypeId\r\n    ) internal returns (address) {\r\n        return address(new WorldAssetProxy(worldAddress, eraNumber, assetGroupId, assetTypeId));\r\n    }\r\n\r\n    /// @dev Allows caller to be only world or world asset\r\n    function _onlyWorldOrWorldAsset(address worldAddress, uint256 eraNumber) internal view {\r\n        if (msg.sender != worldAddress && IWorld(worldAddress).worldAssets(eraNumber, msg.sender) == bytes32(0)) revert OnlyWorldOrWorldAsset();\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/WorldAssetProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../IWorld.sol\";\r\nimport \"./WorldAssetStorage.sol\";\r\n\r\n/// @title World asset proxy\r\n/// @notice Acts as a proxy contract to specified world asset, implementation of which is dereferenced from its creation parameters\r\ncontract WorldAssetProxy {\r\n    constructor(\r\n        address worldAddress,\r\n        uint256 eraNumber,\r\n        bytes32 assetGroupId,\r\n        bytes32 assetTypeId\r\n    ) public {\r\n        WorldAssetStorage storage proxyStorage = getWorldAssetStorage();\r\n        proxyStorage.worldAddress = worldAddress;\r\n        proxyStorage.eraNumber = eraNumber;\r\n        proxyStorage.assetId = bytes28(keccak256(abi.encodePacked(assetGroupId, assetTypeId)));\r\n        proxyStorage.assetGroupId = assetGroupId;\r\n        proxyStorage.assetTypeId = assetTypeId;\r\n    }\r\n\r\n    /// @dev Fallback function that delegates calls to the address returned by registry script contract. Will run if no other function in the contract matches the call data.\r\n    fallback() external payable {\r\n        WorldAssetStorage storage proxyStorage = getWorldAssetStorage();\r\n        address impl = IWorld(proxyStorage.worldAddress).implementations(proxyStorage.assetId);\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n\r\n            // (1) copy incoming call data\r\n            calldatacopy(ptr, 0, calldatasize())\r\n\r\n            // (2) forward call to logic contract\r\n            let result := delegatecall(gas(), impl, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n\r\n            // (3) retrieve return data\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // (4) forward return data back to caller\r\n            switch result\r\n            case 0 {\r\n                revert(ptr, size)\r\n            }\r\n            default {\r\n                return(ptr, size)\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/WorldAssetStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nstruct WorldAssetStorage {\r\n    address worldAddress;\r\n    uint256 eraNumber;\r\n    bytes28 assetId;\r\n    bytes32 assetGroupId;\r\n    bytes32 assetTypeId;\r\n}\r\n\r\nfunction getWorldAssetStorage() pure returns (WorldAssetStorage storage ds) {\r\n    //keccak256(\"mithraeum.worldassetproxy\") is 6c85b93e587873fbe6712f3b438d42c2945689b262f7bd34b8ea4e3f832a89e6\r\n    bytes32 position = 0x6c85b93e587873fbe6712f3b438d42c2945689b262f7bd34b8ea4e3f832a89e6;\r\n    assembly {\r\n        ds.slot := position\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/WorldAssetStorageAccessorWithoutPush0.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IWorldAssetStorageAccessor.sol\";\r\n\r\n/// @title World asset storage accessor\r\n/// @notice Any world asset which requires to identify itself as a specific type should inherit this contract\r\nabstract contract WorldAssetStorageAccessorWithoutPush0 is IWorldAssetStorageAccessor {\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function world() public view virtual override returns (IWorld) {\r\n        address currentAddress = address(this);\r\n        address worldAddress;\r\n        bytes memory worldAddressMemoryContainer = new bytes(20);\r\n\r\n        assembly {\r\n            //42 is where 'worldAddress' in proxy code\r\n            extcodecopy(currentAddress, add(worldAddressMemoryContainer, 32), 42, 20)\r\n            worldAddress := mload(add(worldAddressMemoryContainer, 20))\r\n        }\r\n\r\n        return IWorld(worldAddress);\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function eraNumber() public view override returns (uint256) {\r\n        address currentAddress = address(this);\r\n        uint256 _eraNumber;\r\n        bytes memory eraNumberMemoryContainer = new bytes(32);\r\n\r\n        assembly {\r\n            //without Push0\r\n            //155 is where 'eraNumber' in proxy code\r\n            extcodecopy(currentAddress, add(eraNumberMemoryContainer, 32), 155, 32)\r\n\r\n            _eraNumber := mload(add(eraNumberMemoryContainer, 32))\r\n        }\r\n\r\n        return _eraNumber;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function assetGroupId() public view override returns (bytes32) {\r\n        address currentAddress = address(this);\r\n        bytes32 _assetGroupId;\r\n        bytes memory assetGroupIdMemoryContainer = new bytes(32);\r\n\r\n        assembly {\r\n            //without Push0\r\n            //91 is where 'assetGroupId' in proxy code\r\n            extcodecopy(currentAddress, add(assetGroupIdMemoryContainer, 32), 91, 32)\r\n\r\n            _assetGroupId := mload(add(assetGroupIdMemoryContainer, 32))\r\n        }\r\n\r\n        return _assetGroupId;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function assetTypeId() public view override returns (bytes32) {\r\n        address currentAddress = address(this);\r\n        bytes32 _assetTypeId;\r\n        bytes memory assetTypeIdMemoryContainer = new bytes(32);\r\n\r\n        assembly {\r\n            //without Push0\r\n            //123 is where 'assetTypeId' in proxy code\r\n            extcodecopy(currentAddress, add(assetTypeIdMemoryContainer, 32), 123, 32)\r\n\r\n            _assetTypeId := mload(add(assetTypeIdMemoryContainer, 32))\r\n        }\r\n\r\n        return _assetTypeId;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/WorldAssetStorageAccessorWithPush0.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IWorldAssetStorageAccessor.sol\";\r\n\r\n/// @title World asset storage accessor\r\n/// @notice Any world asset which requires to identify itself as a specific type should inherit this contract\r\nabstract contract WorldAssetStorageAccessorWithPush0 is IWorldAssetStorageAccessor {\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function world() public view virtual override returns (IWorld) {\r\n        address currentAddress = address(this);\r\n        address worldAddress;\r\n        bytes memory worldAddressMemoryContainer = new bytes(20);\r\n\r\n        assembly {\r\n            //42 is where 'worldAddress' in proxy code\r\n            extcodecopy(currentAddress, add(worldAddressMemoryContainer, 32), 42, 20)\r\n            worldAddress := mload(add(worldAddressMemoryContainer, 20))\r\n        }\r\n\r\n        return IWorld(worldAddress);\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function eraNumber() public view override returns (uint256) {\r\n        address currentAddress = address(this);\r\n        uint256 _eraNumber;\r\n        bytes memory eraNumberMemoryContainer = new bytes(32);\r\n\r\n        assembly {\r\n            //with Push0\r\n            //154 is where 'eraNumber' in proxy code\r\n            extcodecopy(currentAddress, add(eraNumberMemoryContainer, 32), 154, 32)\r\n\r\n            _eraNumber := mload(add(eraNumberMemoryContainer, 32))\r\n        }\r\n\r\n        return _eraNumber;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function assetGroupId() public view override returns (bytes32) {\r\n        address currentAddress = address(this);\r\n        bytes32 _assetGroupId;\r\n        bytes memory assetGroupIdMemoryContainer = new bytes(32);\r\n\r\n        assembly {\r\n            //with Push0\r\n            //90 is where 'assetGroupId' in proxy code\r\n            extcodecopy(currentAddress, add(assetGroupIdMemoryContainer, 32), 90, 32)\r\n\r\n            _assetGroupId := mload(add(assetGroupIdMemoryContainer, 32))\r\n        }\r\n\r\n        return _assetGroupId;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function assetTypeId() public view override returns (bytes32) {\r\n        address currentAddress = address(this);\r\n        bytes32 _assetTypeId;\r\n        bytes memory assetTypeIdMemoryContainer = new bytes(32);\r\n\r\n        assembly {\r\n            //with Push0\r\n            //122 is where 'assetTypeId' in proxy code\r\n            extcodecopy(currentAddress, add(assetTypeIdMemoryContainer, 32), 122, 32)\r\n\r\n            _assetTypeId := mload(add(assetTypeIdMemoryContainer, 32))\r\n        }\r\n\r\n        return _assetTypeId;\r\n    }\r\n}\r\n"
    },
    "contracts/core/assets/WorldAssetStorageAccessorWithStaticContractCode.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IWorldAssetStorageAccessor.sol\";\r\nimport \"./WorldAssetStorage.sol\";\r\n\r\n/// @title World asset storage accessor\r\n/// @notice Any world asset which requires to identify itself as a specific type should inherit this contract\r\nabstract contract WorldAssetStorageAccessorWithStaticContractCode is IWorldAssetStorageAccessor {\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function world() public view virtual override returns (IWorld) {\r\n        return IWorld(getWorldAssetStorage().worldAddress);\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function eraNumber() public view override returns (uint256) {\r\n        return getWorldAssetStorage().eraNumber;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function assetGroupId() public view override returns (bytes32) {\r\n        return getWorldAssetStorage().assetGroupId;\r\n    }\r\n\r\n    /// @inheritdoc IWorldAssetStorageAccessor\r\n    function assetTypeId() public view override returns (bytes32) {\r\n        return getWorldAssetStorage().assetTypeId;\r\n    }\r\n}\r\n"
    },
    "contracts/core/crossErasMemory/CrossErasMemory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./ICrossErasMemory.sol\";\r\nimport \"../WorldInitializable.sol\";\r\nimport \"../assets/IWorldAssetStorageAccessor.sol\";\r\n\r\ncontract CrossErasMemory is ICrossErasMemory, WorldInitializable  {\r\n    /// @inheritdoc ICrossErasMemory\r\n    mapping(uint64 => ISettlement) public override settlementByPosition;\r\n    /// @inheritdoc ICrossErasMemory\r\n    mapping(uint256 => ISettlement) public override settlementByBannerId;\r\n    /// @inheritdoc ICrossErasMemory\r\n    mapping(uint64 => uint256) public override regionUserSettlementsCount;\r\n    /// @inheritdoc ICrossErasMemory\r\n    mapping(uint64 => uint256) public override regionSettlementPrice;\r\n    /// @inheritdoc ICrossErasMemory\r\n    mapping(uint64 => uint256) public override regionSettlementPriceUpdateTime;\r\n\r\n    /// @dev Only active era modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyActiveEra() {\r\n        _onlyActiveEra();\r\n        _;\r\n    }\r\n\r\n    /// @dev Only world asset from old era modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyWorldAssetFromOldEra() {\r\n        _onlyWorldAssetFromOldEra();\r\n        _;\r\n    }\r\n\r\n    /// @dev Only world asset from active era modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyWorldAssetFromActiveEra() {\r\n        _onlyWorldAssetFromActiveEra();\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc ICrossErasMemory\r\n    function init(address worldAddress) public override initializer {\r\n        setWorld(worldAddress);\r\n    }\r\n\r\n    /// @inheritdoc ICrossErasMemory\r\n    function addUserSettlement(\r\n        uint256 bannerId,\r\n        uint64 regionId,\r\n        address settlementAddress,\r\n        bool isNewSettlement\r\n    ) public onlyActiveEra {\r\n        settlementByBannerId[bannerId] = ISettlement(settlementAddress);\r\n\r\n        if (isNewSettlement) {\r\n            regionUserSettlementsCount[regionId]++;\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ICrossErasMemory\r\n    function placeSettlementOnMap(\r\n        uint64 position,\r\n        address settlementAddress\r\n    ) public onlyActiveEra {\r\n        settlementByPosition[position] = ISettlement(settlementAddress);\r\n        emit SettlementOnPositionUpdated(position, settlementAddress);\r\n    }\r\n\r\n    /// @inheritdoc ICrossErasMemory\r\n    function changeRegionSettlementPrice(\r\n        uint64 regionId,\r\n        uint256 settlementPrice,\r\n        uint256 lastUpdateTime\r\n    ) public onlyWorldAssetFromActiveEra {\r\n        regionSettlementPrice[regionId] = settlementPrice;\r\n        regionSettlementPriceUpdateTime[regionId] = lastUpdateTime;\r\n    }\r\n\r\n    /// @inheritdoc ICrossErasMemory\r\n    function removeUserSettlement(address settlementAddress) public override onlyWorldAssetFromOldEra {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n        uint64 position = settlement.position();\r\n        uint64 regionId = settlement.relatedRegion().regionId();\r\n        uint256 bannerId = settlement.bannerId();\r\n\r\n        settlementByPosition[position] = ISettlement(address(0));\r\n        emit SettlementOnPositionUpdated(position, address(0));\r\n\r\n        settlementByBannerId[bannerId] = ISettlement(address(0));\r\n        regionUserSettlementsCount[regionId]--;\r\n    }\r\n\r\n    /// @dev Allows caller to be only active world era\r\n    function _onlyActiveEra() internal view {\r\n        uint256 currentEraNumber = world.currentEraNumber();\r\n        if (msg.sender != address(world.eras(currentEraNumber))) revert OnlyActiveEra();\r\n    }\r\n\r\n    /// @dev Allows caller to be only world asset from its era\r\n    function _onlyWorldAssetFromOldEra() internal view {\r\n        uint256 eraNumberOfPotentialWorldAsset = IWorldAssetStorageAccessor(msg.sender).eraNumber();\r\n        if (eraNumberOfPotentialWorldAsset >= world.currentEraNumber() ||\r\n            world.worldAssets(eraNumberOfPotentialWorldAsset, msg.sender) == bytes32(0)) revert OnlyWorldAssetFromOldEra();\r\n    }\r\n\r\n    /// @dev Allows caller to be only active world era\r\n    function _onlyWorldAssetFromActiveEra() internal view {\r\n        uint256 currentEraNumber = world.currentEraNumber();\r\n        if (world.worldAssets(currentEraNumber, msg.sender) == bytes32(0)) revert OnlyWorldAssetFromActiveEra();\r\n    }\r\n}\r\n"
    },
    "contracts/core/crossErasMemory/ICrossErasMemory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../assets/settlement/ISettlement.sol\";\r\n\r\n/// @title Cross era memory interface\r\n/// @notice Functions to read state/modify state in order to get cross era memory parameters and/or interact with it\r\ninterface ICrossErasMemory {\r\n    // State variables\r\n\r\n    /// @notice Mapping containing settlement by provided position\r\n    /// @dev Updated when #placeSettlementOnMap is called\r\n    function settlementByPosition(uint64 position) external view returns (ISettlement);\r\n\r\n    /// @notice Mapping containing settlement address by provided banner id\r\n    /// @dev Updated when #addUserSettlement is called\r\n    function settlementByBannerId(uint256 bannerId) external view returns (ISettlement);\r\n\r\n    /// @notice Mapping containing count of user settlement by provided region id\r\n    /// @dev Updated when #addUserSettlement or #removeUserSettlement is called\r\n    function regionUserSettlementsCount(uint64 regionId) external view returns (uint256);\r\n\r\n    /// @notice Mapping containing settlement price by provided region id\r\n    /// @dev Updated when #changeRegionSettlementPrice is called\r\n    function regionSettlementPrice(uint64 regionId) external view returns (uint256);\r\n\r\n    /// @notice Mapping containing settlement price update time by provided region id\r\n    /// @dev Updated when #changeRegionSettlementPrice is called\r\n    function regionSettlementPriceUpdateTime(uint64 regionId) external view returns (uint256);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when #placeSettlementOnMap or #removeUserSettlement is called\r\n    event SettlementOnPositionUpdated(uint64 position, address settlementAddress);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by active era\r\n    error OnlyActiveEra();\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by old era\r\n    error OnlyWorldAssetFromOldEra();\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by world asset from active era\r\n    error OnlyWorldAssetFromActiveEra();\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param worldAddress World address\r\n    function init(address worldAddress) external;\r\n\r\n    /// @notice Adds user settlement\r\n    /// @dev Even though this function is opened, it can only be called by world asset\r\n    /// @param bannerId Banners token id which will represent to which settlement will be attached to\r\n    /// @param regionId Region id\r\n    /// @param settlementAddress New settlement address\r\n    /// @param isNewSettlement Is new settlement\r\n    function addUserSettlement(\r\n        uint256 bannerId,\r\n        uint64 regionId,\r\n        address settlementAddress,\r\n        bool isNewSettlement\r\n    ) external;\r\n\r\n    /// @notice Changes region settlement price\r\n    /// @dev Even though this function is opened, it can only be called by world asset from active era\r\n    /// @param regionId Region id\r\n    /// @param settlementPrice Settlement price\r\n    /// @param lastUpdateTime Time at which price is changed\r\n    function changeRegionSettlementPrice(\r\n        uint64 regionId,\r\n        uint256 settlementPrice,\r\n        uint256 lastUpdateTime\r\n    ) external;\r\n\r\n    /// @notice Places settlement on map (including system ones, like CULTISTS)\r\n    /// @dev Even though this function is opened, it can only be called by active era\r\n    /// @param position Position\r\n    /// @param settlementAddress Settlement address\r\n    function placeSettlementOnMap(\r\n        uint64 position,\r\n        address settlementAddress\r\n    ) external;\r\n\r\n    /// @notice Removes user settlement\r\n    /// @dev Even though this function is opened, it can only be called by world asset from its era\r\n    /// @param settlementAddress Settlement address\r\n    function removeUserSettlement(\r\n        address settlementAddress\r\n    ) external;\r\n}\r\n"
    },
    "contracts/core/distributions/Distributions.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./IDistributions.sol\";\r\nimport \"../IWorld.sol\";\r\nimport \"../assets/building/IBuilding.sol\";\r\nimport \"../assets/IWorldAsset.sol\";\r\nimport \"../assets/IWorldAssetStorageAccessor.sol\";\r\nimport \"../../const/GameAssetTypes.sol\";\r\n\r\ncontract Distributions is IDistributions, ERC1155, Ownable {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    /// @dev Contains set of holders for specified nft id\r\n    mapping(uint256 => EnumerableSet.AddressSet) private distributionReceivers;\r\n\r\n    /// @inheritdoc IDistributions\r\n    IWorld public override world;\r\n    /// @inheritdoc IDistributions\r\n    mapping(uint256 => address) public override distributionIdToBuildingAddress;\r\n    /// @inheritdoc IDistributions\r\n    uint256 public override lastDistributionId;\r\n\r\n    /// @dev Only world asset from same era modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyWorldAssetFromSameEra() {\r\n        _onlyWorldAssetFromSameEra();\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address worldAddress_,\r\n        string memory uri_\r\n    ) ERC1155(uri_) {\r\n        world = IWorld(worldAddress_);\r\n    }\r\n\r\n    /// @notice Updates token uri\r\n    /// @dev Only owner can modify token uri\r\n    function updateURI(string memory _newUri) public onlyOwner {\r\n        _setURI(_newUri);\r\n    }\r\n\r\n    /// @inheritdoc IDistributions\r\n    function getDistributionReceivers(uint256 distributionId) public view returns (address[] memory) {\r\n        return distributionReceivers[distributionId].values();\r\n    }\r\n\r\n    /// @inheritdoc IDistributions\r\n    function mint(\r\n        address to\r\n    ) public onlyWorldAssetFromSameEra returns (uint256) {\r\n        uint256 newDistributionId = lastDistributionId + 1;\r\n\r\n        _mint(\r\n            to,\r\n            newDistributionId,\r\n            getItemsPerNft(),\r\n            bytes(\"\")\r\n        );\r\n\r\n        lastDistributionId = newDistributionId;\r\n        distributionIdToBuildingAddress[newDistributionId] = msg.sender;\r\n        return newDistributionId;\r\n    }\r\n\r\n    /// @inheritdoc IDistributions\r\n    function getItemsPerNft() public pure returns (uint256) {\r\n        return 100;\r\n    }\r\n\r\n    /// @dev Allows caller to be only world asset from same era\r\n    function _onlyWorldAssetFromSameEra() internal view {\r\n        uint256 eraNumber = IWorldAssetStorageAccessor(msg.sender).eraNumber();\r\n        if (world.worldAssets(eraNumber, msg.sender) == bytes32(0)) revert OnlyWorldAssetFromSameEra();\r\n    }\r\n\r\n    /// @dev ERC1155 _beforeTokenTransfer hook\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal override {\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            address buildingAddress = distributionIdToBuildingAddress[ids[i]];\r\n            if (buildingAddress == address(0)) {\r\n                continue;\r\n            }\r\n\r\n            // Blocks shares transfer of one building (determined by tokenId) to same type of second building (determined by 'to')\r\n            IBuilding building = IBuilding(buildingAddress);\r\n            uint256 eraNumberOfBuilding = IWorldAssetStorageAccessor(buildingAddress).eraNumber();\r\n\r\n            if (world.worldAssets(eraNumberOfBuilding, to) == BUILDING_GROUP_TYPE_ID && IBuilding(to).buildingTypeId() == building.buildingTypeId()) {\r\n                revert CannotTransferDistributionSharesToBuildingOfSameBuildingType();\r\n            }\r\n\r\n            // Distributes productions to shares sender and receiver\r\n            building.distributeToSingleShareholder(from);\r\n            building.distributeToSingleShareholder(to);\r\n        }\r\n    }\r\n\r\n    /// @dev ERC1155 _afterTokenTransfer hook\r\n    function _afterTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal override {\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            EnumerableSet.AddressSet storage receivers = distributionReceivers[ids[i]];\r\n\r\n            if (from != address(0) && balanceOf(from, ids[i]) == 0) {\r\n                receivers.remove(from);\r\n            }\r\n\r\n            // In case 'to' is already a receiver -> this will do nothing\r\n            receivers.add(to);\r\n\r\n            // Its necessary to update produced resource debt for both 'from' and 'to' in order to maintain valid resources distribution\r\n            address buildingAddress = distributionIdToBuildingAddress[ids[i]];\r\n            if (buildingAddress != address(0)) {\r\n                IBuilding(buildingAddress).updateDebtsAccordingToNewDistributionsAmounts(from, to, amounts[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/distributions/IDistributions.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\r\nimport \"../IWorld.sol\";\r\n\r\ninterface IDistributions is IERC1155 {\r\n    // State variables\r\n\r\n    /// @notice World\r\n    /// @dev Immutable, initialized on creation\r\n    function world() external view returns (IWorld);\r\n\r\n    /// @notice Mapping containing distribution id to assigned building address\r\n    /// @dev Updated when #mint is called\r\n    function distributionIdToBuildingAddress(uint256 distributionId) external view returns (address);\r\n\r\n    /// @notice Last nft token id\r\n    /// @dev Updated when #mint is called\r\n    function lastDistributionId() external view returns (uint256);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call method by not world asset from same era\r\n    error OnlyWorldAssetFromSameEra();\r\n\r\n    /// @notice Thrown when attempting to transfer distribution shares of building to building with equal building types (ex. farm to farm)\r\n    error CannotTransferDistributionSharesToBuildingOfSameBuildingType();\r\n\r\n    // Functions\r\n\r\n    /// @notice Returns set of receivers as an array\r\n    /// @dev\r\n    /// @param distributionId Distribution id\r\n    /// @return receivers An array of receivers\r\n    function getDistributionReceivers(uint256 distributionId) external view returns (address[] memory receivers);\r\n\r\n    /// @notice Mints new distribution Nft to specified address\r\n    /// @dev Can be called only by world asset from active era\r\n    /// @param to An address which will receive new nft\r\n    /// @return newDistributionId Newly minted distribution id\r\n    function mint(address to) external returns (uint256 newDistributionId);\r\n\r\n    /// @notice Returns items per nft\r\n    /// @dev Used to determine percent holdings\r\n    /// @return itemsPerNft Items per nft\r\n    function getItemsPerNft() external pure returns (uint256 itemsPerNft);\r\n}\r\n"
    },
    "contracts/core/geography/Geography.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./IGeography.sol\";\r\nimport \"../../libraries/GeographyUtils.sol\";\r\nimport \"../WorldInitializable.sol\";\r\nimport \"../../periphery/ProxyReentrancyGuard.sol\";\r\n\r\ncontract Geography is IGeography, WorldInitializable, ProxyReentrancyGuard {\r\n    /// @notice Mapping containing region id to its inclusion order\r\n    /// @dev Values are stored each time region is included and used in #isRegionIncluded\r\n    mapping(uint64 => uint256) private includedRegions;\r\n\r\n    /// @notice Mapping containing region id to its tier\r\n    /// @dev Values are stored each time region is included and used in #getRegionTier in order to persists tiers between eras\r\n    mapping(uint64 => uint256) private regionTiers;\r\n\r\n    /// @notice Amount of included regions\r\n    /// @dev Value is accessible via #getRegionsCount\r\n    uint64 private regionsCount;\r\n\r\n    /// @inheritdoc IGeography\r\n    function init(address worldAddress) public override initializer {\r\n        setWorld(worldAddress);\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function getRegionOwner(uint64 regionId) public view override returns (address) {\r\n        return world.regionOwnershipToken().ownerOf(regionId);\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function getRegionTier(uint64 regionId) public view override returns (uint256) {\r\n        uint256 savedRegionTier = regionTiers[regionId];\r\n        if (savedRegionTier != 0) {\r\n            return savedRegionTier;\r\n        }\r\n\r\n        return _generateRegionTier(regionId);\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function getRegionsCount() public view override returns (uint256) {\r\n        return regionsCount;\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function includeRegion(\r\n        uint64 newRegionPosition,\r\n        uint64 neighborRegionPosition\r\n    ) public payable override nonReentrant {\r\n        if (regionsCount == 0 && msg.sender != world.registry().mightyCreator()) {\r\n            revert FirstRegionCanOnlyBeIncludedByMightyCreator();\r\n        }\r\n\r\n        (uint64 newRegionId, bool isNewRegionPositionExist) = getRegionIdByPosition(newRegionPosition);\r\n\r\n        if (!isNewRegionPositionExist) revert CannotIncludeRegionWithInvalidRegionInclusionProofProvided();\r\n        if (isRegionIncluded(newRegionId)) revert CannotIncludeAlreadyIncludedRegion();\r\n\r\n        if (regionsCount > 0) {\r\n            (uint64 neighborRegionId, bool isNeighborRegionPositionExist) = getRegionIdByPosition(neighborRegionPosition);\r\n\r\n            if (!isNeighborRegionPositionExist) revert CannotIncludeRegionWithInvalidRegionInclusionProofProvided();\r\n            if (!isRegionIncluded(neighborRegionId)) revert CannotIncludeRegionWithInvalidRegionInclusionProofProvided();\r\n            if (!_areNeighbors(newRegionPosition, neighborRegionPosition)) revert CannotIncludeRegionWithInvalidRegionInclusionProofProvided();\r\n\r\n            if (msg.sender != world.registry().mightyCreator()) {\r\n                if (world.crossErasMemory().regionUserSettlementsCount(neighborRegionId) < registry().getMinimumUserSettlementsCountInNeighboringRegionRequiredToIncludeRegion()) revert CannotIncludeRegionDueToInsufficientUserSettlementsCountInNeighboringRegion();\r\n            }\r\n        }\r\n\r\n        if (regionsCount > 0) {\r\n            uint256 regionTier = _generateRegionTier(newRegionId);\r\n            regionTiers[newRegionId] = regionTier;\r\n\r\n            uint256 regionInclusionPrice = world.registry().getRegionInclusionPrice(regionTier);\r\n\r\n            IERC20 erc20ForRegionInclusion = world.erc20ForRegionInclusion();\r\n            if (address(erc20ForRegionInclusion) == address(0)) {\r\n                if (msg.value < regionInclusionPrice) revert CannotIncludeRegionDueToInsufficientValueSent();\r\n\r\n                uint256 valueToSendBack = msg.value > regionInclusionPrice ? msg.value - regionInclusionPrice : 0;\r\n                if (valueToSendBack > 0) {\r\n                    Address.sendValue(payable(msg.sender), valueToSendBack);\r\n                }\r\n\r\n                Address.sendValue(payable(address(world.registry().mightyCreator())), regionInclusionPrice);\r\n            } else {\r\n                SafeERC20.safeTransferFrom(\r\n                    erc20ForRegionInclusion,\r\n                    msg.sender,\r\n                    address(world.registry().mightyCreator()),\r\n                    regionInclusionPrice\r\n                );\r\n            }\r\n        } else {\r\n            regionTiers[newRegionId] = registry().getMaxRegionTier();\r\n        }\r\n\r\n        regionsCount++;\r\n        includedRegions[newRegionId] = regionsCount;\r\n        world.regionOwnershipToken().mint(msg.sender, newRegionId);\r\n\r\n        emit RegionIncluded(newRegionId);\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function isRegionIncluded(uint64 regionId) public view override returns (bool) {\r\n        return includedRegions[regionId] != 0;\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function getTileBonus(\r\n        bytes32 tileBonusesSeed,\r\n        uint256 chanceForTileWithBonus,\r\n        uint64 position\r\n    ) public pure override returns (TileBonus memory) {\r\n        bytes32 randomHash = keccak256(abi.encodePacked(position, tileBonusesSeed));\r\n        uint256 randomValue = uint256(randomHash) % 1e18;\r\n        if (randomValue > chanceForTileWithBonus) {\r\n            return TileBonus(TileBonusType.NO_BONUS, 0);\r\n        }\r\n\r\n        randomValue = uint256(keccak256(abi.encodePacked(randomHash))) % 1e18;\r\n\r\n        // Advanced production (extra workers)\r\n        // 0.67e18 total weight\r\n        uint256[] memory advancedProductionBonusVariationWeights = new uint256[](10);\r\n        advancedProductionBonusVariationWeights[0] = 0.1e18;\r\n        advancedProductionBonusVariationWeights[1] = 0.07e18;\r\n        advancedProductionBonusVariationWeights[2] = 0.09e18;\r\n        advancedProductionBonusVariationWeights[3] = 0.06e18;\r\n        advancedProductionBonusVariationWeights[4] = 0.07e18;\r\n        advancedProductionBonusVariationWeights[5] = 0.05e18;\r\n        advancedProductionBonusVariationWeights[6] = 0.06e18;\r\n        advancedProductionBonusVariationWeights[7] = 0.05e18;\r\n        advancedProductionBonusVariationWeights[8] = 0.07e18;\r\n        advancedProductionBonusVariationWeights[9] = 0.05e18;\r\n\r\n        uint256 currentWeight = 0;\r\n        for (uint8 i = 0; i < advancedProductionBonusVariationWeights.length; i++) {\r\n            uint256 newWeight = currentWeight + advancedProductionBonusVariationWeights[i];\r\n            if (randomValue >= currentWeight && randomValue < newWeight) {\r\n                return TileBonus(TileBonusType.ADVANCED_PRODUCTION, i);\r\n            }\r\n\r\n            currentWeight = newWeight;\r\n        }\r\n\r\n        // Battle multiplier\r\n        // 0.33e18 total weight\r\n        uint256[] memory battleMultiplierBonusVariationWeights = new uint256[](3);\r\n        battleMultiplierBonusVariationWeights[0] = 0.17e18;\r\n        battleMultiplierBonusVariationWeights[1] = 0.1e18;\r\n        battleMultiplierBonusVariationWeights[2] = 0.06e18;\r\n\r\n        for (uint8 i = 0; i < battleMultiplierBonusVariationWeights.length; i++) {\r\n            uint256 newWeight = currentWeight + battleMultiplierBonusVariationWeights[i];\r\n            if (randomValue >= currentWeight && randomValue < newWeight) {\r\n                return TileBonus(TileBonusType.ARMY_BATTLE_STATS, i);\r\n            }\r\n\r\n            currentWeight = newWeight;\r\n        }\r\n\r\n        revert InvalidTileBonusConfiguration();\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function getRegionIdByPosition(uint64 position) public view override returns (uint64, bool) {\r\n        IWorld _world = world;\r\n        return GeographyUtils.getRegionCenterByPosition(position, _world.getRegionRadius(), _world.getRegionSeed());\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function getRingPositions(uint64 position, uint256 radius) public pure override returns (uint64[] memory, uint256) {\r\n        uint64[] memory ringPositions = new uint64[](radius * 6);\r\n\r\n        GeographyUtils.Oddq memory movingPosition = GeographyUtils.positionToOddq(position);\r\n\r\n        for (uint256 i = 0; i < radius; i++) {\r\n            movingPosition = _getNeighborPosition(movingPosition, 4);\r\n        }\r\n\r\n        uint256 length = 0;\r\n        for (uint256 i = 0; i < 6; i++) {\r\n            for (uint256 j = 0; j < radius; j++) {\r\n                if (_isPositionInBounds(movingPosition)) {\r\n                    ringPositions[length] = GeographyUtils.oddqToPosition(movingPosition);\r\n                    length++;\r\n                }\r\n\r\n                movingPosition = _getNeighborPosition(movingPosition, i);\r\n            }\r\n        }\r\n\r\n        return (ringPositions, length);\r\n    }\r\n\r\n    /// @inheritdoc IGeography\r\n    function getDistanceBetweenPositions(uint64 position1, uint64 position2) public pure override returns (uint64) {\r\n        GeographyUtils.Oddq memory oddq1 = GeographyUtils.positionToOddq(position1);\r\n        GeographyUtils.Oddq memory oddq2 = GeographyUtils.positionToOddq(position2);\r\n\r\n        GeographyUtils.Axial memory axial1 = GeographyUtils.oddqToAxial(oddq1);\r\n        GeographyUtils.Axial memory axial2 = GeographyUtils.oddqToAxial(oddq2);\r\n\r\n        return GeographyUtils.getDistanceBetweenPositions(axial1, axial2);\r\n    }\r\n\r\n    /// @dev Checks if provided position is in game bounds\r\n    function _isPositionInBounds(GeographyUtils.Oddq memory oddq) internal pure returns (bool) {\r\n        return oddq.x >= 0 && oddq.x < int64(uint64(type(uint32).max)) && oddq.y >= 0 && oddq.y < int64(uint64(type(uint32).max));\r\n    }\r\n\r\n    /// @dev Calculates neighbor position of position according to provided direction\r\n    function _getNeighborPosition(GeographyUtils.Oddq memory oddq, uint256 direction) internal pure returns (GeographyUtils.Oddq memory) {\r\n        int64 x = oddq.x;\r\n        int64 y = oddq.y;\r\n\r\n        bool isEven = (x & 1) == 0;\r\n\r\n        if (direction == 0) {\r\n            return GeographyUtils.Oddq(x, y - 1);\r\n        }\r\n\r\n        if (direction == 1) {\r\n            if (isEven) {\r\n                return GeographyUtils.Oddq(x + 1, y - 1);\r\n            } else {\r\n                return GeographyUtils.Oddq(x + 1, y);\r\n            }\r\n        }\r\n\r\n        if (direction == 2) {\r\n            if (isEven) {\r\n                return GeographyUtils.Oddq(x + 1, y);\r\n            } else {\r\n                return GeographyUtils.Oddq(x + 1, y + 1);\r\n            }\r\n        }\r\n\r\n        if (direction == 3) {\r\n            return GeographyUtils.Oddq(x, y + 1);\r\n        }\r\n\r\n        if (direction == 4) {\r\n            if (isEven) {\r\n                return GeographyUtils.Oddq(x - 1, y);\r\n            } else {\r\n                return GeographyUtils.Oddq(x - 1, y + 1);\r\n            }\r\n        }\r\n\r\n        if (direction == 5) {\r\n            if (isEven) {\r\n                return GeographyUtils.Oddq(x - 1, y - 1);\r\n            } else {\r\n                return GeographyUtils.Oddq(x - 1, y);\r\n            }\r\n        }\r\n\r\n        revert InvalidNeighborDirectionSpecified();\r\n    }\r\n\r\n    /// @dev Checks if positions are neighbors\r\n    function _areNeighbors(uint64 position1, uint64 position2) internal pure returns (bool) {\r\n        return getDistanceBetweenPositions(position1, position2) == 1;\r\n    }\r\n\r\n    /// @dev Generates region tier by region id\r\n    function _generateRegionTier(uint64 regionId) internal view returns (uint256) {\r\n        bytes32 randomHash = keccak256(abi.encodePacked(regionId, world.getRegionTierSeed()));\r\n        uint256 randomValue = uint256(randomHash) % 1e18;\r\n        uint256 regionTier = ((randomValue * (registry().getMaxRegionTier())) / 1e18) + 1;\r\n\r\n        return regionTier;\r\n    }\r\n}\r\n"
    },
    "contracts/core/geography/IGeography.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../assets/settlement/ISettlement.sol\";\r\n\r\ninterface IGeography {\r\n    enum TileBonusType {\r\n        NO_BONUS, //0\r\n        ADVANCED_PRODUCTION, //1\r\n        ARMY_BATTLE_STATS //2\r\n    }\r\n\r\n    struct TileBonus {\r\n        TileBonusType tileBonusType;\r\n        uint8 tileBonusVariation;\r\n    }\r\n\r\n    // State variables\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when #includeRegion is called\r\n    /// @param regionId Region id\r\n    event RegionIncluded(\r\n        uint64 regionId\r\n    );\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to include first region by non mighty creator address\r\n    error FirstRegionCanOnlyBeIncludedByMightyCreator();\r\n\r\n    /// @notice Thrown when attempting to include region by providing invalid region inclusion proof\r\n    error CannotIncludeRegionWithInvalidRegionInclusionProofProvided();\r\n\r\n    /// @notice Thrown when attempting to include already included region\r\n    error CannotIncludeAlreadyIncludedRegion();\r\n\r\n    /// @notice Thrown when attempting to include region with insufficient value sent (only if world.erc20ForRegionInclusion == address(0), which is equivalent of native token)\r\n    error CannotIncludeRegionDueToInsufficientValueSent();\r\n\r\n    /// @notice Thrown when attempting to include region with insufficient amount of user settlements in neighboring region\r\n    error CannotIncludeRegionDueToInsufficientUserSettlementsCountInNeighboringRegion();\r\n\r\n    /// @notice Thrown when attempting to _getNeighborPosition with invalid neighbor direction. It should not be thrown ever, if it does this will indicate logic error\r\n    error InvalidNeighborDirectionSpecified();\r\n\r\n    /// @notice Thrown when attempting to calculate tile bonus. It should not be thrown ever, if it does this will indicate logic error\r\n    error InvalidTileBonusConfiguration();\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param worldAddress World address\r\n    function init(address worldAddress) external;\r\n\r\n    /// @notice Returns region owner\r\n    /// @dev Updated when #includeRegion is called\r\n    /// @param regionId Region id\r\n    /// @return regionOwner Region owner\r\n    function getRegionOwner(uint64 regionId) external view returns (address regionOwner);\r\n\r\n    /// @notice Returns region tier\r\n    /// @dev Updated when #includeRegion is called\r\n    /// @param regionId Region id\r\n    /// @return regionTier Region tier\r\n    function getRegionTier(uint64 regionId) external view returns (uint256 regionTier);\r\n\r\n    /// @notice Returns created regions count\r\n    /// @dev Updated when #includeRegion is called\r\n    /// @return regionsCount Regions count\r\n    function getRegionsCount() external view returns (uint256 regionsCount);\r\n\r\n    /// @notice Includes new region to the game\r\n    /// @dev In case if there is more than zero regions in the game caller must provide two neighboring positions: first for new region, second of already existing region\r\n    /// @dev In case if zero included regions -> second param is ignored\r\n    /// @param newRegionPosition New region position\r\n    /// @param neighborRegionPosition Neighbor region position\r\n    function includeRegion(\r\n        uint64 newRegionPosition,\r\n        uint64 neighborRegionPosition\r\n    ) external payable;\r\n\r\n    /// @notice Checks if region is included to the game\r\n    /// @dev Used to determine whether region can be activated or not\r\n    /// @param regionId Region id\r\n    /// @return isRegionIncluded Is region included\r\n    function isRegionIncluded(uint64 regionId) external view returns (bool isRegionIncluded);\r\n\r\n    /// @notice Returns region id by position\r\n    /// @param position Provided position\r\n    /// @return regionId Region id\r\n    /// @return isPositionExist Is position exist (may not exist due to region cavities)\r\n    function getRegionIdByPosition(uint64 position) external view returns (uint64 regionId, bool isPositionExist);\r\n\r\n    /// @notice Calculates all ring positions by provided position and radius\r\n    /// @param position Position\r\n    /// @param radius Ring radius\r\n    /// @return ringPositions Ring positions\r\n    /// @return ringPositionsLength Ring positions length (array is initialized 6 * radius, however not all values should be used)\r\n    function getRingPositions(uint64 position, uint256 radius) external pure returns (uint64[] memory ringPositions, uint256 ringPositionsLength);\r\n\r\n    /// @notice Returns tile bonus by provided position\r\n    /// @param tileBonusesSeed Tile bonuses seed\r\n    /// @param chanceForTileWithBonus Chance for tile with bonus (in 1e18 precision)\r\n    /// @param position Position\r\n    /// @return tileBonus Tile bonus struct\r\n    function getTileBonus(bytes32 tileBonusesSeed, uint256 chanceForTileWithBonus, uint64 position) external pure returns (TileBonus memory tileBonus);\r\n\r\n    /// @notice Calculates distance between positions\r\n    /// @param position1 First position\r\n    /// @param position2 Second position\r\n    /// @param distance Distance\r\n    function getDistanceBetweenPositions(uint64 position1, uint64 position2) external pure returns (uint64 distance);\r\n}\r\n"
    },
    "contracts/core/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./assets/IWorldAssetFactory.sol\";\r\n\r\n/// @title Registry interface\r\n/// @notice Functions related to current game configuration\r\ninterface IRegistry {\r\n    struct GameResource {\r\n        string tokenName;\r\n        string tokenSymbol;\r\n        bytes32 resourceTypeId;\r\n    }\r\n\r\n    struct GameUnit {\r\n        string tokenName;\r\n        string tokenSymbol;\r\n        bytes32 unitTypeId;\r\n    }\r\n\r\n    struct UnitStats {\r\n        uint256 offenseStage1;\r\n        uint256 defenceStage1;\r\n        uint256 offenseStage2;\r\n        uint256 defenceStage2;\r\n        uint256 siegePower;\r\n        uint256 siegeSupport;\r\n    }\r\n\r\n    // State variables\r\n\r\n    /// @notice An address which can configure/reconfigure current game\r\n    /// @dev Immutable, initialized on the registry creation\r\n    function mightyCreator() external view returns (address);\r\n\r\n    /// @notice World asset factory\r\n    /// @dev During new world asset creation process registry is asked for factory contract\r\n    function worldAssetFactory() external view returns (IWorldAssetFactory);\r\n\r\n    /// @notice Global multiplier\r\n    /// @dev Immutable, initialized on the registry creation\r\n    function globalMultiplier() external view returns (uint256);\r\n\r\n    /// @notice Settlement starting price\r\n    /// @dev Immutable, initialized on the registry creation\r\n    function settlementStartingPrice() external view returns (uint256);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by mighty creator\r\n    error OnlyMightyCreator();\r\n\r\n    /// @notice Thrown when attempting to call function by providing unknown parameter\r\n    error UnknownInputParameter();\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param globalMultiplier Global multiplier\r\n    /// @param settlementStartingPrice Settlement starting price\r\n    function init(\r\n        uint256 globalMultiplier,\r\n        uint256 settlementStartingPrice\r\n    ) external;\r\n\r\n    /// @notice Sets new mighty creator\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param newMightyCreator New mighty creator\r\n    function setMightyCreator(address newMightyCreator) external;\r\n\r\n    /// @notice Sets provided address as world asset factory contract\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param worldAssetFactoryAddress World asset factory address\r\n    function setWorldAssetFactory(address worldAssetFactoryAddress) external;\r\n\r\n    /// @notice Calculates worker capacity coefficient for provided building type id\r\n    /// @dev Used for internal calculation of max workers for each building\r\n    /// @param buildingTypeId Building type id\r\n    /// @return workerCapacityCoefficient Worker capacity coefficient\r\n    function getWorkerCapacityCoefficient(bytes32 buildingTypeId) external pure returns (uint256 workerCapacityCoefficient);\r\n\r\n    /// @notice Calculates basic production building coefficient\r\n    /// @dev used for internal calculation of production result\r\n    /// @param buildingTypeId Building type id\r\n    /// @return basicProductionBuildingCoefficient Basic production building coefficient\r\n    function getBasicProductionBuildingCoefficient(bytes32 buildingTypeId) external pure returns (uint256 basicProductionBuildingCoefficient);\r\n\r\n    /// @notice Returns corruptionIndex by resource type id\r\n    /// @dev Used for calculation of how much corruptionIndex increased/decreased\r\n    /// @param resourceTypeId Resource type id\r\n    /// @return corruptionIndex Amount of corruptionIndex per 1 resource (both are in 1e18 precision)\r\n    function getCorruptionIndexByResource(bytes32 resourceTypeId) external pure returns (uint256 corruptionIndex);\r\n\r\n    /// @notice Returns resource weight\r\n    /// @dev Used for calculation how much prosperity will be produced by resource in treasury\r\n    /// @param resourceTypeId Resource type id\r\n    /// @return resourceWeight Resource weight (in 1e0 precision)\r\n    function getResourceWeight(bytes32 resourceTypeId) external pure returns (uint256 resourceWeight);\r\n\r\n    /// @notice Returns robbery points per damage multiplier\r\n    /// @dev Used for determination how much robbery points will be given\r\n    /// @return robberyPointsPerDamageMultiplier Robbery points per damage multiplier (in 1e18 precision)\r\n    function getRobberyPointsPerDamageMultiplier() external pure returns (uint256 robberyPointsPerDamageMultiplier);\r\n\r\n    /// @notice Returns robbery point multiplier by provided resource type id\r\n    /// @dev Used in calculation how many resources can be exchanged for robbery points\r\n    /// @param resourceTypeId Resource type id\r\n    /// @return robberyPointsToResourceMultiplier Robbery point multiplier (in 1e18 precision)\r\n    function getRobberyPointsToResourceMultiplier(bytes32 resourceTypeId) external view returns (uint256 robberyPointsToResourceMultiplier);\r\n\r\n    /// @notice Returns global multiplier\r\n    /// @dev Used everywhere, where time is involved. Essentially determines game speed\r\n    /// @return globalMultiplier Global multiplier\r\n    function getGlobalMultiplier() external view returns (uint256 globalMultiplier);\r\n\r\n    /// @notice Returns unit stats by provided unit type\r\n    /// @dev Used everywhere, where game logic based on unit stats\r\n    /// @param unitTypeId Unit type id\r\n    /// @return unitStats Unit stats\r\n    function getUnitStats(bytes32 unitTypeId) external pure returns (UnitStats memory unitStats);\r\n\r\n    /// @notice Returns production to treasury percent\r\n    /// @dev Determines how much of buildings production will go to treasury (if not full)\r\n    /// @param toTreasuryPercent Production to treasury percent (in 1e18 precision, where 1e18 is 100%)\r\n    function getToTreasuryPercent() external pure returns (uint256 toTreasuryPercent);\r\n\r\n    /// @notice Returns base battle duration\r\n    /// @dev Used internally to determine how long battle will last\r\n    /// @return baseBattleDuration Base battle duration\r\n    function getBaseBattleDuration() external view returns (uint256 baseBattleDuration);\r\n\r\n    /// @notice Returns battle duration losing army stun multiplier\r\n    /// @dev Used internally to determine how long stun will last after army lost the battle\r\n    /// @return battleDurationLosingArmyStunMultiplier Battle duration losing army stun multiplier\r\n    function getBattleDurationLosingArmyStunMultiplier() external pure returns (uint256 battleDurationLosingArmyStunMultiplier);\r\n\r\n    /// @notice Returns battle duration winning army stun multiplier\r\n    /// @dev Used internally to determine how long stun will last after army won the battle\r\n    /// @return battleDurationWinningArmyStunMultiplier Battle duration winning army stun multiplier\r\n    function getBattleDurationWinningArmyStunMultiplier() external pure returns (uint256 battleDurationWinningArmyStunMultiplier);\r\n\r\n    /// @notice Returns maneuver duration stun multiplier\r\n    /// @dev Used internally to determine how long stun will last after armies' maneuver\r\n    /// @return maneuverDurationStunMultiplier Maneuver duration stun multiplier\r\n    function getManeuverDurationStunMultiplier() external pure returns (uint256 maneuverDurationStunMultiplier);\r\n\r\n    /// @notice Returns game building type ids\r\n    /// @dev Used internally to determine which buildings will be created on placing settlement\r\n    /// @return buildingTypeIds Building type ids\r\n    function getBuildingTypeIds() external view returns (bytes32[] memory buildingTypeIds);\r\n\r\n    /// @notice Returns game unit type ids\r\n    /// @dev Used internally in many places where interaction with units is necessary\r\n    /// @return unitTypeIds Unit type ids\r\n    function getUnitTypeIds() external view returns (bytes32[] memory unitTypeIds);\r\n\r\n    /// @notice Returns game resources\r\n    /// @dev Used internally to determine upgrade costs and providing initial resources for settlement owner based on his tier\r\n    /// @param resources Game resources\r\n    function getGameResources() external view returns (GameResource[] memory resources);\r\n\r\n    /// @notice Returns game units\r\n    /// @dev Used internally in many places where interaction with units is necessary\r\n    /// @return units Game units\r\n    function getGameUnits() external view returns (GameUnit[] memory units);\r\n\r\n    /// @notice Returns unit hiring fort hp multiplier\r\n    /// @dev Used to determine how much units in army can be presented based on its current fort hp and this parameter\r\n    /// @return unitHiringFortHpMultiplier Unit hiring fort hp multiplier\r\n    function getUnitHiringFortHpMultiplier() external pure returns (uint256 unitHiringFortHpMultiplier);\r\n\r\n    /// @notice Returns how much resource unit can take from treasury to reduce maneuver duration\r\n    /// @dev Used internally to calculate army's maneuver speed\r\n    /// @param unitTypeId Unit type id\r\n    /// @return unitResourceUsagePer1SecondOfDecreasedManeuverDuration Amount of resource to spend per unit per 1 second of decreased maneuver duration (in 1e18 precision)\r\n    function getUnitResourceUsagePer1SecondOfDecreasedManeuverDuration(bytes32 unitTypeId) external pure returns (uint256 unitResourceUsagePer1SecondOfDecreasedManeuverDuration);\r\n\r\n    /// @notice Returns how much prosperity will be given for provided unit type id\r\n    /// @dev Used internally to calculate how much prosperity will be given\r\n    /// @return prosperityPerUnit Prosperity amount per one unit (in 1e18 precision)\r\n    function getProsperityForUnitLiquidation(bytes32 unitTypeId) external pure returns (uint256 prosperityPerUnit);\r\n\r\n    /// @notice Returns how much workers will be given for provided unit type id\r\n    /// @dev Used internally to calculate how much workers will be given\r\n    /// @return workersPerUnit Workers amount per one unit (in 1e18 precision)\r\n    function getWorkersForUnitLiquidation(bytes32 unitTypeId) external pure returns (uint256 workersPerUnit);\r\n\r\n    /// @notice Returns cultists summon delay\r\n    /// @dev Used to determine is cultists can be re-summoned\r\n    /// @return cultistsSummonDelay Cultists summon delay (in seconds)\r\n    function getCultistsSummonDelay() external pure returns (uint256 cultistsSummonDelay);\r\n\r\n    /// @notice Returns max settlements that can be placed in one region\r\n    /// @dev Cultists does not count (so +1 with cultists)\r\n    /// @return maxSettlementsPerRegion Max settlements that can be placed in one region\r\n    function getMaxSettlementsPerRegion() external pure returns (uint256 maxSettlementsPerRegion);\r\n\r\n    /// @notice Returns interval duration where world is not destructible after recent cultists summon\r\n    /// @dev Used to determine if destruction is available or not\r\n    /// @return cultistsNoDestructionDelay No destruction interval duration (in seconds)\r\n    function getCultistsNoDestructionDelay() external pure returns (uint256 cultistsNoDestructionDelay);\r\n\r\n    /// @notice Returns value of cultists per region which determines cultists threshold for world destruction\r\n    /// @dev Used to determine amount of cultists that have to be present for world destruction\r\n    /// @return cultistsPerRegionMultiplier Value of cultists per region\r\n    function getCultistsPerRegionMultiplier() external pure returns (uint256 cultistsPerRegionMultiplier);\r\n\r\n    /// @notice Returns maximum amount of cultists that can be present in region\r\n    /// @dev Used to determine how many cultists will be summoned\r\n    /// @return maxCultistsPerRegion Maximum amount of cultists\r\n    function getMaxCultistsPerRegion() external pure returns (uint256 maxCultistsPerRegion);\r\n\r\n    /// @notice Returns unit type id of cultists army\r\n    /// @dev Determines type of unit in cultists army\r\n    /// @return cultistUnitTypeId Cultists unit type id\r\n    function getCultistUnitTypeId() external pure returns (bytes32 cultistUnitTypeId);\r\n\r\n    /// @notice Returns building token transfer threshold percent\r\n    /// @dev Used to determine is building token transfer allowed based on treasury percent\r\n    /// @return buildingTokenTransferThresholdPercent Building token transfer threshold percent\r\n    function getBuildingTokenTransferThresholdPercent() external pure returns (uint256 buildingTokenTransferThresholdPercent);\r\n\r\n    /// @notice Returns new settlement starting price in settlements market\r\n    /// @dev Used to determine how much base price for first settlement will be\r\n    /// @return newSettlementStartingPrice New settlement starting price\r\n    function getNewSettlementStartingPrice() external view returns (uint256 newSettlementStartingPrice);\r\n\r\n    /// @notice Returns amount of production ticks\r\n    /// @dev Used for production calculation\r\n    /// @return ticks Amount of production ticks\r\n    function getProductionTicksInSecond() external view returns (uint256 ticks);\r\n\r\n    /// @notice Returns unit price increase in unit pool for each extra unit to buy (value returned as numerator and denominator)\r\n    /// @dev Used for determination of unit price\r\n    /// @return numerator Numerator\r\n    /// @return denominator Denominator\r\n    function getUnitPriceIncreaseForEachUnit() external pure returns (uint256 numerator, uint256 denominator);\r\n\r\n    /// @notice Returns max allowed units to buy per transaction\r\n    /// @dev Limit specified in order to limit potential price overflows (value is returned in 1e18 precision)\r\n    /// @return maxAllowedUnitsToBuy Max allowed units to buy\r\n    function getMaxAllowedUnitsToBuyPerTransaction() external pure returns (uint256 maxAllowedUnitsToBuy);\r\n\r\n    /// @notice Returns unit pool price drop per second for provided unit type id (value returned as numerator and denominator)\r\n    /// @dev Used for determination of current unit pool price\r\n    /// @param unitTypeId Unit type id\r\n    /// @return numerator Numerator\r\n    /// @return denominator Denominator\r\n    function getUnitPriceDropByUnitTypeId(bytes32 unitTypeId) external pure returns (uint256 numerator, uint256 denominator);\r\n\r\n    /// @notice Returns worker pool price drop per second for each worker (value returned as numerator and denominator)\r\n    /// @dev Used for determination of worker price\r\n    /// @return numerator Numerator\r\n    /// @return denominator Denominator\r\n    function getWorkerPriceIncreaseForEachWorker() external pure returns (uint256 numerator, uint256 denominator);\r\n\r\n    /// @notice Returns max allowed workers to buy per transaction\r\n    /// @dev Limit specified in order to limit potential price overflows (value is returned in 1e18 precision)\r\n    /// @return maxAllowedWorkersToBuy Max allowed workers to buy\r\n    function getMaxAllowedWorkersToBuyPerTransaction() external pure returns (uint256 maxAllowedWorkersToBuy);\r\n\r\n    /// @notice Returns workers pool price drop per second, provided as numerator and denominator\r\n    /// @dev Used for determination of current workers pool price\r\n    /// @return numerator Numerator\r\n    /// @return denominator Denominator\r\n    function getWorkerPriceDrop() external pure returns (uint256 numerator, uint256 denominator);\r\n\r\n    /// @notice Returns max potential advanced production buff gain from capturing tiles\r\n    /// @dev Used for determination advanced production multiplier\r\n    /// @return maxAdvancedProductionTileBuff Max potential advanced production from tile buff\r\n    function getMaxAdvancedProductionTileBuff() external pure returns (uint256 maxAdvancedProductionTileBuff);\r\n\r\n    /// @notice Returns capture tile duration per each tile in distance from settlement to selected tile\r\n    /// @dev Used to capture tile duration calculation\r\n    /// @return captureTileDurationPerTile Capture tile duration per tile\r\n    function getCaptureTileDurationPerTile() external pure returns (uint256 captureTileDurationPerTile);\r\n\r\n    /// @notice Returns next capture prosperity basic threshold\r\n    /// @dev Used to determine if new bid on captured tile is possible\r\n    /// @return nextCaptureProsperityBasicThreshold Next capture prosperity basic threshold\r\n    function getNextCaptureProsperityBasicThreshold() external pure returns (uint256 nextCaptureProsperityBasicThreshold);\r\n\r\n    /// @notice Returns next capture prosperity per tile threshold\r\n    /// @dev Used to determine if new bid on captured tile is possible\r\n    /// @return nextCaptureProsperityPerTileThreshold Next capture prosperity per tile threshold\r\n    function getNextCaptureProsperityPerTileThreshold() external pure returns (uint256 nextCaptureProsperityPerTileThreshold);\r\n\r\n    /// @notice Returns percent of prosperity that has to be in settlement for claiming captured tile\r\n    /// @dev Used to determine if tile claim is possible\r\n    /// @return necessaryProsperityPercentForClaimingTileCapture Necessary prosperity percent for claiming tile capture\r\n    function getNecessaryProsperityPercentForClaimingTileCapture() external pure returns (uint256 necessaryProsperityPercentForClaimingTileCapture);\r\n\r\n    /// @notice Returns tile capture cancellation fee\r\n    /// @dev Used to determine how much prosperity has to be given in order to cancel tile capture\r\n    /// @return tileCaptureCancellationFee Tile capture cancellation fee\r\n    function getTileCaptureCancellationFee() external pure returns (uint256 tileCaptureCancellationFee);\r\n\r\n    /// @notice Returns max captured tiles for settlement\r\n    /// @dev Used to determine whether settlement can initiate tile capture\r\n    /// @param tileBonusType Tile bonus type\r\n    /// @return maxCapturedTilesForSettlement Max captured tiles for settlement with this bonus type\r\n    function getMaxCapturedTilesForSettlement(uint8 tileBonusType) external pure returns (uint256 maxCapturedTilesForSettlement);\r\n\r\n    /// @notice Returns advanced production tile bonus by variation\r\n    /// @dev Used to determine tile bonus by tile bonus variation\r\n    /// @param tileBonusVariation Tile bonus variation\r\n    /// @return buildingTypeId Building type id\r\n    /// @return capacityAmountMultiplier Capacity amount multiplier\r\n    function getAdvancedProductionTileBonusByVariation(uint8 tileBonusVariation) external pure returns (bytes32 buildingTypeId, uint256 capacityAmountMultiplier);\r\n\r\n    /// @notice Returns unit battle multiplier tile bonus by variation\r\n    /// @dev Used to determine tile bonus by tile bonus variation\r\n    /// @param tileBonusVariation Tile bonus variation\r\n    /// @return unitTypeId Unit type id\r\n    /// @return unitBattleMultiplier Unit battle multiplier\r\n    function getUnitBattleMultiplierTileBonusByVariation(uint8 tileBonusVariation) external pure returns (bytes32 unitTypeId, uint256 unitBattleMultiplier);\r\n\r\n    /// @notice Returns max region tier\r\n    /// @dev Used in validation in region tier increase\r\n    /// @return maxRegionTier Max region tier\r\n    function getMaxRegionTier() external pure returns (uint256 maxRegionTier);\r\n\r\n    /// @notice Returns initial cultists amount per region tier\r\n    /// @dev Used in region activation\r\n    /// @return initialCultistsAmount Initial cultists amount\r\n    function getInitialCultistsAmountPerRegionTier() external pure returns (uint256 initialCultistsAmount);\r\n\r\n    /// @notice Returns initial corruptionIndex amount per region tier\r\n    /// @dev Used in region activation and region tier increase handler\r\n    /// @return initialCorruptionIndexAmount Initial corruptionIndex amount\r\n    function getInitialCorruptionIndexAmountPerRegionTier() external pure returns (uint256 initialCorruptionIndexAmount);\r\n\r\n    /// @notice Returns settlement price multiplier per increased region tier\r\n    /// @dev Used in calculation of new settlement price\r\n    /// @return settlementPriceMultiplierPerIncreasedRegionTier Settlement price multiplier per increased region tier\r\n    function getSettlementPriceMultiplierPerIncreasedRegionTier() external pure returns (uint256 settlementPriceMultiplierPerIncreasedRegionTier);\r\n\r\n    /// @notice Returns stun duration multiplier of cancelled secret maneuver\r\n    /// @dev Used in calculation of stun duration during cancelling secret maneuver\r\n    /// @return stunMultiplierOfCancelledSecretManeuver Stun multiplier of cancelled secret maneuver\r\n    function getStunDurationMultiplierOfCancelledSecretManeuver() external pure returns (uint256 stunMultiplierOfCancelledSecretManeuver);\r\n\r\n    /// @notice Returns max allowed robbery multiplier increase value\r\n    /// @dev Used in army siege modification\r\n    /// @return maxAllowedRobberyMultiplierIncreaseValue Max allowed robbery multiplier increase value\r\n    function getMaxAllowedRobberyMultiplierIncreaseValue() external pure returns (uint256 maxAllowedRobberyMultiplierIncreaseValue);\r\n\r\n    /// @notice Returns army stun duration per one point of added robbery multiplier\r\n    /// @dev Used in army siege modification\r\n    /// @return armyStunDurationPerRobberyMultiplier Army stun duration per robbery multiplier\r\n    function getArmyStunDurationPerRobberyMultiplier() external pure returns (uint256 armyStunDurationPerRobberyMultiplier);\r\n\r\n    /// @notice Returns chance for tile with bonus by region tier\r\n    /// @dev Used to determine whether tile has bonus or not\r\n    /// @param regionTier Region tier\r\n    /// @return chanceForTileWithBonus Chance for tile with bonus (in 1e18 precision)\r\n    function getChanceForTileWithBonusByRegionTier(uint256 regionTier) external pure returns (uint256 chanceForTileWithBonus);\r\n\r\n    /// @notice Returns region inclusion price\r\n    /// @dev Used to determine amount of token to be taken from msg.sender in order to include region\r\n    /// @param regionTier Region tier\r\n    /// @return regionInclusionPrice Region inclusion price\r\n    function getRegionInclusionPrice(uint256 regionTier) external pure returns (uint256 regionInclusionPrice);\r\n\r\n    /// @notice Returns region owner settlement purchase percent\r\n    /// @dev Used to determine amount of tokens to be sent to region owner when another user buys settlement in his region\r\n    /// @param regionTier Region tier\r\n    /// @return percent Percent (in 1e18 precision)\r\n    function getRegionOwnerSettlementPurchasePercent(uint256 regionTier) external pure returns (uint256 percent);\r\n\r\n    /// @notice Returns unit pool type by unit type id\r\n    /// @dev Used to determine which implementation of unit pool to use for provided unit type\r\n    /// @param unitTypeId Unit type id\r\n    /// @return unitPoolType Unit pool type\r\n    function getUnitPoolType(bytes32 unitTypeId) external pure returns (bytes32 unitPoolType);\r\n\r\n    /// @notice Returns stun duration army will receive by joining battle at attacking side\r\n    /// @dev Used to determine stun duration army will receive by joining battle at attacking side\r\n    /// @return stunDuration Stun duration\r\n    function getArmyStunDurationByJoiningBattleAtAttackingSide() external pure returns (uint256 stunDuration);\r\n\r\n    /// @notice Returns initial capture prosperity basic value\r\n    /// @dev Used to determine if new bid on captured tile is possible\r\n    /// @return initialCaptureProsperityBasicValue Initial capture prosperity basic value\r\n    function getInitialCaptureProsperityBasicValue() external pure returns (uint256 initialCaptureProsperityBasicValue);\r\n\r\n    /// @notice Returns initial capture prosperity per tile value\r\n    /// @dev Used to determine if new bid on captured tile is possible\r\n    /// @return initialCaptureProsperityPerTileValue Initial capture prosperity per tile value\r\n    function getInitialCaptureProsperityPerTileValue() external pure returns (uint256 initialCaptureProsperityPerTileValue);\r\n\r\n    /// @notice Returns minimum user settlements count in neighboring region required to include region\r\n    /// @dev Used to determine whether region can be included or not\r\n    /// @return minimumUserSettlementsCount Minimum user settlements count\r\n    function getMinimumUserSettlementsCountInNeighboringRegionRequiredToIncludeRegion() external pure returns (uint256 minimumUserSettlementsCount);\r\n\r\n    /// @notice Returns settlement pay to decrease corruptionIndex penalty multiplier\r\n    /// @dev Used to determine how much corruptionIndex penalty settlement will endure whenever its corruptionIndex is lowered by paying to reward pool\r\n    /// @return penaltyMultiplier Penalty multiplier\r\n    function getSettlementPayToDecreaseCorruptionIndexPenaltyMultiplier() external pure returns (uint256 penaltyMultiplier);\r\n\r\n    /// @notice Returns minimum battle duration\r\n    /// @dev Used to determine battle duration ignoring current world multiplier\r\n    /// @return minimumBattleDuration Minimum battle duration\r\n    function getMinimumBattleDuration() external pure returns (uint256 minimumBattleDuration);\r\n\r\n    /// @notice Returns new settlement price increase multiplier\r\n    /// @dev Used to determine new settlement purchase price (in 1e18 precision)\r\n    /// @return newSettlementPriceIncreaseMultiplier New settlement price increase multiplier\r\n    function getNewSettlementPriceIncreaseMultiplier() external pure returns (uint256 newSettlementPriceIncreaseMultiplier);\r\n}\r\n"
    },
    "contracts/core/IWorld.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./IRegistry.sol\";\r\nimport \"./assets/era/IEra.sol\";\r\nimport \"./geography/IGeography.sol\";\r\nimport \"./crossErasMemory/ICrossErasMemory.sol\";\r\nimport \"./rewardPool/IRewardPool.sol\";\r\nimport \"./distributions/IDistributions.sol\";\r\nimport \"./regionOwnershipToken/IRegionOwnershipToken.sol\";\r\n\r\n/// @title World interface\r\n/// @notice Functions to read state/modify state of game world\r\ninterface IWorld {\r\n\r\n    // State variables\r\n\r\n    /// @notice Registry\r\n    /// @dev Immutable, initialized on creation\r\n    function registry() external view returns (IRegistry);\r\n\r\n    /// @notice Banners token\r\n    /// @dev Immutable, initialized on creation\r\n    function bannerContract() external view returns (IERC721);\r\n\r\n    /// @notice ERC20 token for settlement purchase\r\n    /// @dev Immutable, initialized on creation\r\n    function erc20ForSettlementPurchase() external view returns (IERC20);\r\n\r\n    /// @notice ERC20 token for region inclusion\r\n    /// @dev Immutable, initialized on creation\r\n    function erc20ForRegionInclusion() external view returns (IERC20);\r\n\r\n    /// @notice Region ownership token\r\n    /// @dev Immutable, initialized on creation\r\n    function regionOwnershipToken() external view returns (IRegionOwnershipToken);\r\n\r\n    /// @notice Distributions token\r\n    /// @dev Immutable, initialized on creation\r\n    function distributions() external view returns (IDistributions);\r\n\r\n    /// @notice Cross eras memory\r\n    /// @dev Immutable, initialized on creation\r\n    function crossErasMemory() external view returns (ICrossErasMemory);\r\n\r\n    /// @notice Reward pool\r\n    /// @dev Immutable, initialized on creation\r\n    function rewardPool() external view returns (IRewardPool);\r\n\r\n    /// @notice Game begin time\r\n    /// @dev Updated when #setGameBeginTime is called\r\n    function gameBeginTime() external view returns (uint256);\r\n\r\n    /// @notice Game end time\r\n    /// @dev Updated when #setGameEndTime is called\r\n    function gameEndTime() external view returns (uint256);\r\n\r\n    /// @notice Geography\r\n    /// @dev Immutable, initialized on creation\r\n    function geography() external view returns (IGeography);\r\n\r\n    /// @notice Current world era\r\n    /// @dev Updated when #destroy is called\r\n    function currentEraNumber() external view returns (uint256);\r\n\r\n    /// @notice World eras\r\n    /// @dev Updated when world initialized or #destroy is called\r\n    function eras(uint256 eraNumber) external view returns (IEra);\r\n\r\n    /// @notice Mapping containing assets implementations addresses by provided asset id\r\n    /// @dev Updated when #setImplementations is called\r\n    /// @dev Every worlds assets implementation (code, not data) will be defined by value from this mapping\r\n    function implementations(bytes28 assetId) external view returns (address);\r\n\r\n    /// @notice Mapping containing world asset type by provided era number and address\r\n    /// @dev Updated when #addWorldAsset is called\r\n    function worldAssets(uint256 eraNumber, address worldAsset) external view returns (bytes32);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when world initialized\r\n    /// @param registryAddress Registry contract address\r\n    /// @param crossErasMemoryAddress Cross eras memory address\r\n    /// @param geographyAddress Geography contract address\r\n    /// @param bannersAddress Banners contract address\r\n    /// @param erc20ForBuyingSettlementAddress ERC20 token for settlement purchase address\r\n    /// @param erc20ForRegionInclusionAddress ERC20 token for region inclusion address\r\n    /// @param regionOwnershipTokenAddress Region ownership token address\r\n    /// @param distributionsAddress Distributions token address\r\n    /// @param rewardPoolAddress Reward pool contract address\r\n    event WorldInitialized(\r\n        address registryAddress,\r\n        address crossErasMemoryAddress,\r\n        address geographyAddress,\r\n        address bannersAddress,\r\n        address erc20ForBuyingSettlementAddress,\r\n        address erc20ForRegionInclusionAddress,\r\n        address regionOwnershipTokenAddress,\r\n        address distributionsAddress,\r\n        address rewardPoolAddress\r\n    );\r\n\r\n    /// @notice Emitted when #setGameBeginTime is called\r\n    /// @param newBeginTime New game begin time\r\n    event GameBeginTimeUpdated(uint newBeginTime);\r\n\r\n    /// @notice Emitted when #setGameEndTime is called\r\n    /// @param newEndTime New game end time\r\n    event GameEndTimeUpdated(uint newEndTime);\r\n\r\n    /// @notice Emitted when world initialized or #destroyCurrentEra is called\r\n    /// @param newEraAddress New era address\r\n    /// @param newEraNumber New era number\r\n    event EraCreated(address newEraAddress, uint256 newEraNumber);\r\n\r\n    /// @notice Emitted after new era initialization\r\n    /// @param newEraNumber New era number\r\n    event CurrentEraNumberUpdated(uint256 newEraNumber);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called in active game (started and not finished)\r\n    error OnlyActiveGame();\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by mighty creator\r\n    error OnlyMightyCreator();\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by mighty creator or reward pool\r\n    error OnlyMightyCreatorOrRewardPool();\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by world asset factory\r\n    error OnlyFactory();\r\n\r\n    /// @notice Thrown when attempting to destroy current era while cultists destruction delay not passed since last cultists summon\r\n    error CurrentEraCannotBeDestroyedDueToCultistsNoDestructionDelayNotPassed();\r\n\r\n    /// @notice Thrown when attempting to destroy current era while cultists limit not reached\r\n    error CurrentEraCannotBeDestroyedDueCultistsLimitNotReached();\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param packedAddresses Packed addresses (registry, crossErasMemory, geography, banners, erc20ForSettlementPurchase, erc20ForRegionInclusion, regionOwnershipToken, distributions, rewardPool)\r\n    /// @param assetIds Asset ids\r\n    /// @param implementationAddresses Implementation addresses\r\n    function init(\r\n        bytes calldata packedAddresses,\r\n        bytes28[] calldata assetIds,\r\n        address[] calldata implementationAddresses\r\n    ) external;\r\n\r\n    /// @notice Adds an address as world asset\r\n    /// @dev Even though function is opened, it can only be called by factory contract\r\n    /// @param eraNumber Era number\r\n    /// @param worldAssetAddress World asset address\r\n    /// @param assetType Asset type\r\n    function addWorldAsset(\r\n        uint256 eraNumber,\r\n        address worldAssetAddress,\r\n        bytes32 assetType\r\n    ) external;\r\n\r\n    /// @notice Sets provided address as implementation for provided asset ids\r\n    /// @dev Even though function is opened, it can be called only by mightyCreator\r\n    /// @param assetIds Asset ids\r\n    /// @param implementationAddresses Implementation addresses\r\n    function setImplementations(\r\n        bytes28[] calldata assetIds,\r\n        address[] calldata implementationAddresses\r\n    ) external;\r\n\r\n    /// @notice Mints workers to provided address\r\n    /// @dev Even though function is opened, it can only be called by mighty creator\r\n    /// @param eraNumber Era number\r\n    /// @param to Address which will receive workers\r\n    /// @param value Amount of workers to mint\r\n    function mintWorkers(\r\n        uint256 eraNumber,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Mints units to provided address\r\n    /// @dev Even though function is opened, it can only be called by mighty creator\r\n    /// @param eraNumber Era number\r\n    /// @param unitTypeId Type id of unit to mint\r\n    /// @param to Address which will receive units\r\n    /// @param value Amount of units to mint\r\n    function mintUnits(\r\n        uint256 eraNumber,\r\n        bytes32 unitTypeId,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Mints resource to provided address\r\n    /// @dev Even though function is opened, it can only be called by mighty creator\r\n    /// @param eraNumber Era number\r\n    /// @param resourceTypeId Resource type id\r\n    /// @param to Address which will receive resources\r\n    /// @param value Amount of resources to mint\r\n    function mintResources(\r\n        uint256 eraNumber,\r\n        bytes32 resourceTypeId,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    /// @notice Sets game end time\r\n    /// @dev Even though function is opened, it can only be called by mighty creator or reward pool\r\n    /// @param gameEndTime Game end time\r\n    function setGameEndTime(uint256 gameEndTime) external;\r\n\r\n    /// @notice Sets game begin time\r\n    /// @dev Even though function is opened, it can only be called by mighty creator\r\n    /// @param gameBeginTime Game begin time\r\n    function setGameBeginTime(uint256 gameBeginTime) external;\r\n\r\n    /// @notice Destroys current era if conditions are met\r\n    /// @dev Anyone can call this function\r\n    function destroyCurrentEra() external;\r\n\r\n    /// @notice Returns region radius which is used to determine average region size\r\n    /// @dev Immutable\r\n    /// @return regionRadius Region radius\r\n    function getRegionRadius() external pure returns (uint64 regionRadius);\r\n\r\n    /// @notice Returns region seed which is used to determine region ids for positions\r\n    /// @dev Immutable\r\n    /// @return regionSeed Region seed\r\n    function getRegionSeed() external pure returns (bytes32 regionSeed);\r\n\r\n    /// @notice Returns tile bonuses seed\r\n    /// @dev Immutable\r\n    /// @return tileBonusesSeed Tile bonuses seed\r\n    function getTileBonusesSeed() external pure returns (bytes32 tileBonusesSeed);\r\n\r\n    /// @notice Returns region tier seed\r\n    /// @dev Updated when era is changed\r\n    /// @return regionTierSeed Region tier seed\r\n    function getRegionTierSeed() external view returns (bytes32 regionTierSeed);\r\n}\r\n"
    },
    "contracts/core/IWorldInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./IWorld.sol\";\r\n\r\n/// @title Interface of the contract which will be initialized with world\r\n/// @notice Contains access to world storage variable\r\ninterface IWorldInitializable {\r\n    // State variables\r\n\r\n    /// @notice World\r\n    /// @dev Should be immutable and initialized only once\r\n    function world() external view returns (IWorld);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called in active game (started and not finished)\r\n    error OnlyActiveGame();\r\n}\r\n"
    },
    "contracts/core/regionOwnershipToken/IRegionOwnershipToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\r\n\r\ninterface IRegionOwnershipToken is IERC721Enumerable {\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to call action which only possible to be called by geography\r\n    error OnlyGeography();\r\n\r\n    // Functions\r\n\r\n    /// @notice Updates base token uri\r\n    /// @dev Only owner can modify base token uri\r\n    /// @param _uri New base token uri\r\n    function updateURI(string memory _uri) external;\r\n\r\n    /// @notice Returns all token ids for specified holder address\r\n    /// @dev Used to query all token ids without asking them one by one (may not work for holder with very large amount of nfts)\r\n    /// @param holderAddress Holder address\r\n    /// @return tokenIds Token ids holder owns\r\n    function getTokenIdsByAddress(address holderAddress) external view returns (uint256[] memory tokenIds);\r\n\r\n    /// @notice Mints region ownership token\r\n    /// @dev Can only be called by geography contract\r\n    /// @param to Mint to address\r\n    /// @param regionId Region id\r\n    function mint(\r\n        address to,\r\n        uint256 regionId\r\n    ) external;\r\n}"
    },
    "contracts/core/regionOwnershipToken/RegionOwnershipToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../IWorld.sol\";\r\nimport \"./IRegionOwnershipToken.sol\";\r\n\r\ncontract RegionOwnershipToken is IRegionOwnershipToken, ERC721Enumerable, Ownable {\r\n    /// @notice World contract\r\n    /// @dev Immutable, initialized on creation\r\n    IWorld public world;\r\n\r\n    /// @notice Base URI for computing token uri\r\n    /// @dev Updated on creation or when #updateURI is called\r\n    string public baseURI;\r\n\r\n    modifier onlyGeography() {\r\n        if (msg.sender != address(world.geography())) revert OnlyGeography();\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        string memory uri_,\r\n        address worldAddress_\r\n    ) ERC721(name_, symbol_) {\r\n        world = IWorld(worldAddress_);\r\n        baseURI = uri_;\r\n    }\r\n\r\n    /// @dev Overridden value from ERC721\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return baseURI;\r\n    }\r\n\r\n    /// @inheritdoc IRegionOwnershipToken\r\n    function updateURI(string memory _uri) public onlyOwner {\r\n        baseURI = _uri;\r\n    }\r\n\r\n    /// @inheritdoc IRegionOwnershipToken\r\n    function getTokenIdsByAddress(address holderAddress) public view returns (uint256[] memory tokenIds) {\r\n        uint256 userBalance = balanceOf(holderAddress);\r\n        tokenIds = new uint256[](userBalance);\r\n\r\n        for (uint256 i = 0; i < userBalance; i++) {\r\n            tokenIds[i] = tokenOfOwnerByIndex(holderAddress, i);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IRegionOwnershipToken\r\n    function mint(\r\n        address to,\r\n        uint256 regionId\r\n    ) public onlyGeography {\r\n        _safeMint(to, regionId, \"\");\r\n    }\r\n}"
    },
    "contracts/core/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"./IRegistry.sol\";\r\nimport \"../const/GameAssetTypes.sol\";\r\n\r\ncontract Registry is IRegistry, Initializable {\r\n    /// @inheritdoc IRegistry\r\n    address public override mightyCreator;\r\n    /// @inheritdoc IRegistry\r\n    IWorldAssetFactory public override worldAssetFactory;\r\n    /// @inheritdoc IRegistry\r\n    uint256 public override globalMultiplier;\r\n    /// @inheritdoc IRegistry\r\n    uint256 public override settlementStartingPrice;\r\n\r\n    /// @dev Only mighty creator modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyMightyCreator() {\r\n        _onlyMightyCreator();\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function init(\r\n        uint256 _globalMultiplier,\r\n        uint256 _settlementStartingPrice\r\n    ) public override initializer {\r\n        mightyCreator = msg.sender;\r\n        globalMultiplier = _globalMultiplier;\r\n        settlementStartingPrice = _settlementStartingPrice;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function setMightyCreator(address newMightyCreator) public override onlyMightyCreator {\r\n        mightyCreator = newMightyCreator;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function setWorldAssetFactory(address worldAssetFactoryAddress) public override onlyMightyCreator {\r\n        worldAssetFactory = IWorldAssetFactory(worldAssetFactoryAddress);\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getGlobalMultiplier() public view override returns (uint256) {\r\n        return globalMultiplier;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getUnitStats(bytes32 unitTypeId) public pure returns (UnitStats memory) {\r\n        if (unitTypeId == WARRIOR_TYPE_ID) {\r\n            return UnitStats({\r\n                offenseStage1: 0,\r\n                defenceStage1: 20,\r\n                offenseStage2: 5,\r\n                defenceStage2: 5,\r\n                siegePower: 11574074074074,//uint256(1e18 / 1 days),\r\n                siegeSupport: 23148148148148//2 * siegePower\r\n            });\r\n        }\r\n\r\n        if (unitTypeId == ARCHER_TYPE_ID) {\r\n            return UnitStats({\r\n                offenseStage1: 5,\r\n                defenceStage1: 5,\r\n                offenseStage2: 0,\r\n                defenceStage2: 5,\r\n                siegePower: 11574074074074,//uint256(1e18 / 1 days),\r\n                siegeSupport: 23148148148148//2 * siegePower\r\n            });\r\n        }\r\n\r\n        if (unitTypeId == HORSEMAN_TYPE_ID) {\r\n            return UnitStats({\r\n                offenseStage1: 0,\r\n                defenceStage1: 5,\r\n                offenseStage2: 5,\r\n                defenceStage2: 20,\r\n                siegePower: 11574074074074,//uint256(1e18 / 1 days),\r\n                siegeSupport: 23148148148148//2 * siegePower\r\n            });\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getRobberyPointsPerDamageMultiplier() public pure override returns (uint256) {\r\n        return 5e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getRobberyPointsToResourceMultiplier(bytes32 resourceTypeId) public view override returns (uint256) {\r\n        if (resourceTypeId == FOOD_TYPE_ID) {\r\n            return 1e18;\r\n        }\r\n\r\n        if (resourceTypeId == WOOD_TYPE_ID) {\r\n            return 1e18;\r\n        }\r\n\r\n        if (resourceTypeId == ORE_TYPE_ID) {\r\n            return 1e18;\r\n        }\r\n\r\n        if (resourceTypeId == INGOT_TYPE_ID) {\r\n            return 1e18;\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getWorkerCapacityCoefficient(bytes32 buildingTypeId) public pure override returns (uint256) {\r\n        if (buildingTypeId == FARM_TYPE_ID) {\r\n            return 10e18;\r\n        }\r\n\r\n        if (buildingTypeId == LUMBERMILL_TYPE_ID) {\r\n            return 7e18;\r\n        }\r\n\r\n        if (buildingTypeId == MINE_TYPE_ID) {\r\n            return 5e18;\r\n        }\r\n\r\n        if (buildingTypeId == SMITHY_TYPE_ID) {\r\n            return 3e18;\r\n        }\r\n\r\n        if (buildingTypeId == FORT_TYPE_ID) {\r\n            return 5e18;\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getBasicProductionBuildingCoefficient(bytes32 buildingTypeId) public pure override returns (uint256) {\r\n        if (buildingTypeId == FARM_TYPE_ID) {\r\n            return 0.5e18;\r\n        }\r\n\r\n        if (buildingTypeId == LUMBERMILL_TYPE_ID) {\r\n            return 0.43e18;\r\n        }\r\n\r\n        if (buildingTypeId == MINE_TYPE_ID) {\r\n            return 0.4e18;\r\n        }\r\n\r\n        if (buildingTypeId == SMITHY_TYPE_ID) {\r\n            return 0.33e18;\r\n        }\r\n\r\n        if (buildingTypeId == FORT_TYPE_ID) {\r\n            return 0.4e18;\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getCorruptionIndexByResource(bytes32 resourceTypeId) public pure override returns (uint256) {\r\n        if (resourceTypeId == FOOD_TYPE_ID) {\r\n            return 0.3e18;\r\n        }\r\n\r\n        if (resourceTypeId == WOOD_TYPE_ID) {\r\n            return 1e18;\r\n        }\r\n\r\n        if (resourceTypeId == ORE_TYPE_ID) {\r\n            return 3e18;\r\n        }\r\n\r\n        if (resourceTypeId == INGOT_TYPE_ID) {\r\n            return 10e18;\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getResourceWeight(bytes32 resourceTypeId) public pure override returns (uint256) {\r\n        if (resourceTypeId == FOOD_TYPE_ID) {\r\n            return 0.5e18;\r\n        }\r\n\r\n        if (resourceTypeId == WOOD_TYPE_ID) {\r\n            return 1e18;\r\n        }\r\n\r\n        if (resourceTypeId == ORE_TYPE_ID) {\r\n            return 2e18;\r\n        }\r\n\r\n        if (resourceTypeId == INGOT_TYPE_ID) {\r\n            return 3e18;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getToTreasuryPercent() public pure override returns (uint256) {\r\n        return 1e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getBaseBattleDuration() public pure override returns (uint256) {\r\n        return 18 hours;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getBattleDurationLosingArmyStunMultiplier() public pure override returns (uint256) {\r\n        return 0.665e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getBattleDurationWinningArmyStunMultiplier() public pure override returns (uint256) {\r\n        return 0.335e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getManeuverDurationStunMultiplier() public pure override returns (uint256) {\r\n        return 0.6e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getBuildingTypeIds() public pure override returns (bytes32[] memory) {\r\n        bytes32[] memory buildingTypeIds = new bytes32[](5);\r\n\r\n        buildingTypeIds[0] = FARM_TYPE_ID;\r\n        buildingTypeIds[1] = LUMBERMILL_TYPE_ID;\r\n        buildingTypeIds[2] = MINE_TYPE_ID;\r\n        buildingTypeIds[3] = SMITHY_TYPE_ID;\r\n        buildingTypeIds[4] = FORT_TYPE_ID;\r\n\r\n        return buildingTypeIds;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getGameResources() public pure override returns (GameResource[] memory) {\r\n        GameResource[] memory resources = new GameResource[](4);\r\n\r\n        resources[0] = GameResource(\"Mithraeum Food\", \"mFOOD\", FOOD_TYPE_ID);\r\n        resources[1] = GameResource(\"Mithraeum Wood\", \"mWOOD\", WOOD_TYPE_ID);\r\n        resources[2] = GameResource(\"Mithraeum Ore\", \"mORE\", ORE_TYPE_ID);\r\n        resources[3] = GameResource(\"Mithraeum Ingot\", \"mINGOT\", INGOT_TYPE_ID);\r\n\r\n        return resources;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getGameUnits() public pure override returns (GameUnit[] memory) {\r\n        GameUnit[] memory gameUnits = new GameUnit[](3);\r\n\r\n        gameUnits[0] = GameUnit(\"Mithraeum Warrior\", \"mWARRIOR\", WARRIOR_TYPE_ID);\r\n        gameUnits[1] = GameUnit(\"Mithraeum Archer\", \"mARCHER\", ARCHER_TYPE_ID);\r\n        gameUnits[2] = GameUnit(\"Mithraeum Horseman\", \"mHORSEMAN\", HORSEMAN_TYPE_ID);\r\n\r\n        return gameUnits;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getUnitTypeIds() public pure override returns (bytes32[] memory) {\r\n        GameUnit[] memory gameUnits = getGameUnits();\r\n        bytes32[] memory unitTypeIds = new bytes32[](gameUnits.length);\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            unitTypeIds[i] = gameUnits[i].unitTypeId;\r\n        }\r\n\r\n        return unitTypeIds;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getUnitHiringFortHpMultiplier() public pure override returns (uint256) {\r\n        return 5e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getUnitResourceUsagePer1SecondOfDecreasedManeuverDuration(bytes32 unitTypeId) public pure override returns (uint256) {\r\n        if (unitTypeId == WARRIOR_TYPE_ID) {\r\n            // 1e18 / 5 hours = irrational const\r\n            return 0.000055555e18;\r\n        }\r\n\r\n        if (unitTypeId == ARCHER_TYPE_ID) {\r\n            // 1e18 / 20 hours = irrational const\r\n            return 0.000013888e18;\r\n        }\r\n\r\n        if (unitTypeId == HORSEMAN_TYPE_ID) {\r\n            // 1e18 / 50 hours = irrational const\r\n            return 0.000005555e18;\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getProsperityForUnitLiquidation(bytes32 unitTypeId) public pure override returns (uint256) {\r\n        if (unitTypeId == WARRIOR_TYPE_ID) {\r\n            return 0e18;\r\n        }\r\n\r\n        if (unitTypeId == ARCHER_TYPE_ID) {\r\n            return 3e18;\r\n        }\r\n\r\n        if (unitTypeId == HORSEMAN_TYPE_ID) {\r\n            return 4e18;\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getWorkersForUnitLiquidation(bytes32 unitTypeId) public pure override returns (uint256) {\r\n        if (unitTypeId == WARRIOR_TYPE_ID) {\r\n            return 1e18;\r\n        }\r\n\r\n        if (unitTypeId == ARCHER_TYPE_ID) {\r\n            return 0e18;\r\n        }\r\n\r\n        if (unitTypeId == HORSEMAN_TYPE_ID) {\r\n            return 0e18;\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getCultistsSummonDelay() public pure override returns (uint256) {\r\n        return 2 weeks;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMaxSettlementsPerRegion() public pure override returns (uint256) {\r\n        return 40;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getCultistsNoDestructionDelay() public pure override returns (uint256) {\r\n        return 10 days;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getCultistsPerRegionMultiplier() public pure override returns (uint256) {\r\n        return 5000e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMaxCultistsPerRegion() public pure override returns (uint256) {\r\n        return 10000e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getCultistUnitTypeId() public pure override returns (bytes32) {\r\n        return WARRIOR_TYPE_ID;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getBuildingTokenTransferThresholdPercent() public pure override returns (uint256) {\r\n        return 0.3e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getNewSettlementStartingPrice() public view override returns (uint256) {\r\n        return settlementStartingPrice;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getProductionTicksInSecond() public view override returns (uint256) {\r\n        return getMaxCultistsPerRegion() / 1e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getUnitPriceIncreaseForEachUnit() public pure override returns (uint256, uint256) {\r\n        return (1004, 1000);\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMaxAllowedUnitsToBuyPerTransaction() public pure override returns (uint256) {\r\n        return 5000e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getUnitPriceDropByUnitTypeId(bytes32 unitTypeId) public pure override returns (uint256, uint256) {\r\n        if (unitTypeId == ARCHER_TYPE_ID) {\r\n            //10% drop in 1 day (90% leftover)\r\n            return (9999987805503308, 10000000000000000);\r\n        }\r\n\r\n        if (unitTypeId == HORSEMAN_TYPE_ID) {\r\n            //7% drop in 1 day (93% leftover)\r\n            return (9999991600617782, 10000000000000000);\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getWorkerPriceIncreaseForEachWorker() public pure override returns (uint256, uint256) {\r\n        return (1004, 1000);\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMaxAllowedWorkersToBuyPerTransaction() public pure override returns (uint256) {\r\n        return 5000e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getWorkerPriceDrop() public pure override returns (uint256, uint256) {\r\n        //7% drop in 1 day (93% leftover)\r\n        return (9999991600617782, 10000000000000000);\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMaxAdvancedProductionTileBuff() public pure override returns (uint256) {\r\n        return 1e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getCaptureTileDurationPerTile() public pure override returns (uint256) {\r\n        return 9 hours;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getNextCaptureProsperityBasicThreshold() public pure override returns (uint256) {\r\n        return 1.2e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getNextCaptureProsperityPerTileThreshold() public pure override returns (uint256) {\r\n        return 0.05e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getNecessaryProsperityPercentForClaimingTileCapture() public pure override returns (uint256) {\r\n        return 0.7e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getTileCaptureCancellationFee() public pure override returns (uint256) {\r\n        return 0.25e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMaxCapturedTilesForSettlement(uint8 tileBonusType) public pure override returns (uint256) {\r\n        if (tileBonusType == 1) {\r\n            return 2;\r\n        }\r\n\r\n        if (tileBonusType == 2) {\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getAdvancedProductionTileBonusByVariation(uint8 variation) public pure override returns (bytes32, uint256) {\r\n        if (variation == 0) {\r\n            return (FARM_TYPE_ID, 0.25e18);\r\n        }\r\n\r\n        if (variation == 1) {\r\n            return (FARM_TYPE_ID, 0.4e18);\r\n        }\r\n\r\n        if (variation == 2) {\r\n            return (LUMBERMILL_TYPE_ID, 0.3e18);\r\n        }\r\n\r\n        if (variation == 3) {\r\n            return (LUMBERMILL_TYPE_ID, 0.6e18);\r\n        }\r\n\r\n        if (variation == 4) {\r\n            return (MINE_TYPE_ID, 0.5e18);\r\n        }\r\n\r\n        if (variation == 5) {\r\n            return (MINE_TYPE_ID, 0.8e18);\r\n        }\r\n\r\n        if (variation == 6) {\r\n            return (SMITHY_TYPE_ID, 0.7e18);\r\n        }\r\n\r\n        if (variation == 7) {\r\n            return (SMITHY_TYPE_ID, 1e18);\r\n        }\r\n\r\n        if (variation == 8) {\r\n            return (FORT_TYPE_ID, 0.4e18);\r\n        }\r\n\r\n        if (variation == 9) {\r\n            return (FORT_TYPE_ID, 0.6e18);\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getUnitBattleMultiplierTileBonusByVariation(uint8 variation) public pure override returns (bytes32, uint256) {\r\n        if (variation == 0) {\r\n            return (WARRIOR_TYPE_ID, 0.3e18);\r\n        }\r\n\r\n        if (variation == 1) {\r\n            return (ARCHER_TYPE_ID, 0.5e18);\r\n        }\r\n\r\n        if (variation == 2) {\r\n            return (HORSEMAN_TYPE_ID, 1e18);\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMaxRegionTier() public pure override returns (uint256) {\r\n        return 4;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getInitialCultistsAmountPerRegionTier() public pure override returns (uint256) {\r\n        return 1500e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getInitialCorruptionIndexAmountPerRegionTier() public pure override returns (uint256) {\r\n        return getInitialCultistsAmountPerRegionTier() * 5;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getSettlementPriceMultiplierPerIncreasedRegionTier() public pure override returns (uint256) {\r\n        return 2;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getStunDurationMultiplierOfCancelledSecretManeuver() public pure override returns (uint256) {\r\n        return 0.5e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMaxAllowedRobberyMultiplierIncreaseValue() public pure override returns (uint256) {\r\n        return 3e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getArmyStunDurationPerRobberyMultiplier() public pure override returns (uint256) {\r\n        return 1 days;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getChanceForTileWithBonusByRegionTier(uint256 regionTier) public pure override returns (uint256) {\r\n        if (regionTier == 1) {\r\n            return 0.04e18;\r\n        }\r\n\r\n        if (regionTier == 2) {\r\n            return 0.08e18;\r\n        }\r\n\r\n        if (regionTier == 3) {\r\n            return 0.12e18;\r\n        }\r\n\r\n        if (regionTier == 4) {\r\n            return 0.15e18;\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getRegionInclusionPrice(uint256 regionTier) public pure override returns (uint256) {\r\n        if (regionTier == 1) {\r\n            return 40000e18;\r\n        }\r\n\r\n        if (regionTier == 2) {\r\n            return 80000e18;\r\n        }\r\n\r\n        if (regionTier == 3) {\r\n            return 160000e18;\r\n        }\r\n\r\n        if (regionTier == 4) {\r\n            return 320000e18;\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getRegionOwnerSettlementPurchasePercent(uint256 regionTier) public pure override returns (uint256) {\r\n        if (regionTier == 1) {\r\n            return 0.4e18;\r\n        }\r\n\r\n        if (regionTier == 2) {\r\n            return 0.2e18;\r\n        }\r\n\r\n        if (regionTier == 3) {\r\n            return 0.1e18;\r\n        }\r\n\r\n        if (regionTier == 4) {\r\n            return 0;\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getUnitPoolType(bytes32 unitTypeId) public pure override returns (bytes32) {\r\n        if (unitTypeId == WARRIOR_TYPE_ID) {\r\n            return WORKERS_UNIT_POOL_TYPE_ID;\r\n        }\r\n\r\n        if (unitTypeId == ARCHER_TYPE_ID) {\r\n            return INGOTS_UNIT_POOL_TYPE_ID;\r\n        }\r\n\r\n        if (unitTypeId == HORSEMAN_TYPE_ID) {\r\n            return INGOTS_UNIT_POOL_TYPE_ID;\r\n        }\r\n\r\n        revert UnknownInputParameter();\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getArmyStunDurationByJoiningBattleAtAttackingSide() public pure override returns (uint256) {\r\n        return 12 hours;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getInitialCaptureProsperityBasicValue() public pure override returns (uint256) {\r\n        return 1e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getInitialCaptureProsperityPerTileValue() public pure override returns (uint256) {\r\n        return 0.25e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMinimumUserSettlementsCountInNeighboringRegionRequiredToIncludeRegion() public pure override returns (uint256) {\r\n        return 20;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getSettlementPayToDecreaseCorruptionIndexPenaltyMultiplier() public pure override returns (uint256) {\r\n        return 0.5e18;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getMinimumBattleDuration() public pure override returns (uint256) {\r\n        return 10;\r\n    }\r\n\r\n    /// @inheritdoc IRegistry\r\n    function getNewSettlementPriceIncreaseMultiplier() public pure override returns (uint256) {\r\n        return 1.3e18;\r\n    }\r\n\r\n    /// @dev Allows caller to be only mighty creator\r\n    function _onlyMightyCreator() internal view {\r\n        if (msg.sender != mightyCreator) revert OnlyMightyCreator();\r\n    }\r\n}\r\n"
    },
    "contracts/core/rewardPool/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\ninterface IRewardPool {\r\n    // State variables\r\n\r\n    /// @notice Represents how much of ingots must be given for one unit of token by default (in 64.64 format)\r\n    /// @dev Updated when #handleEraDestroyed is called\r\n    function defaultTokenPrice() external view returns (int128);\r\n\r\n    /// @notice Represents how much bless tokens must be repaid first to the mighty creator\r\n    /// @dev Updated when #investIntoPrizePool is called\r\n    function toBeRepaidTokenAmount() external view returns (uint256);\r\n\r\n    /// @notice Represents last synced reward pool total balance after repayment and function(s) are done\r\n    /// @dev Updated when #investIntoPrizePool or #swapIngotsForTokens or #withdrawRepayment are called\r\n    function lastSyncedTokenBalance() external view returns (uint256);\r\n\r\n    // Events\r\n\r\n    /// @notice Emitted when 'lastSyncedTokenBalance' updated\r\n    /// @param newLastSyncedTokenBalance New last synced token balance\r\n    event LastSyncedTokenBalanceUpdated(uint256 newLastSyncedTokenBalance);\r\n\r\n    /// @notice Emitted when 'toBeRepaidTokenAmount' updated\r\n    /// @param newToBeRepaidTokenAmount New to be repaid token amount\r\n    event ToBeRepaidTokenAmountUpdated(uint256 newToBeRepaidTokenAmount);\r\n\r\n    /// @notice Emitted when eth balance updated\r\n    /// @param newEthBalance New eth balance\r\n    event EthBalanceUpdated(uint256 newEthBalance);\r\n\r\n    // Errors\r\n\r\n    /// @notice Thrown when attempting to receive ether while having non native token reward\r\n    error UnableToReceiveEther();\r\n\r\n    /// @notice Thrown when attempting to swap ingots for tokens but specified ingots amount are not enough even for one unit of token\r\n    error NoTokensWillBeReceived();\r\n\r\n    /// @notice Thrown when attempting to swap ingots for tokens but amount of tokens to be received less than specified minimum amount\r\n    error TokensToBeReceivedLessThanMinimumRequired();\r\n\r\n    /// @notice Thrown when attempting to swap ingots for tokens but not enough tokens left for specified ingots amount\r\n    error NotEnoughTokensLeft();\r\n\r\n    // Functions\r\n\r\n    /// @notice Proxy initializer\r\n    /// @dev Called by address which created current instance\r\n    /// @param worldAddress World address\r\n    function init(address worldAddress) external;\r\n\r\n    /// @notice Swap provided amount of ingots\r\n    /// @dev If resourcesOwner == address(0) -> resources will be taken from msg.sender\r\n    /// @dev If resourcesOwner != address(0) and resourcesOwner has given allowance to msg.sender >= ingotsAmount -> resources will be taken from resourcesOwner\r\n    /// @param resourcesOwner Resources owner\r\n    /// @param ingotsAmount Amount of ingots to swap\r\n    /// @param minTokensToReceive Minimum amount of tokens to receive\r\n    function swapIngotsForTokens(\r\n        address resourcesOwner,\r\n        uint256 ingotsAmount,\r\n        uint256 minTokensToReceive\r\n    ) external;\r\n\r\n    /// @notice Invests specified amount of tokens into prize pool\r\n    /// @dev Bless tokens must be sent to this function (if its type=eth) or will be deducted from msg.sender (if its type=erc20)\r\n    /// @param amountToInvest Amount of tokens to invest\r\n    function investIntoPrizePool(uint256 amountToInvest) external payable;\r\n\r\n    /// @notice Withdraws potential bless token added balance to the mighty creator\r\n    /// @dev Triggers withdraw of potential added balance\r\n    function withdrawRepayment() external;\r\n\r\n    /// @notice Calculates amount of tokens to be received by provided ingots amount\r\n    /// @dev Used to determine how much tokens will be received by provided ingots amount\r\n    /// @param ingotsAmountIn Ingots amount in\r\n    /// @return tokensAmountOut Tokens amount out\r\n    function getTokensAmountOut(uint256 ingotsAmountIn) external view returns (uint256 tokensAmountOut);\r\n\r\n    /// Calculates minimum amount of ingots required for specified amount of tokens to receive\r\n    /// @dev Used to determine how much tokens will be received by provided ingots amount\r\n    /// @param tokensAmountOut Tokens amount out\r\n    /// @return ingotsAmountIn Ingots amount in\r\n    function getIngotsAmountIn(uint256 tokensAmountOut) external view returns (uint256 ingotsAmountIn);\r\n\r\n    /// @notice Calculates current price of token in ingots\r\n    /// @return price Price\r\n    function getCurrentPrice() external view returns (uint256 price);\r\n}\r\n"
    },
    "contracts/core/rewardPool/RewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"./IRewardPool.sol\";\r\nimport \"../WorldInitializable.sol\";\r\nimport \"../../periphery/ProxyReentrancyGuard.sol\";\r\nimport \"../../libraries/ABDKMath64x64.sol\";\r\nimport \"../../const/GameAssetTypes.sol\";\r\n\r\ncontract RewardPool is IRewardPool, WorldInitializable, ProxyReentrancyGuard {\r\n    /// @inheritdoc IRewardPool\r\n    int128 public override defaultTokenPrice;\r\n    /// @inheritdoc IRewardPool\r\n    uint256 public override toBeRepaidTokenAmount;\r\n    /// @inheritdoc IRewardPool\r\n    uint256 public override lastSyncedTokenBalance;\r\n\r\n    /// @dev Repays newly added balance to mighty creator\r\n    modifier syncBalances(uint256 msgValue) {\r\n        uint256 rewardPoolBalanceBefore = _getRewardPoolBalance() - msgValue;\r\n        uint256 addedBalance = rewardPoolBalanceBefore - lastSyncedTokenBalance;\r\n        if (addedBalance > 0) {\r\n            uint256 toRepay = Math.min(toBeRepaidTokenAmount, addedBalance);\r\n\r\n            if (toRepay > 0) {\r\n                _sendTokens(world.registry().mightyCreator(), toRepay);\r\n                toBeRepaidTokenAmount -= toRepay;\r\n                emit ToBeRepaidTokenAmountUpdated(toBeRepaidTokenAmount);\r\n            }\r\n        }\r\n        _;\r\n        lastSyncedTokenBalance = _getRewardPoolBalance();\r\n        emit LastSyncedTokenBalanceUpdated(lastSyncedTokenBalance);\r\n    }\r\n\r\n    receive() external payable {\r\n        if (address(world.erc20ForSettlementPurchase()) != address(0)) revert UnableToReceiveEther();\r\n        emit EthBalanceUpdated(address(this).balance);\r\n    }\r\n\r\n    /// @inheritdoc IRewardPool\r\n    function init(address worldAddress) public override initializer {\r\n        setWorld(worldAddress);\r\n        defaultTokenPrice = ABDKMath64x64.fromUInt(1);\r\n    }\r\n\r\n    /// @inheritdoc IRewardPool\r\n    function investIntoPrizePool(uint256 amountToInvest) public payable syncBalances(msg.value) {\r\n        IERC20 erc20ForSettlementPurchase = world.erc20ForSettlementPurchase();\r\n        if (address(erc20ForSettlementPurchase) != address(0) && msg.value != 0) revert UnableToReceiveEther();\r\n\r\n        if (address(erc20ForSettlementPurchase) == address(0)) {\r\n            toBeRepaidTokenAmount += msg.value;\r\n        } else {\r\n            SafeERC20.safeTransferFrom(\r\n                erc20ForSettlementPurchase,\r\n                msg.sender,\r\n                address(this),\r\n                amountToInvest\r\n            );\r\n            toBeRepaidTokenAmount += amountToInvest;\r\n        }\r\n\r\n        emit ToBeRepaidTokenAmountUpdated(toBeRepaidTokenAmount);\r\n    }\r\n\r\n    /// @inheritdoc IRewardPool\r\n    function swapIngotsForTokens(\r\n        address resourcesOwner,\r\n        uint256 ingotsAmount,\r\n        uint256 minTokensToReceive\r\n    ) public override nonReentrant syncBalances(0) {\r\n        uint256 tokenPrecision = _getTokenPrecision();\r\n        uint256 currentPrice = getCurrentPrice();\r\n        uint256 rewardPoolBalance = _getRewardPoolBalance();\r\n\r\n        uint256 tokensToBeReceived = _getTokensAmountOut(ingotsAmount, tokenPrecision, currentPrice);\r\n\r\n        // In case if amount of tokens to be received (66.6) > current reward pool balance (62)\r\n        // And current reward pool balance (62) > minimum desired amount of tokens to receive (60)\r\n        // We need to make user drain everything of whats left in the pool\r\n        if (tokensToBeReceived > rewardPoolBalance && rewardPoolBalance > minTokensToReceive) {\r\n            tokensToBeReceived = rewardPoolBalance;\r\n        }\r\n\r\n        if (tokensToBeReceived == 0) revert NoTokensWillBeReceived();\r\n        if (tokensToBeReceived < minTokensToReceive) revert TokensToBeReceivedLessThanMinimumRequired();\r\n        if (minTokensToReceive > rewardPoolBalance || rewardPoolBalance == 0) revert NotEnoughTokensLeft();\r\n\r\n        uint256 minimumAmountOfIngotsRequiredForSpecificTokensToBeReceived = _getIngotsAmountIn(tokensToBeReceived, tokenPrecision, currentPrice);\r\n\r\n        IResource ingots = world.eras(world.currentEraNumber()).resources(INGOT_TYPE_ID);\r\n\r\n        if (resourcesOwner == address(0)) {\r\n            ingots.transferFrom(msg.sender, address(this), minimumAmountOfIngotsRequiredForSpecificTokensToBeReceived);\r\n        } else {\r\n            ingots.spendAllowance(resourcesOwner, msg.sender, minimumAmountOfIngotsRequiredForSpecificTokensToBeReceived);\r\n            ingots.transferFrom(resourcesOwner, address(this), minimumAmountOfIngotsRequiredForSpecificTokensToBeReceived);\r\n        }\r\n\r\n        _sendTokens(msg.sender, tokensToBeReceived);\r\n\r\n        if (_getRewardPoolBalance() == 0 && world.gameEndTime() == 0) {\r\n            world.setGameEndTime(block.timestamp);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IRewardPool\r\n    function withdrawRepayment() public syncBalances(0) {}\r\n\r\n    /// @inheritdoc IRewardPool\r\n    function getTokensAmountOut(uint256 ingotsAmountIn) public view override returns (uint256) {\r\n        return _getTokensAmountOut(ingotsAmountIn, _getTokenPrecision(), getCurrentPrice());\r\n    }\r\n\r\n    /// @inheritdoc IRewardPool\r\n    function getIngotsAmountIn(uint256 tokensAmountOut) public view override returns (uint256) {\r\n        return _getIngotsAmountIn(tokensAmountOut, _getTokenPrecision(), getCurrentPrice());\r\n    }\r\n\r\n    /// @inheritdoc IRewardPool\r\n    function getCurrentPrice() public view override returns (uint256) {\r\n        uint256 currentEraNumber = world.currentEraNumber();\r\n        IEra currentEra = world.eras(currentEraNumber);\r\n        address ingotsAddress = address(currentEra.resources(INGOT_TYPE_ID));\r\n\r\n        uint256 ingotPrecision = 10 ** IERC20Metadata(ingotsAddress).decimals();\r\n\r\n        int128 currentPrice64 = _getCurrentPrice64(currentEraNumber, currentEra.creationTime(), world.gameBeginTime());\r\n        return ABDKMath64x64.mulu(currentPrice64, ingotPrecision);\r\n    }\r\n\r\n    /// @dev Calculates tokens amount out based on specified parameters\r\n    function _getTokensAmountOut(\r\n        uint256 ingotsAmountIn,\r\n        uint256 tokenPrecision,\r\n        uint256 price\r\n    ) internal pure returns (uint256) {\r\n        return ingotsAmountIn * tokenPrecision / price;\r\n    }\r\n\r\n    /// @dev Calculates tokens amount out based on specified parameters\r\n    function _getIngotsAmountIn(\r\n        uint256 tokensAmountOut,\r\n        uint256 tokenPrecision,\r\n        uint256 price\r\n    ) internal pure returns (uint256) {\r\n        uint256 numerator = price * tokensAmountOut;\r\n\r\n        if (numerator % tokenPrecision != 0) {\r\n            return numerator / tokenPrecision + 1;\r\n        } else {\r\n            return numerator / tokenPrecision;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns token precision\r\n    function _getTokenPrecision() internal view returns (uint256) {\r\n        address tokenAddress = address(world.erc20ForSettlementPurchase());\r\n\r\n        return tokenAddress == address(0)\r\n            ? 1e18\r\n            : 10 ** IERC20Metadata(tokenAddress).decimals();\r\n    }\r\n\r\n    /// @dev Calculates current token price based on current era and time passed since current era created (in 64.64 format)\r\n    function _getCurrentPrice64(\r\n        uint256 currentEraNumber,\r\n        uint256 currentEraCreationTime,\r\n        uint256 gameBeginTime\r\n    ) internal view returns (int128) {\r\n        int128 currentEraMultiplier64 = ABDKMath64x64.pow(\r\n            ABDKMath64x64.fromUInt(2),\r\n            currentEraNumber\r\n        );\r\n\r\n        int128 currentEraStartingPrice64 = ABDKMath64x64.div(defaultTokenPrice, currentEraMultiplier64);\r\n\r\n        uint256 currentEraStartTime = Math.max(currentEraCreationTime, gameBeginTime);\r\n\r\n        if (currentEraStartTime >= block.timestamp) {\r\n            return currentEraStartingPrice64;\r\n        }\r\n\r\n        uint256 timePassedSinceEraStarted = block.timestamp - currentEraStartTime;\r\n\r\n        // 50% every two weeks -> 1.5 increase every 1209600 seconds -> 1.0000003352059987312573101913599 increase every second\r\n        int128 priceMultiplierPerSecond64 = ABDKMath64x64.divu(10000003352059987, 10000000000000000);\r\n        int128 priceMultiplierForTimePassed64 = ABDKMath64x64.pow(priceMultiplierPerSecond64, timePassedSinceEraStarted);\r\n\r\n        return ABDKMath64x64.mul(currentEraStartingPrice64, priceMultiplierForTimePassed64);\r\n    }\r\n\r\n    /// @dev Reads current balance\r\n    function _getRewardPoolBalance() internal view returns (uint256) {\r\n        IERC20 erc20ForSettlementPurchase = world.erc20ForSettlementPurchase();\r\n        return address(erc20ForSettlementPurchase) == address(0)\r\n            ? address(this).balance\r\n            : erc20ForSettlementPurchase.balanceOf(address(this));\r\n    }\r\n\r\n    /// @dev Sends bless tokens from this contract to specified address (either eth or erc20)\r\n    function _sendTokens(address to, uint256 amount) internal {\r\n        IERC20 erc20ForSettlementPurchase = world.erc20ForSettlementPurchase();\r\n        if (address(erc20ForSettlementPurchase) == address(0)) {\r\n            Address.sendValue(payable(to), amount);\r\n            emit EthBalanceUpdated(address(this).balance);\r\n        } else {\r\n            SafeERC20.safeTransfer(\r\n                erc20ForSettlementPurchase,\r\n                to,\r\n                amount\r\n            );\r\n        }\r\n    }\r\n}"
    },
    "contracts/core/World.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"./IRegistry.sol\";\r\nimport \"./IWorld.sol\";\r\nimport \"./assets/building/IBuilding.sol\";\r\nimport \"./crossErasMemory/ICrossErasMemory.sol\";\r\nimport \"../const/GameAssetTypes.sol\";\r\n\r\ncontract World is IWorld, Initializable {\r\n    /// @inheritdoc IWorld\r\n    IRegistry public override registry;\r\n    /// @inheritdoc IWorld\r\n    IGeography public override geography;\r\n    /// @inheritdoc IWorld\r\n    IERC721 public override bannerContract;\r\n    /// @inheritdoc IWorld\r\n    IERC20 public override erc20ForSettlementPurchase;\r\n    /// @inheritdoc IWorld\r\n    IERC20 public override erc20ForRegionInclusion;\r\n    /// @inheritdoc IWorld\r\n    IRegionOwnershipToken public override regionOwnershipToken;\r\n    /// @inheritdoc IWorld\r\n    IDistributions public override distributions;\r\n    /// @inheritdoc IWorld\r\n    ICrossErasMemory public override crossErasMemory;\r\n    /// @inheritdoc IWorld\r\n    IRewardPool public override rewardPool;\r\n\r\n    /// @inheritdoc IWorld\r\n    uint256 public override gameBeginTime;\r\n    /// @inheritdoc IWorld\r\n    uint256 public override gameEndTime;\r\n\r\n    /// @inheritdoc IWorld\r\n    uint256 public override currentEraNumber;\r\n    /// @inheritdoc IWorld\r\n    mapping(uint256 => IEra) public override eras;\r\n\r\n    /// @inheritdoc IWorld\r\n    mapping(bytes28 => address) public override implementations;\r\n    /// @inheritdoc IWorld\r\n    mapping(uint256 => mapping(address => bytes32)) public override worldAssets;\r\n\r\n    /// @dev Only active game modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyActiveGame() {\r\n        _onlyActiveGame();\r\n        _;\r\n    }\r\n\r\n    /// @dev Only mighty creator or reward pool modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyMightyCreatorOrRewardPool() {\r\n        _onlyMightyCreatorOrRewardPool();\r\n        _;\r\n    }\r\n\r\n    /// @dev Only mighty creator modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyMightyCreator() {\r\n        _onlyMightyCreator();\r\n        _;\r\n    }\r\n\r\n    /// @dev Only factory modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyFactory() {\r\n        _onlyFactory();\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function init(\r\n        bytes calldata packedAddresses,\r\n        bytes28[] calldata assetIds,\r\n        address[] calldata implementationAddresses\r\n    ) public override initializer {\r\n        (\r\n            address registryContractAddress,\r\n            address crossErasMemoryAddress,\r\n            address geographyAddress,\r\n            address bannersAddress,\r\n            address erc20ForSettlementPurchaseAddress,\r\n            address erc20ForRegionInclusionAddress,\r\n            address regionOwnershipTokenAddress,\r\n            address distributionsAddress,\r\n            address rewardPoolAddress\r\n        ) = abi.decode(\r\n            packedAddresses,\r\n            (address, address, address, address, address, address, address, address, address)\r\n        );\r\n\r\n        registry = IRegistry(registryContractAddress);\r\n        crossErasMemory = ICrossErasMemory(crossErasMemoryAddress);\r\n        geography = IGeography(geographyAddress);\r\n        bannerContract = IERC721(bannersAddress);\r\n        erc20ForSettlementPurchase = IERC20(erc20ForSettlementPurchaseAddress);\r\n        erc20ForRegionInclusion = IERC20(erc20ForRegionInclusionAddress);\r\n        regionOwnershipToken = IRegionOwnershipToken(regionOwnershipTokenAddress);\r\n        distributions = IDistributions(distributionsAddress);\r\n        rewardPool = IRewardPool(rewardPoolAddress);\r\n\r\n        setImplementations(assetIds, implementationAddresses);\r\n\r\n        emit WorldInitialized(\r\n            registryContractAddress,\r\n            crossErasMemoryAddress,\r\n            geographyAddress,\r\n            bannersAddress,\r\n            erc20ForSettlementPurchaseAddress,\r\n            erc20ForRegionInclusionAddress,\r\n            regionOwnershipTokenAddress,\r\n            distributionsAddress,\r\n            rewardPoolAddress\r\n        );\r\n\r\n        _createAndAssignEra(currentEraNumber);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function addWorldAsset(\r\n        uint256 eraNumber,\r\n        address worldAsset,\r\n        bytes32 assetType\r\n    ) public override onlyFactory {\r\n        worldAssets[eraNumber][worldAsset] = assetType;\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function setImplementations(\r\n        bytes28[] calldata assetIds,\r\n        address[] calldata implementationAddresses\r\n    ) public override onlyMightyCreator {\r\n        for (uint256 i = 0; i < assetIds.length; i++) {\r\n            implementations[assetIds[i]] = implementationAddresses[i];\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function setGameBeginTime(uint256 value) public override onlyMightyCreator {\r\n        gameBeginTime = value;\r\n        emit GameBeginTimeUpdated(value);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function setGameEndTime(uint256 value) public override onlyMightyCreatorOrRewardPool {\r\n        gameEndTime = value;\r\n        emit GameEndTimeUpdated(value);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function mintWorkers(\r\n        uint256 eraNumber,\r\n        address _to,\r\n        uint256 _value\r\n    ) public override onlyMightyCreator {\r\n        eras[eraNumber].workers().mint(_to, _value);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function mintUnits(\r\n        uint256 eraNumber,\r\n        bytes32 unitTypeId,\r\n        address to,\r\n        uint256 value\r\n    ) public override onlyMightyCreator {\r\n        eras[eraNumber].units(unitTypeId).mint(to, value);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function mintResources(\r\n        uint256 eraNumber,\r\n        bytes32 resourceTypeId,\r\n        address to,\r\n        uint256 value\r\n    ) public override onlyMightyCreator {\r\n        eras[eraNumber].resources(resourceTypeId).mint(to, value);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function destroyCurrentEra() public override onlyActiveGame {\r\n        IEra currentEra = eras[currentEraNumber];\r\n\r\n        uint256 _globalMultiplier = registry.getGlobalMultiplier();\r\n        uint256 _summonDelay = registry.getCultistsSummonDelay() / _globalMultiplier;\r\n        uint256 _noDestructionDelay = registry.getCultistsNoDestructionDelay() / _globalMultiplier;\r\n\r\n        uint256 _epochCreationTime = Math.max(currentEra.creationTime(), gameBeginTime);\r\n        if (block.timestamp <= _epochCreationTime) revert CurrentEraCannotBeDestroyedDueToCultistsNoDestructionDelayNotPassed();\r\n\r\n        uint256 _timePassedSinceEpochCreationTime = block.timestamp - _epochCreationTime;\r\n        uint256 _timeInsideCurrentSummonInterval = _timePassedSinceEpochCreationTime % _summonDelay;\r\n        if (_timeInsideCurrentSummonInterval <= _noDestructionDelay) revert CurrentEraCannotBeDestroyedDueToCultistsNoDestructionDelayNotPassed();\r\n\r\n        uint256 maxAllowedCultists = geography.getRegionsCount() * registry.getCultistsPerRegionMultiplier();\r\n        if (currentEra.totalCultists() <= maxAllowedCultists) revert CurrentEraCannotBeDestroyedDueCultistsLimitNotReached();\r\n\r\n        uint256 newEraNumber = currentEraNumber + 1;\r\n        _createAndAssignEra(newEraNumber);\r\n    }\r\n\r\n    /// TODO FOR TESTS REMOVE AFTER\r\n    function destroyCurrentEraWithoutCondition() public onlyActiveGame {\r\n        _createAndAssignEra(currentEraNumber + 1);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function getRegionRadius() public pure override returns (uint64) {\r\n        return 15;\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function getRegionSeed() public pure override returns (bytes32) {\r\n        return bytes32(0);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function getTileBonusesSeed() public pure override returns (bytes32) {\r\n        return bytes32(0);\r\n    }\r\n\r\n    /// @inheritdoc IWorld\r\n    function getRegionTierSeed() public view override returns (bytes32) {\r\n        return keccak256(abi.encodePacked(address(this), currentEraNumber));\r\n    }\r\n\r\n    /// @dev Allows function to be callable only while game is active (block.timestamp in [beginTime, endTime) or [beginTime, inf)\r\n    function _onlyActiveGame() internal view {\r\n        uint256 _gameBeginTime = gameBeginTime;\r\n        uint256 _gameEndTime = gameEndTime;\r\n        if (_gameBeginTime == 0 || block.timestamp < _gameBeginTime) revert OnlyActiveGame();\r\n        if (_gameEndTime != 0 && block.timestamp >= _gameEndTime) revert OnlyActiveGame();\r\n    }\r\n\r\n    /// @dev Allows caller to be only mighty creator or reward pool\r\n    function _onlyMightyCreatorOrRewardPool() internal view {\r\n        if (msg.sender != registry.mightyCreator() && msg.sender != address(rewardPool)) revert OnlyMightyCreatorOrRewardPool();\r\n    }\r\n\r\n    /// @dev Allows caller to be only mighty creator\r\n    function _onlyMightyCreator() internal view {\r\n        if (msg.sender != registry.mightyCreator()) revert OnlyMightyCreator();\r\n    }\r\n\r\n    /// @dev Allows caller to be only factory contract\r\n    function _onlyFactory() internal view {\r\n        if (msg.sender != address(registry.worldAssetFactory())) revert OnlyFactory();\r\n    }\r\n\r\n    /// @dev Creates era\r\n    function _createEra(uint256 eraNumber) internal returns (IEra) {\r\n        return IEra(\r\n            registry.worldAssetFactory().create(\r\n                address(this),\r\n                eraNumber,\r\n                ERA_GROUP_TYPE_ID,\r\n                BASIC_TYPE_ID,\r\n                abi.encode(eraNumber)\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @dev Create and assign era\r\n    function _createAndAssignEra(uint256 eraNumber) internal {\r\n        IEra newEra = _createEra(eraNumber);\r\n\r\n        eras[eraNumber] = newEra;\r\n        emit EraCreated(address(newEra), eraNumber);\r\n\r\n        _setCurrentEraNumber(eraNumber);\r\n    }\r\n\r\n    /// @dev Sets current era number\r\n    function _setCurrentEraNumber(uint256 newEraNumber) internal {\r\n        currentEraNumber = newEraNumber;\r\n        emit CurrentEraNumberUpdated(newEraNumber);\r\n    }\r\n}\r\n"
    },
    "contracts/core/WorldInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"./IWorldInitializable.sol\";\r\n\r\n/// @title Abstract World initializable contract\r\n/// @notice Any contract which should be initialized with world should inherit this contract\r\nabstract contract WorldInitializable is IWorldInitializable, Initializable {\r\n    /// @inheritdoc IWorldInitializable\r\n    IWorld public override world;\r\n\r\n    /// @dev Only active game modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyActiveGame() {\r\n        _onlyActiveGame();\r\n        _;\r\n    }\r\n\r\n    /// @dev Initializes world by specified address, can be called only once\r\n    function setWorld(address worldAddress) internal onlyInitializing {\r\n        world = IWorld(worldAddress);\r\n    }\r\n\r\n    /// @dev Extracts registry from the world\r\n    function registry() internal view returns (IRegistry) {\r\n        return world.registry();\r\n    }\r\n\r\n    /// @dev Allows function to be callable only while game is active\r\n    function _onlyActiveGame() internal view {\r\n        uint256 _gameBeginTime = world.gameBeginTime();\r\n        uint256 _gameEndTime = world.gameEndTime();\r\n        if (_gameBeginTime == 0 || block.timestamp < _gameBeginTime) revert OnlyActiveGame();\r\n        if (_gameEndTime != 0 && block.timestamp >= _gameEndTime) revert OnlyActiveGame();\r\n    }\r\n}\r\n"
    },
    "contracts/external/SettlementsListings.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nimport \"../core/IWorld.sol\";\r\n\r\n/// @title Settlements listings\r\n/// @notice Functions related to selling settlements for specific amount of tokens\r\ncontract SettlementsListings is ReentrancyGuard {\r\n    enum OrderStatus {\r\n        NOT_EXIST,// This status is necessary because of enum-uint cast (0 if empty storage)\r\n        NEW,\r\n        CANCELLED,\r\n        ACCEPTED\r\n    }\r\n\r\n    struct SharesInfo {\r\n        bytes32 buildingTypeId;\r\n        uint256 minSharesAmount;\r\n    }\r\n\r\n    struct OrderDetails {\r\n        address orderOwner;\r\n        address sellingTokenAddress;\r\n        address allowedAddressToAcceptOrder;\r\n        uint256 orderStartTime;\r\n        uint256 orderEndTime;\r\n        uint256 price;\r\n        uint256 bannerId;\r\n        OrderStatus status;\r\n    }\r\n\r\n    /// @notice Banners contract\r\n    /// @dev Immutable, initialized in constructor\r\n    IERC721Enumerable public banners;\r\n\r\n    /// @notice World contract\r\n    /// @dev Immutable, initialized in constructor\r\n    IWorld public world;\r\n\r\n    /// @notice Mapping containing order id to related OrderDetails struct\r\n    /// @dev Modified when #createOrder or #acceptOrder or #cancelOrder is called\r\n    mapping(uint256 => OrderDetails) public orders;\r\n\r\n    /// @notice Mapping containing link from banner id to order id\r\n    /// @dev Modified when #createOrder or #createOrder is called\r\n    mapping(uint256 => uint256) public bannersOrders;\r\n\r\n    /// @notice Lastly created order id (0 if no orders is created)\r\n    /// @dev Modified when #createOrder is called\r\n    uint256 public lastOrderId = 0;\r\n\r\n    /// @notice Emitted when #createOrder is called\r\n    /// @param orderId Newly created order id\r\n    /// @param bannerId Banner id\r\n    /// @param sellingTokenAddress Selling token address (address(0) if native eth currency is used)\r\n    /// @param price Price\r\n    /// @param allowedAddressToAcceptOrder Allowed address to accept order (address(0) if any address can accept order)\r\n    /// @param orderStartTime Order start time (0 if order is started immediately)\r\n    /// @param orderEndTime Order end time (0 if order is lasting infinitely)\r\n    event OrderCreated(\r\n        uint256 orderId,\r\n        uint256 bannerId,\r\n        address sellingTokenAddress,\r\n        uint256 price,\r\n        address allowedAddressToAcceptOrder,\r\n        uint256 orderStartTime,\r\n        uint256 orderEndTime\r\n    );\r\n\r\n    /// @notice Emitted when #cancelOrder is called (can be emitted when #createOrder is called once again after banner owner is changed)\r\n    /// @param orderId Order id\r\n    event OrderCancelled(uint256 orderId);\r\n\r\n    /// @notice Emitted when #acceptOrder is called\r\n    /// @param orderId Order id\r\n    event OrderAccepted(uint256 orderId);\r\n\r\n    /// @notice Emitted when #modifyOrder is called\r\n    /// @param orderId Order id\r\n    /// @param sellingTokenAddress New selling token address (address(0) if native eth currency is used)\r\n    /// @param price New price\r\n    /// @param allowedAddressToAcceptOrder New allowed address to accept order (address(0) if any address can accept order)\r\n    /// @param orderStartTime New order start time (0 if order is started immediately)\r\n    /// @param orderEndTime New order end time (0 if order is lasting infinitely)\r\n    event OrderModified(\r\n        uint256 orderId,\r\n        address sellingTokenAddress,\r\n        uint256 price,\r\n        address allowedAddressToAcceptOrder,\r\n        uint256 orderStartTime,\r\n        uint256 orderEndTime\r\n    );\r\n\r\n    /// @notice Thrown when attempting to create order while not owning banner which will be traded\r\n    error CannotCreateOrderForNotOwnedBanner();\r\n\r\n    /// @notice Thrown when attempting to create order for one banner more than once\r\n    error CannotCreateOrderForBannerMoreThanOnce();\r\n\r\n    /// @notice Thrown when attempting to accept order with non NEW status\r\n    error CannotAcceptNotNewOrder();\r\n\r\n    /// @notice Thrown when attempting to accept order if 'orderDetails.allowedAddressToAcceptOrder' exist and msg.sender is not that address\r\n    error CannotAcceptOrderByNotAllowedAddress();\r\n\r\n    /// @notice Thrown when attempting to accept order if 'orderDetails.orderStartTime' exist and order is not started\r\n    error CannotAcceptNotStartedOrder();\r\n\r\n    /// @notice Thrown when attempting to accept order if 'orderDetails.orderEndTime' exist and order is already expired\r\n    error CannotAcceptExpiredOrder();\r\n\r\n    /// @notice Thrown when attempting to accept order without providing exact amount of tokens for it\r\n    error CannotAcceptOrderByProvidingNotExactPriceForIt();\r\n\r\n    /// @notice Thrown when attempting to accept order with shares to receive in the process lower than specified\r\n    error CannotAcceptOrderWithSharesToReceiveLowerThanSpecified();\r\n\r\n    /// @notice Thrown when attempting to cancel order if caller is not order owner and order owner owns banner\r\n    error CannotCancelActiveOrderIfCallerNotOrderOwnerAndOrderOwnerOwnsBanner();\r\n\r\n    /// @notice Thrown when attempting to cancel non NEW order\r\n    error CannotCancelNonNewOrder();\r\n\r\n    /// @notice Thrown when attempting to modify non NEW order\r\n    error CannotModifyNonNewOrder();\r\n\r\n    /// @notice Thrown when attempting to modify order by caller who is not order owner\r\n    error CannotModifyOrderByNonOrderOwner();\r\n\r\n    constructor(\r\n        address bannersAddress,\r\n        address worldAddress\r\n    ) public {\r\n        banners = IERC721Enumerable(bannersAddress);\r\n        world = IWorld(worldAddress);\r\n    }\r\n\r\n    /// @notice Creates settlement order\r\n    /// @dev Creates order for specified amount of tokens\r\n    /// @param bannerId Banner id\r\n    /// @param sellingTokenAddress Selling token address (address(0) if native eth currency is used)\r\n    /// @param price Price\r\n    /// @param allowedAddressToAcceptOrder Allowed address to accept order (address(0) if any address can accept order)\r\n    /// @param orderStartTime Order start time (0 if order is started immediately)\r\n    /// @param orderEndTime Order end time (0 if order is lasting infinitely)\r\n    function createOrder(\r\n        uint256 bannerId,\r\n        address sellingTokenAddress,\r\n        uint256 price,\r\n        address allowedAddressToAcceptOrder,\r\n        uint256 orderStartTime,\r\n        uint256 orderEndTime\r\n    ) public {\r\n        address bannerOwner = banners.ownerOf(bannerId);\r\n\r\n        uint256 orderId = bannersOrders[bannerId];\r\n        OrderDetails storage orderDetails = orders[orderId];\r\n\r\n        if (orderDetails.status == OrderStatus.NEW && orderDetails.orderOwner != bannerOwner) {\r\n            cancelOrder(orderId);\r\n        }\r\n\r\n        if (bannerOwner != msg.sender) revert CannotCreateOrderForNotOwnedBanner();\r\n        if (bannersOrders[bannerId] != 0) revert CannotCreateOrderForBannerMoreThanOnce();\r\n\r\n        lastOrderId = lastOrderId + 1;\r\n        bannersOrders[bannerId] = lastOrderId;\r\n\r\n        OrderDetails storage newOrderDetails = orders[lastOrderId];\r\n\r\n        newOrderDetails.bannerId = bannerId;\r\n        newOrderDetails.orderOwner = msg.sender;\r\n        newOrderDetails.sellingTokenAddress = sellingTokenAddress;\r\n        newOrderDetails.price = price;\r\n        newOrderDetails.status = OrderStatus.NEW;\r\n        newOrderDetails.allowedAddressToAcceptOrder = allowedAddressToAcceptOrder;\r\n        newOrderDetails.orderStartTime = orderStartTime;\r\n        newOrderDetails.orderEndTime = orderEndTime;\r\n\r\n        emit OrderCreated(lastOrderId, bannerId, sellingTokenAddress, price, allowedAddressToAcceptOrder, orderStartTime, orderEndTime);\r\n    }\r\n\r\n    /// @notice Accepts order\r\n    /// @dev Transfers banner id to msg.sender for provided amount of tokens (if ERC20 - they need to be approved beforehand, if native - they have to be sent to this function)\r\n    /// @param orderId Order id\r\n    /// @param minBuildingsSharesToReceive Minimum amount of building shares to receive with orders' banner\r\n    function acceptOrder(\r\n        uint256 orderId,\r\n        SharesInfo[] memory minBuildingsSharesToReceive\r\n    ) public payable nonReentrant {\r\n        OrderDetails storage orderDetails = orders[orderId];\r\n\r\n        if (orderDetails.status != OrderStatus.NEW) revert CannotAcceptNotNewOrder();\r\n        if (orderDetails.allowedAddressToAcceptOrder != address(0) && orderDetails.allowedAddressToAcceptOrder != msg.sender) revert CannotAcceptOrderByNotAllowedAddress();\r\n        if (orderDetails.orderStartTime != 0 && block.timestamp < orderDetails.orderStartTime) revert CannotAcceptNotStartedOrder();\r\n        if (orderDetails.orderEndTime != 0 && block.timestamp > orderDetails.orderEndTime) revert CannotAcceptExpiredOrder();\r\n\r\n        bool isNativeCurrency = orderDetails.sellingTokenAddress == address(0);\r\n        if (isNativeCurrency) {\r\n            if (msg.value != orderDetails.price) revert CannotAcceptOrderByProvidingNotExactPriceForIt();\r\n            Address.sendValue(payable(orderDetails.orderOwner), orderDetails.price);\r\n        } else {\r\n            SafeERC20.safeTransferFrom(\r\n                IERC20(orderDetails.sellingTokenAddress),\r\n                msg.sender,\r\n                orderDetails.orderOwner,\r\n                orderDetails.price\r\n            );\r\n        }\r\n\r\n        banners.safeTransferFrom(orderDetails.orderOwner, msg.sender, orderDetails.bannerId);\r\n\r\n        IDistributions distributions = world.distributions();\r\n        IEra currentEra = world.eras(world.currentEraNumber());\r\n        ISettlement settlement = currentEra.settlementByBannerId(orderDetails.bannerId);\r\n\r\n        uint256[] memory distributionIds = new uint256[](minBuildingsSharesToReceive.length);\r\n        uint256[] memory amounts = new uint256[](minBuildingsSharesToReceive.length);\r\n\r\n        for (uint256 i = 0; i < minBuildingsSharesToReceive.length; i++) {\r\n            SharesInfo memory minSharesInfo = minBuildingsSharesToReceive[i];\r\n            uint256 distributionId = settlement.buildings(minSharesInfo.buildingTypeId).distributionId();\r\n            uint256 sharesAmountOnOwner = distributions.balanceOf(orderDetails.orderOwner, distributionId);\r\n\r\n            if (sharesAmountOnOwner < minSharesInfo.minSharesAmount) revert CannotAcceptOrderWithSharesToReceiveLowerThanSpecified();\r\n\r\n            distributionIds[i] = distributionId;\r\n            amounts[i] = sharesAmountOnOwner;\r\n        }\r\n\r\n        distributions.safeBatchTransferFrom(\r\n            orderDetails.orderOwner,\r\n            msg.sender,\r\n            distributionIds,\r\n            amounts,\r\n            new bytes(0)\r\n        );\r\n\r\n        orderDetails.status = OrderStatus.ACCEPTED;\r\n        bannersOrders[orderDetails.bannerId] = 0;\r\n\r\n        emit OrderAccepted(orderId);\r\n    }\r\n\r\n    /// @notice Cancels order\r\n    /// @dev Can be called by order owner OR order owner is not banner owner (anyone can cancel order if order is not valid)\r\n    /// @param orderId Order id\r\n    function cancelOrder(\r\n        uint256 orderId\r\n    ) public {\r\n        OrderDetails storage orderDetails = orders[orderId];\r\n        address bannerOwner = banners.ownerOf(orderDetails.bannerId);\r\n\r\n        if (orderDetails.status != OrderStatus.NEW) revert CannotCancelNonNewOrder();\r\n\r\n        bool isOrderOwner = orderDetails.orderOwner == msg.sender;\r\n        bool isOrderOwnerOwnsBanner = orderDetails.orderOwner == bannerOwner;\r\n        if (!isOrderOwner && isOrderOwnerOwnsBanner) revert CannotCancelActiveOrderIfCallerNotOrderOwnerAndOrderOwnerOwnsBanner();\r\n\r\n        orderDetails.status = OrderStatus.CANCELLED;\r\n        bannersOrders[orderDetails.bannerId] = 0;\r\n\r\n        emit OrderCancelled(orderId);\r\n    }\r\n\r\n    /// @notice Modifies order\r\n    /// @dev Selling token address, price can be modified; banner id cannot be modified\r\n    /// @param orderId Order id\r\n    /// @param sellingTokenAddress New selling token address (address(0) if native eth currency is used)\r\n    /// @param price New price\r\n    /// @param allowedAddressToAcceptOrder New allowed address to accept order (address(0) if any address can accept order)\r\n    /// @param orderStartTime New order start time (0 if order is started immediately)\r\n    /// @param orderEndTime New order end time (0 if order is lasting infinitely)\r\n    function modifyOrder(\r\n        uint256 orderId,\r\n        address sellingTokenAddress,\r\n        uint256 price,\r\n        address allowedAddressToAcceptOrder,\r\n        uint256 orderStartTime,\r\n        uint256 orderEndTime\r\n    ) public {\r\n        OrderDetails storage orderDetails = orders[orderId];\r\n\r\n        if (orderDetails.status != OrderStatus.NEW) revert CannotModifyNonNewOrder();\r\n        if (orderDetails.orderOwner != msg.sender) revert CannotModifyOrderByNonOrderOwner();\r\n\r\n        orderDetails.sellingTokenAddress = sellingTokenAddress;\r\n        orderDetails.price = price;\r\n        orderDetails.allowedAddressToAcceptOrder = allowedAddressToAcceptOrder;\r\n        orderDetails.orderStartTime = orderStartTime;\r\n        orderDetails.orderEndTime = orderEndTime;\r\n\r\n        emit OrderModified(orderId, sellingTokenAddress, price, allowedAddressToAcceptOrder, orderStartTime, orderEndTime);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/ABDKMath64x64.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n    /*\r\n     * Minimum value signed 64.64-bit fixed point number may have.\r\n     */\r\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n    /*\r\n     * Maximum value signed 64.64-bit fixed point number may have.\r\n     */\r\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    /**\r\n     * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function fromInt (int256 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n        return int128 (x << 64);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n     * rounding down.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n    function toInt (int128 x) internal pure returns (int64) {\r\n    unchecked {\r\n        return int64 (x >> 64);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function fromUInt (uint256 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x <= 0x7FFFFFFFFFFFFFFF);\r\n        return int128 (int256 (x << 64));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n     * number rounding down.  Revert on underflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n    function toUInt (int128 x) internal pure returns (uint64) {\r\n    unchecked {\r\n        require (x >= 0);\r\n        return uint64 (uint128 (x >> 64));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n     * number rounding down.  Revert on overflow.\r\n     *\r\n     * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function from128x128 (int256 x) internal pure returns (int128) {\r\n    unchecked {\r\n        int256 result = x >> 64;\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n     * number.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n    function to128x128 (int128 x) internal pure returns (int256) {\r\n    unchecked {\r\n        return int256 (x) << 64;\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x + y.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function add (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n        int256 result = int256(x) + y;\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x - y.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n        int256 result = int256(x) - y;\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding down.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n        int256 result = int256(x) * y >> 64;\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n     * number and y is signed 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n    function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    unchecked {\r\n        if (x == MIN_64x64) {\r\n            require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n            y <= 0x1000000000000000000000000000000000000000000000000);\r\n            return -y << 63;\r\n        } else {\r\n            bool negativeResult = false;\r\n            if (x < 0) {\r\n                x = -x;\r\n                negativeResult = true;\r\n            }\r\n            if (y < 0) {\r\n                y = -y; // We rely on overflow behavior here\r\n                negativeResult = !negativeResult;\r\n            }\r\n            uint256 absoluteResult = mulu (x, uint256 (y));\r\n            if (negativeResult) {\r\n                require (absoluteResult <=\r\n                    0x8000000000000000000000000000000000000000000000000000000000000000);\r\n                return -int256 (absoluteResult); // We rely on overflow behavior here\r\n            } else {\r\n                require (absoluteResult <=\r\n                    0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n                return int256 (absoluteResult);\r\n            }\r\n        }\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n    function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    unchecked {\r\n        if (y == 0) return 0;\r\n\r\n        require (x >= 0);\r\n\r\n        uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n        uint256 hi = uint256 (int256 (x)) * (y >> 128);\r\n\r\n        require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        hi <<= 64;\r\n\r\n        require (hi <=\r\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n        return hi + lo;\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n     * zero.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function div (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n        require (y != 0);\r\n        int256 result = (int256 (x) << 64) / y;\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    unchecked {\r\n        require (y != 0);\r\n\r\n        bool negativeResult = false;\r\n        if (x < 0) {\r\n            x = -x; // We rely on overflow behavior here\r\n            negativeResult = true;\r\n        }\r\n        if (y < 0) {\r\n            y = -y; // We rely on overflow behavior here\r\n            negativeResult = !negativeResult;\r\n        }\r\n        uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n        if (negativeResult) {\r\n            require (absoluteResult <= 0x80000000000000000000000000000000);\r\n            return -int128 (absoluteResult); // We rely on overflow behavior here\r\n        } else {\r\n            require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n            return int128 (absoluteResult); // We rely on overflow behavior here\r\n        }\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    unchecked {\r\n        require (y != 0);\r\n        uint128 result = divuu (x, y);\r\n        require (result <= uint128 (MAX_64x64));\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate -x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function neg (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x != MIN_64x64);\r\n        return -x;\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate |x|.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function abs (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x != MIN_64x64);\r\n        return x < 0 ? -x : x;\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n     * zero.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function inv (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x != 0);\r\n        int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n        return int128 ((int256 (x) + int256 (y)) >> 1);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n     * Revert on overflow or in case x * y is negative.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    unchecked {\r\n        int256 m = int256 (x) * int256 (y);\r\n        require (m >= 0);\r\n        require (m <\r\n            0x4000000000000000000000000000000000000000000000000000000000000000);\r\n        return int128 (sqrtu (uint256 (m)));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    unchecked {\r\n        bool negative = x < 0 && y & 1 == 1;\r\n\r\n        uint256 absX = uint128 (x < 0 ? -x : x);\r\n        uint256 absResult;\r\n        absResult = 0x100000000000000000000000000000000;\r\n\r\n        if (absX <= 0x10000000000000000) {\r\n            absX <<= 63;\r\n            while (y != 0) {\r\n                if (y & 0x1 != 0) {\r\n                    absResult = absResult * absX >> 127;\r\n                }\r\n                absX = absX * absX >> 127;\r\n\r\n                if (y & 0x2 != 0) {\r\n                    absResult = absResult * absX >> 127;\r\n                }\r\n                absX = absX * absX >> 127;\r\n\r\n                if (y & 0x4 != 0) {\r\n                    absResult = absResult * absX >> 127;\r\n                }\r\n                absX = absX * absX >> 127;\r\n\r\n                if (y & 0x8 != 0) {\r\n                    absResult = absResult * absX >> 127;\r\n                }\r\n                absX = absX * absX >> 127;\r\n\r\n                y >>= 4;\r\n            }\r\n\r\n            absResult >>= 64;\r\n        } else {\r\n            uint256 absXShift = 63;\r\n            if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\r\n            if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\r\n            if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\r\n            if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\r\n            if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\r\n            if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\r\n\r\n            uint256 resultShift = 0;\r\n            while (y != 0) {\r\n                require (absXShift < 64);\r\n\r\n                if (y & 0x1 != 0) {\r\n                    absResult = absResult * absX >> 127;\r\n                    resultShift += absXShift;\r\n                    if (absResult > 0x100000000000000000000000000000000) {\r\n                        absResult >>= 1;\r\n                        resultShift += 1;\r\n                    }\r\n                }\r\n                absX = absX * absX >> 127;\r\n                absXShift <<= 1;\r\n                if (absX >= 0x100000000000000000000000000000000) {\r\n                    absX >>= 1;\r\n                    absXShift += 1;\r\n                }\r\n\r\n                y >>= 1;\r\n            }\r\n\r\n            require (resultShift < 64);\r\n            absResult >>= 64 - resultShift;\r\n        }\r\n        int256 result = negative ? -int256 (absResult) : int256 (absResult);\r\n        require (result >= MIN_64x64 && result <= MAX_64x64);\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function sqrt (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x >= 0);\r\n        return int128 (sqrtu (uint256 (int256 (x)) << 64));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate binary logarithm of x.  Revert if x <= 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function log_2 (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x > 0);\r\n\r\n        int256 msb = 0;\r\n        int256 xc = x;\r\n        if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n        int256 result = msb - 64 << 64;\r\n        uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\r\n        for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n            ux *= ux;\r\n            uint256 b = ux >> 255;\r\n            ux >>= 127 + b;\r\n            result += bit * int256 (b);\r\n        }\r\n\r\n        return int128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate natural logarithm of x.  Revert if x <= 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function ln (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x > 0);\r\n\r\n        return int128 (int256 (\r\n                uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate binary exponent of x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function exp_2 (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x < 0x400000000000000000); // Overflow\r\n\r\n        if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n        uint256 result = 0x80000000000000000000000000000000;\r\n\r\n        if (x & 0x8000000000000000 > 0)\r\n            result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n        if (x & 0x4000000000000000 > 0)\r\n            result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n        if (x & 0x2000000000000000 > 0)\r\n            result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n        if (x & 0x1000000000000000 > 0)\r\n            result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n        if (x & 0x800000000000000 > 0)\r\n            result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n        if (x & 0x400000000000000 > 0)\r\n            result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n        if (x & 0x200000000000000 > 0)\r\n            result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n        if (x & 0x100000000000000 > 0)\r\n            result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n        if (x & 0x80000000000000 > 0)\r\n            result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n        if (x & 0x40000000000000 > 0)\r\n            result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n        if (x & 0x20000000000000 > 0)\r\n            result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n        if (x & 0x10000000000000 > 0)\r\n            result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n        if (x & 0x8000000000000 > 0)\r\n            result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n        if (x & 0x4000000000000 > 0)\r\n            result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n        if (x & 0x2000000000000 > 0)\r\n            result = result * 0x1000162E525EE054754457D5995292026 >> 128;\r\n        if (x & 0x1000000000000 > 0)\r\n            result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n        if (x & 0x800000000000 > 0)\r\n            result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n        if (x & 0x400000000000 > 0)\r\n            result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n        if (x & 0x200000000000 > 0)\r\n            result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n        if (x & 0x100000000000 > 0)\r\n            result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n        if (x & 0x80000000000 > 0)\r\n            result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n        if (x & 0x40000000000 > 0)\r\n            result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n        if (x & 0x20000000000 > 0)\r\n            result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n        if (x & 0x10000000000 > 0)\r\n            result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n        if (x & 0x8000000000 > 0)\r\n            result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n        if (x & 0x4000000000 > 0)\r\n            result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n        if (x & 0x2000000000 > 0)\r\n            result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n        if (x & 0x1000000000 > 0)\r\n            result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n        if (x & 0x800000000 > 0)\r\n            result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n        if (x & 0x400000000 > 0)\r\n            result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n        if (x & 0x200000000 > 0)\r\n            result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n        if (x & 0x100000000 > 0)\r\n            result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n        if (x & 0x80000000 > 0)\r\n            result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n        if (x & 0x40000000 > 0)\r\n            result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n        if (x & 0x20000000 > 0)\r\n            result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n        if (x & 0x10000000 > 0)\r\n            result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n        if (x & 0x8000000 > 0)\r\n            result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n        if (x & 0x4000000 > 0)\r\n            result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n        if (x & 0x2000000 > 0)\r\n            result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n        if (x & 0x1000000 > 0)\r\n            result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n        if (x & 0x800000 > 0)\r\n            result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n        if (x & 0x400000 > 0)\r\n            result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n        if (x & 0x200000 > 0)\r\n            result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n        if (x & 0x100000 > 0)\r\n            result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n        if (x & 0x80000 > 0)\r\n            result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n        if (x & 0x40000 > 0)\r\n            result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n        if (x & 0x20000 > 0)\r\n            result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n        if (x & 0x10000 > 0)\r\n            result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n        if (x & 0x8000 > 0)\r\n            result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n        if (x & 0x4000 > 0)\r\n            result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n        if (x & 0x2000 > 0)\r\n            result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n        if (x & 0x1000 > 0)\r\n            result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n        if (x & 0x800 > 0)\r\n            result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n        if (x & 0x400 > 0)\r\n            result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n        if (x & 0x200 > 0)\r\n            result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n        if (x & 0x100 > 0)\r\n            result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n        if (x & 0x80 > 0)\r\n            result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n        if (x & 0x40 > 0)\r\n            result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n        if (x & 0x20 > 0)\r\n            result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n        if (x & 0x10 > 0)\r\n            result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n        if (x & 0x8 > 0)\r\n            result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n        if (x & 0x4 > 0)\r\n            result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n        if (x & 0x2 > 0)\r\n            result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n        if (x & 0x1 > 0)\r\n            result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n\r\n        result >>= uint256 (int256 (63 - (x >> 64)));\r\n        require (result <= uint256 (int256 (MAX_64x64)));\r\n\r\n        return int128 (int256 (result));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate natural exponent of x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n    function exp (int128 x) internal pure returns (int128) {\r\n    unchecked {\r\n        require (x < 0x400000000000000000); // Overflow\r\n\r\n        if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n        return exp_2 (\r\n            int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n    function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    unchecked {\r\n        require (y != 0);\r\n\r\n        uint256 result;\r\n\r\n        if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            result = (x << 64) / y;\r\n        else {\r\n            uint256 msb = 192;\r\n            uint256 xc = x >> 192;\r\n            if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n            if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n            if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n            if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n            if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n            if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n            result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\r\n            require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n            uint256 hi = result * (y >> 128);\r\n            uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n            uint256 xh = x >> 192;\r\n            uint256 xl = x << 64;\r\n\r\n            if (xl < lo) xh -= 1;\r\n            xl -= lo; // We rely on overflow behavior here\r\n            lo = hi << 128;\r\n            if (xl < lo) xh -= 1;\r\n            xl -= lo; // We rely on overflow behavior here\r\n\r\n            assert (xh == hi >> 128);\r\n\r\n            result += xl / y;\r\n        }\r\n\r\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return uint128 (result);\r\n    }\r\n    }\r\n\r\n    /**\r\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n     * number.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n    function sqrtu (uint256 x) private pure returns (uint128) {\r\n    unchecked {\r\n        if (x == 0) return 0;\r\n        else {\r\n            uint256 xx = x;\r\n            uint256 r = 1;\r\n            if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\r\n            if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\r\n            if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\r\n            if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\r\n            if (xx >= 0x100) { xx >>= 8; r <<= 4; }\r\n            if (xx >= 0x10) { xx >>= 4; r <<= 2; }\r\n            if (xx >= 0x8) { r <<= 1; }\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1; // Seven iterations should be enough\r\n            uint256 r1 = x / r;\r\n            return uint128 (r < r1 ? r : r1);\r\n        }\r\n    }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/GeographyUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\r\nimport \"./PerlinNoise.sol\";\r\n\r\nlibrary GeographyUtils {\r\n    struct Oddq {\r\n        int64 x;\r\n        int64 y;\r\n    }\r\n\r\n    struct Axial {\r\n        int64 q;\r\n        int64 r;\r\n    }\r\n\r\n    function getArea(uint64 radius) internal pure returns (uint64) {\r\n        return 3 * radius * (radius + 1) + 1;\r\n    }\r\n\r\n    function getShift(uint64 radius) internal pure returns (uint64) {\r\n        return 3 * radius + 2;\r\n    }\r\n\r\n    function positionToOddq(uint64 position) internal pure returns (Oddq memory) {\r\n        int64 y = int64(uint64(uint32(position >> 32)));\r\n        int64 x = int64(uint64(uint32(position)));\r\n        return Oddq(x, y);\r\n    }\r\n\r\n    function oddqToAxial(Oddq memory oddq) internal pure returns (Axial memory) {\r\n        int64 q = oddq.x;\r\n        int64 r = oddq.y - oddq.x / 2;\r\n        return Axial(q, r);\r\n    }\r\n\r\n    function axialToOddq(Axial memory axial) internal pure returns (Oddq memory) {\r\n        int64 x = axial.q;\r\n        int64 y = axial.r + (axial.q - (axial.q & 1)) / 2;\r\n        return Oddq(x, y);\r\n    }\r\n\r\n    function oddqToPosition(Oddq memory oddq) internal pure returns (uint64) {\r\n        return (uint64(oddq.y) << 32) + uint64(oddq.x);\r\n    }\r\n\r\n    function getNeighboringCenter0(Axial memory axial, int64 radius) internal pure returns (Axial memory) {\r\n        int64 q = axial.q + 2 * radius + 1;\r\n        int64 r = axial.r - radius;\r\n\r\n        return Axial(q, r);\r\n    }\r\n\r\n    function getNeighboringCenter1(Axial memory axial, int64 radius) internal pure returns (Axial memory) {\r\n        int64 q = axial.q + radius;\r\n        int64 r = axial.r + radius + 1;\r\n\r\n        return Axial(q, r);\r\n    }\r\n\r\n    function getNeighboringCenter2(Axial memory axial, int64 radius) internal pure returns (Axial memory) {\r\n        int64 q = axial.q - (radius + 1);\r\n        int64 r = axial.r + (2 * radius + 1);\r\n\r\n        return Axial(q, r);\r\n    }\r\n\r\n    function getNeighboringCenter3(Axial memory axial, int64 radius) internal pure returns (Axial memory) {\r\n        int64 q = axial.q - (2 * radius + 1);\r\n        int64 r = axial.r + radius;\r\n\r\n        return Axial(q, r);\r\n    }\r\n\r\n    function getNeighboringCenter4(Axial memory axial, int64 radius) internal pure returns (Axial memory) {\r\n        int64 q = axial.q - radius;\r\n        int64 r = axial.r - (radius + 1);\r\n\r\n        return Axial(q, r);\r\n    }\r\n\r\n    function getNeighboringCenter5(Axial memory axial, int64 radius) internal pure returns (Axial memory) {\r\n        int64 q = axial.q + radius + 1;\r\n        int64 r = axial.r - (2 * radius + 1);\r\n\r\n        return Axial(q, r);\r\n    }\r\n\r\n    function getClosestFakeCenter(\r\n        Axial memory position,\r\n        Axial memory center,\r\n        uint64 radius,\r\n        bytes32 seed,\r\n        uint64 shift,\r\n        uint64 area\r\n    ) internal pure returns (Axial memory) {\r\n        Axial[] memory centers = new Axial[](18);\r\n\r\n        int64 intRadius = int64(radius);\r\n\r\n        centers[0] = getNeighboringCenter0(center, intRadius);\r\n        centers[1] = getNeighboringCenter1(center, intRadius);\r\n        centers[2] = getNeighboringCenter2(center, intRadius);\r\n        centers[3] = getNeighboringCenter3(center, intRadius);\r\n        centers[4] = getNeighboringCenter4(center, intRadius);\r\n        centers[5] = getNeighboringCenter5(center, intRadius);\r\n        centers[6] = getNeighboringCenter0(centers[0], intRadius);\r\n        centers[7] = getNeighboringCenter0(centers[1], intRadius);\r\n        centers[8] = getNeighboringCenter1(centers[1], intRadius);\r\n        centers[9] = getNeighboringCenter2(centers[1], intRadius);\r\n        centers[10] = getNeighboringCenter2(centers[2], intRadius);\r\n        centers[11] = getNeighboringCenter3(centers[2], intRadius);\r\n        centers[12] = getNeighboringCenter3(centers[3], intRadius);\r\n        centers[13] = getNeighboringCenter3(centers[4], intRadius);\r\n        centers[14] = getNeighboringCenter4(centers[4], intRadius);\r\n        centers[15] = getNeighboringCenter4(centers[5], intRadius);\r\n        centers[16] = getNeighboringCenter5(centers[5], intRadius);\r\n        centers[17] = getNeighboringCenter0(centers[5], intRadius);\r\n\r\n        Axial memory closestFakeCenterToPosition = getFakeCenter(center, seed, radius, shift, area);\r\n        uint64 distanceFromClosestFakeCenterToPosition = getDistanceBetweenPositions(position, closestFakeCenterToPosition);\r\n        for (uint256 i = 0; i < 18; i++) {\r\n            Axial memory realCenter = centers[i];\r\n            Axial memory fakeCenter = getFakeCenter(realCenter, seed, radius, shift, area);\r\n            if (!isValidCenter(fakeCenter, radius)) {\r\n                continue;\r\n            }\r\n\r\n            uint64 distanceFromNewFakeCenterToPosition = getDistanceBetweenPositions(position, fakeCenter);\r\n            if (distanceFromNewFakeCenterToPosition < distanceFromClosestFakeCenterToPosition) {\r\n                closestFakeCenterToPosition = fakeCenter;\r\n                distanceFromClosestFakeCenterToPosition = distanceFromNewFakeCenterToPosition;\r\n            }\r\n        }\r\n\r\n        return closestFakeCenterToPosition;\r\n    }\r\n\r\n    function isValidCenter(Axial memory center, uint64 radius) internal pure returns (bool) {\r\n        Oddq memory oddq = axialToOddq(center);\r\n        int64 lowerBound = int64(uint64(type(uint32).max)) - 1 - int64(radius);\r\n        return oddq.x >= int64(radius) && oddq.x <= lowerBound && oddq.y >= int64(radius) && oddq.y <= lowerBound;\r\n    }\r\n\r\n    function getDistanceBetweenPositions(Axial memory axial1, Axial memory axial2) internal pure returns (uint64) {\r\n        int64 axial1S = -axial1.q - axial1.r;\r\n        int64 axial2S = -axial2.q - axial2.r;\r\n        return uint64((SignedMath.abs(axial1.q - axial2.q) + SignedMath.abs(axial1.r - axial2.r) + SignedMath.abs(axial1S - axial2S)) / 2);\r\n    }\r\n\r\n    function getRegionCenterByPosition(uint64 position, uint64 radius, bytes32 seed) internal pure returns (uint64, bool) {\r\n        Oddq memory oddqPosition = positionToOddq(position);\r\n        Axial memory axialPosition = oddqToAxial(oddqPosition);\r\n        uint64 shift = getShift(radius);\r\n        uint64 area = getArea(radius);\r\n\r\n        Axial memory realCenterOfPosition = getRealCenter(axialPosition, radius, shift, area);\r\n        Axial memory fakeCenter = getFakeCenter(realCenterOfPosition, seed, radius, shift, area);\r\n        if (!isValidCenter(fakeCenter, radius)) {\r\n            return (0, false);\r\n        }\r\n\r\n        bool isPositionSameAsItsFakeCenter = fakeCenter.q == axialPosition.q && fakeCenter.r == axialPosition.r;\r\n        if (!isPositionSameAsItsFakeCenter && !hasPosition(oddqPosition)) {\r\n            return (0, false);\r\n        }\r\n\r\n        Axial memory closestFakeCenterToPosition = getClosestFakeCenter(axialPosition, realCenterOfPosition, radius, seed, shift, area);\r\n        return (oddqToPosition(axialToOddq(closestFakeCenterToPosition)), true);\r\n    }\r\n\r\n    function hasPosition(Oddq memory oddq) internal pure returns (bool) {\r\n        int256 noise = PerlinNoise.noise2d(\r\n            int256(oddq.x * 3200),\r\n            int256(oddq.y * 3200)\r\n        );\r\n\r\n        if (noise >= 26660) {\r\n            return false;\r\n        }\r\n\r\n        noise = PerlinNoise.noise2d(\r\n            int256(oddq.x * 5000),\r\n            int256(oddq.y * 5000)\r\n        );\r\n\r\n        if (noise >= 13000) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function hexmodToAxial(uint64 hexmod, uint64 radius, uint64 shift) internal pure returns (Axial memory) {\r\n        uint64 _2xRadius = 2 * radius;\r\n\r\n        uint64 ms = (hexmod + radius) / shift;\r\n        uint64 mcs = (hexmod + _2xRadius) / (shift - 1);\r\n\r\n        uint64 msxRadius = ms * radius;\r\n        uint64 mcsxRadius = mcs * radius;\r\n\r\n        int64 q = int64(msxRadius + ms) - int64(mcsxRadius);\r\n        int64 r = int64(hexmod) - int64(msxRadius * 2 + ms) - int64(mcsxRadius + mcs);\r\n\r\n        return Axial(q, r);\r\n    }\r\n\r\n    function getRealCenter(Axial memory axial, uint64 radius, uint64 shift, uint64 area) internal pure returns (Axial memory) {\r\n        uint64 hexmod = uint64((axial.r + int64(shift) * axial.q) % int64(area));\r\n\r\n        Axial memory axialHexmod = hexmodToAxial(hexmod, radius, shift);\r\n        Axial memory axialCenter = Axial(\r\n            axial.q - axialHexmod.q,\r\n            axial.r - axialHexmod.r\r\n        );\r\n\r\n        return axialCenter;\r\n    }\r\n\r\n    function getFakeCenter(Axial memory axial, bytes32 seed, uint64 radius, uint64 shift, uint64 area) internal pure returns (Axial memory) {\r\n        bytes32 hash = keccak256(abi.encodePacked(axial.q, axial.r, seed));\r\n        uint256 randomValue = uint256(hash) % 1e18;\r\n\r\n        uint64 randomHexmod = uint64(randomValue * area / 1e18);\r\n        Axial memory axialHexmod = hexmodToAxial(randomHexmod, radius, shift);\r\n\r\n        return Axial(\r\n            axial.q + axialHexmod.q,\r\n            axial.r + axialHexmod.r\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/MathExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Extension of math library\r\n/// @notice Contains helper functions for some math operations\r\nlibrary MathExtension {\r\n    /// @dev Calculates square root of uint256 using Babylonian Method\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Rounds uint256 value with provided precision to its integer value rounding down\r\n    function roundDownWithPrecision(uint256 value, uint256 precision) internal pure returns (uint256) {\r\n        return (value / precision) * precision;\r\n    }\r\n\r\n    /// @dev Rounds uint256 value with provided precision to its integer value rounding up\r\n    function roundUpWithPrecision(uint256 value, uint256 precision) internal pure returns (uint256) {\r\n        uint256 roundedValue = roundDownWithPrecision(value, precision);\r\n        if (value % precision != 0) {\r\n            roundedValue += precision;\r\n        }\r\n\r\n        return roundedValue;\r\n    }\r\n\r\n    /// @dev Check if uint256 value with provided precision integer value or not\r\n    function isIntegerWithPrecision(uint256 value, uint256 precision) internal pure returns (bool) {\r\n        return value % precision == 0;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/PerlinNoise.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/**\r\n * @notice An implementation of Perlin Noise that uses 16 bit fixed point arithmetic.\r\n */\r\nlibrary PerlinNoise {\r\n\r\n    /**\r\n     * @notice Computes the noise value for a 2D point.\r\n     *\r\n     * @param x the x coordinate.\r\n     * @param y the y coordinate.\r\n     *\r\n     * @dev This function should be kept public. Inlining the bytecode for this function\r\n     *      into other functions could explode its compiled size because of how `ftable`\r\n     *      and `ptable` were written.\r\n     */\r\n    function noise2d(int256 x, int256 y) internal pure returns (int256) {\r\n        int256 temp = ptable(x >> 16 & 0xff /* Unit square X */);\r\n\r\n        int256 a = ptable((temp >> 8  ) + (y >> 16 & 0xff /* Unit square Y */));\r\n        int256 b = ptable((temp & 0xff) + (y >> 16 & 0xff                    ));\r\n\r\n        x &= 0xffff; // Square relative X\r\n        y &= 0xffff; // Square relative Y\r\n\r\n        int256 u = fade(x);\r\n\r\n        int256 c = lerp(u, grad2(a >> 8  , x, y        ), grad2(b >> 8  , x-0x10000, y        ));\r\n        int256 d = lerp(u, grad2(a & 0xff, x, y-0x10000), grad2(b & 0xff, x-0x10000, y-0x10000));\r\n\r\n        return lerp(fade(y), c, d);\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the noise value for a 3D point.\r\n     *\r\n     * @param x the x coordinate.\r\n     * @param y the y coordinate.\r\n     * @param z the z coordinate.\r\n     *\r\n     * @dev This function should be kept public. Inlining the bytecode for this function\r\n     *      into other functions could explode its compiled size because of how `ftable`\r\n     *      and `ptable` were written.\r\n     */\r\n    function noise3d(int256 x, int256 y, int256 z) internal pure returns (int256) {\r\n        int256[7] memory scratch = [\r\n        x >> 16 & 0xff,  // Unit cube X\r\n        y >> 16 & 0xff,  // Unit cube Y\r\n        z >> 16 & 0xff,  // Unit cube Z\r\n        0, 0, 0, 0\r\n        ];\r\n\r\n        x &= 0xffff; // Cube relative X\r\n        y &= 0xffff; // Cube relative Y\r\n        z &= 0xffff; // Cube relative Z\r\n\r\n        // Temporary variables used for intermediate calculations.\r\n        int256 u;\r\n        int256 v;\r\n\r\n        v = ptable(scratch[0]);\r\n\r\n        u = ptable((v >> 8  ) + scratch[1]);\r\n        v = ptable((v & 0xff) + scratch[1]);\r\n\r\n        scratch[3] = ptable((u >> 8  ) + scratch[2]);\r\n        scratch[4] = ptable((u & 0xff) + scratch[2]);\r\n        scratch[5] = ptable((v >> 8  ) + scratch[2]);\r\n        scratch[6] = ptable((v & 0xff) + scratch[2]);\r\n\r\n        int256 a;\r\n        int256 b;\r\n        int256 c;\r\n\r\n        u = fade(x);\r\n        v = fade(y);\r\n\r\n        a = lerp(u, grad3(scratch[3] >> 8, x, y        , z), grad3(scratch[5] >> 8, x-0x10000, y        , z));\r\n        b = lerp(u, grad3(scratch[4] >> 8, x, y-0x10000, z), grad3(scratch[6] >> 8, x-0x10000, y-0x10000, z));\r\n        c = lerp(v, a, b);\r\n\r\n        a = lerp(u, grad3(scratch[3] & 0xff, x, y        , z-0x10000), grad3(scratch[5] & 0xff, x-0x10000, y        , z-0x10000));\r\n        b = lerp(u, grad3(scratch[4] & 0xff, x, y-0x10000, z-0x10000), grad3(scratch[6] & 0xff, x-0x10000, y-0x10000, z-0x10000));\r\n\r\n        return lerp(fade(z), c, lerp(v, a, b));\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the linear interpolation between two values, `a` and `b`, using fixed point arithmetic.\r\n     *\r\n     * @param t the time value of the equation.\r\n     * @param a the lower point.\r\n     * @param b the upper point.\r\n     */\r\n    function lerp(int256 t, int256 a, int256 b) internal pure returns (int256) {\r\n        return a + (t * (b - a) >> 12);\r\n    }\r\n\r\n    /**\r\n     * @notice Applies the fade function to a value.\r\n     *\r\n     * @param t the time value of the equation.\r\n     *\r\n     * @dev The polynomial for this function is: 6t^4-15t^4+10t^3.\r\n     */\r\n    function fade(int256 t) internal pure returns (int256) {\r\n        int256 n = ftable(t >> 8);\r\n\r\n        // Lerp between the two points grabbed from the fade table.\r\n        (int256 lower, int256 upper) = (n >> 12, n & 0xfff);\r\n        return lower + ((t & 0xff) * (upper - lower) >> 8);\r\n    }\r\n\r\n    /**\r\n      * @notice Computes the gradient value for a 2D point.\r\n      *\r\n      * @param h the hash value to use for picking the vector.\r\n      * @param x the x coordinate of the point.\r\n      * @param y the y coordinate of the point.\r\n      */\r\n    function grad2(int256 h, int256 x, int256 y) internal pure returns (int256) {\r\n        h &= 3;\r\n\r\n        int256 u;\r\n        if (h & 0x1 == 0) {\r\n            u = x;\r\n        } else {\r\n            u = -x;\r\n        }\r\n\r\n        int256 v;\r\n        if (h < 2) {\r\n            v = y;\r\n        } else {\r\n            v = -y;\r\n        }\r\n\r\n        return u + v;\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the gradient value for a 3D point.\r\n     *\r\n     * @param h the hash value to use for picking the vector.\r\n     * @param x the x coordinate of the point.\r\n     * @param y the y coordinate of the point.\r\n     * @param z the z coordinate of the point.\r\n     */\r\n    function grad3(int256 h, int256 x, int256 y, int256 z) internal pure returns (int256) {\r\n        h &= 0xf;\r\n\r\n        int256 u;\r\n        if (h < 8) {\r\n            u = x;\r\n        } else {\r\n            u = y;\r\n        }\r\n\r\n        int256 v;\r\n        if (h < 4) {\r\n            v = y;\r\n        } else if (h == 12 || h == 14) {\r\n            v = x;\r\n        } else {\r\n            v = z;\r\n        }\r\n\r\n        if ((h & 0x1) != 0) {\r\n            u = -u;\r\n        }\r\n\r\n        if ((h & 0x2) != 0) {\r\n            v = -v;\r\n        }\r\n\r\n        return u + v;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets a subsequent values in the permutation table at an index. The values are encoded\r\n     *         into a single 24 bit integer with the  value at the specified index being the most\r\n     *         significant 12 bits and the subsequent value being the least significant 12 bits.\r\n     *\r\n     * @param i the index in the permutation table.\r\n     *\r\n     * @dev The values from the table are mapped out into a binary tree for faster lookups.\r\n     *      Looking up any value in the table in this implementation is is O(8), in\r\n     *      the implementation of sequential if statements it is O(255).\r\n     *\r\n     * @dev The body of this function is autogenerated. Check out the 'gen-ptable' script.\r\n     */\r\n    function ptable(int256 i) internal pure returns (int256) {\r\n        i &= 0xff;\r\n\r\n        if (i <= 127) {\r\n            if (i <= 63) {\r\n                if (i <= 31) {\r\n                    if (i <= 15) {\r\n                        if (i <= 7) {\r\n                            if (i <= 3) {\r\n                                if (i <= 1) {\r\n                                    if (i == 0) { return 38816; } else { return 41097; }\r\n                                } else {\r\n                                    if (i == 2) { return 35163; } else { return 23386; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 5) {\r\n                                    if (i == 4) { return 23055; } else { return 3971; }\r\n                                } else {\r\n                                    if (i == 6) { return 33549; } else { return 3529; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 11) {\r\n                                if (i <= 9) {\r\n                                    if (i == 8) { return 51551; } else { return 24416; }\r\n                                } else {\r\n                                    if (i == 10) { return 24629; } else { return 13762; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 13) {\r\n                                    if (i == 12) { return 49897; } else { return 59655; }\r\n                                } else {\r\n                                    if (i == 14) { return 2017; } else { return 57740; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 23) {\r\n                            if (i <= 19) {\r\n                                if (i <= 17) {\r\n                                    if (i == 16) { return 35876; } else { return 9319; }\r\n                                } else {\r\n                                    if (i == 18) { return 26398; } else { return 7749; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 21) {\r\n                                    if (i == 20) { return 17806; } else { return 36360; }\r\n                                } else {\r\n                                    if (i == 22) { return 2147; } else { return 25381; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 27) {\r\n                                if (i <= 25) {\r\n                                    if (i == 24) { return 9712; } else { return 61461; }\r\n                                } else {\r\n                                    if (i == 26) { return 5386; } else { return 2583; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 29) {\r\n                                    if (i == 28) { return 6078; } else { return 48646; }\r\n                                } else {\r\n                                    if (i == 30) { return 1684; } else { return 38135; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (i <= 47) {\r\n                        if (i <= 39) {\r\n                            if (i <= 35) {\r\n                                if (i <= 33) {\r\n                                    if (i == 32) { return 63352; } else { return 30954; }\r\n                                } else {\r\n                                    if (i == 34) { return 59979; } else { return 19200; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 37) {\r\n                                    if (i == 36) { return 26; } else { return 6853; }\r\n                                } else {\r\n                                    if (i == 38) { return 50494; } else { return 15966; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 43) {\r\n                                if (i <= 41) {\r\n                                    if (i == 40) { return 24316; } else { return 64731; }\r\n                                } else {\r\n                                    if (i == 42) { return 56267; } else { return 52085; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 45) {\r\n                                    if (i == 44) { return 29987; } else { return 8971; }\r\n                                } else {\r\n                                    if (i == 46) { return 2848; } else { return 8249; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 55) {\r\n                            if (i <= 51) {\r\n                                if (i <= 49) {\r\n                                    if (i == 48) { return 14769; } else { return 45345; }\r\n                                } else {\r\n                                    if (i == 50) { return 8536; } else { return 22765; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 53) {\r\n                                    if (i == 52) { return 60821; } else { return 38200; }\r\n                                } else {\r\n                                    if (i == 54) { return 14423; } else { return 22446; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 59) {\r\n                                if (i <= 57) {\r\n                                    if (i == 56) { return 44564; } else { return 5245; }\r\n                                } else {\r\n                                    if (i == 58) { return 32136; } else { return 34987; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 61) {\r\n                                    if (i == 60) { return 43944; } else { return 43076; }\r\n                                } else {\r\n                                    if (i == 62) { return 17583; } else { return 44874; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (i <= 95) {\r\n                    if (i <= 79) {\r\n                        if (i <= 71) {\r\n                            if (i <= 67) {\r\n                                if (i <= 65) {\r\n                                    if (i == 64) { return 19109; } else { return 42311; }\r\n                                } else {\r\n                                    if (i == 66) { return 18310; } else { return 34443; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 69) {\r\n                                    if (i == 68) { return 35632; } else { return 12315; }\r\n                                } else {\r\n                                    if (i == 70) { return 7078; } else { return 42573; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 75) {\r\n                                if (i <= 73) {\r\n                                    if (i == 72) { return 19858; } else { return 37534; }\r\n                                } else {\r\n                                    if (i == 74) { return 40679; } else { return 59219; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 77) {\r\n                                    if (i == 76) { return 21359; } else { return 28645; }\r\n                                } else {\r\n                                    if (i == 78) { return 58746; } else { return 31292; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 87) {\r\n                            if (i <= 83) {\r\n                                if (i <= 81) {\r\n                                    if (i == 80) { return 15571; } else { return 54149; }\r\n                                } else {\r\n                                    if (i == 82) { return 34278; } else { return 59100; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 85) {\r\n                                    if (i == 84) { return 56425; } else { return 26972; }\r\n                                } else {\r\n                                    if (i == 86) { return 23593; } else { return 10551; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 91) {\r\n                                if (i <= 89) {\r\n                                    if (i == 88) { return 14126; } else { return 12021; }\r\n                                } else {\r\n                                    if (i == 90) { return 62760; } else { return 10484; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 93) {\r\n                                    if (i == 92) { return 62566; } else { return 26255; }\r\n                                } else {\r\n                                    if (i == 94) { return 36662; } else { return 13889; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (i <= 111) {\r\n                        if (i <= 103) {\r\n                            if (i <= 99) {\r\n                                if (i <= 97) {\r\n                                    if (i == 96) { return 16665; } else { return 6463; }\r\n                                } else {\r\n                                    if (i == 98) { return 16289; } else { return 41217; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 101) {\r\n                                    if (i == 100) { return 472; } else { return 55376; }\r\n                                } else {\r\n                                    if (i == 102) { return 20553; } else { return 18897; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 107) {\r\n                                if (i <= 105) {\r\n                                    if (i == 104) { return 53580; } else { return 19588; }\r\n                                } else {\r\n                                    if (i == 106) { return 33979; } else { return 48080; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 109) {\r\n                                    if (i == 108) { return 53337; } else { return 22802; }\r\n                                } else {\r\n                                    if (i == 110) { return 4777; } else { return 43464; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 119) {\r\n                            if (i <= 115) {\r\n                                if (i <= 113) {\r\n                                    if (i == 112) { return 51396; } else { return 50311; }\r\n                                } else {\r\n                                    if (i == 114) { return 34690; } else { return 33396; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 117) {\r\n                                    if (i == 116) { return 29884; } else { return 48287; }\r\n                                } else {\r\n                                    if (i == 118) { return 40790; } else { return 22180; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 123) {\r\n                                if (i <= 121) {\r\n                                    if (i == 120) { return 42084; } else { return 25709; }\r\n                                } else {\r\n                                    if (i == 122) { return 28102; } else { return 50861; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 125) {\r\n                                    if (i == 124) { return 44474; } else { return 47619; }\r\n                                } else {\r\n                                    if (i == 126) { return 832; } else { return 16436; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (i <= 191) {\r\n                if (i <= 159) {\r\n                    if (i <= 143) {\r\n                        if (i <= 135) {\r\n                            if (i <= 131) {\r\n                                if (i <= 129) {\r\n                                    if (i == 128) { return 13529; } else { return 55778; }\r\n                                } else {\r\n                                    if (i == 130) { return 58106; } else { return 64124; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 133) {\r\n                                    if (i == 132) { return 31867; } else { return 31493; }\r\n                                } else {\r\n                                    if (i == 134) { return 1482; } else { return 51750; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 139) {\r\n                                if (i <= 137) {\r\n                                    if (i == 136) { return 9875; } else { return 37750; }\r\n                                } else {\r\n                                    if (i == 138) { return 30334; } else { return 32511; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 141) {\r\n                                    if (i == 140) { return 65362; } else { return 21077; }\r\n                                } else {\r\n                                    if (i == 142) { return 21972; } else { return 54479; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 151) {\r\n                            if (i <= 147) {\r\n                                if (i <= 145) {\r\n                                    if (i == 144) { return 53198; } else { return 52795; }\r\n                                } else {\r\n                                    if (i == 146) { return 15331; } else { return 58159; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 149) {\r\n                                    if (i == 148) { return 12048; } else { return 4154; }\r\n                                } else {\r\n                                    if (i == 150) { return 14865; } else { return 4534; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 155) {\r\n                                if (i <= 153) {\r\n                                    if (i == 152) { return 46781; } else { return 48412; }\r\n                                } else {\r\n                                    if (i == 154) { return 7210; } else { return 10975; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 157) {\r\n                                    if (i == 156) { return 57271; } else { return 47018; }\r\n                                } else {\r\n                                    if (i == 158) { return 43733; } else { return 54647; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (i <= 175) {\r\n                        if (i <= 167) {\r\n                            if (i <= 163) {\r\n                                if (i <= 161) {\r\n                                    if (i == 160) { return 30712; } else { return 63640; }\r\n                                } else {\r\n                                    if (i == 162) { return 38914; } else { return 556; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 165) {\r\n                                    if (i == 164) { return 11418; } else { return 39587; }\r\n                                } else {\r\n                                    if (i == 166) { return 41798; } else { return 18141; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 171) {\r\n                                if (i <= 169) {\r\n                                    if (i == 168) { return 56729; } else { return 39269; }\r\n                                } else {\r\n                                    if (i == 170) { return 26011; } else { return 39847; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 173) {\r\n                                    if (i == 172) { return 42795; } else { return 11180; }\r\n                                } else {\r\n                                    if (i == 174) { return 44041; } else { return 2433; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 183) {\r\n                            if (i <= 179) {\r\n                                if (i <= 177) {\r\n                                    if (i == 176) { return 33046; } else { return 5671; }\r\n                                } else {\r\n                                    if (i == 178) { return 10237; } else { return 64787; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 181) {\r\n                                    if (i == 180) { return 4962; } else { return 25196; }\r\n                                } else {\r\n                                    if (i == 182) { return 27758; } else { return 28239; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 187) {\r\n                                if (i <= 185) {\r\n                                    if (i == 184) { return 20337; } else { return 29152; }\r\n                                } else {\r\n                                    if (i == 186) { return 57576; } else { return 59570; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 189) {\r\n                                    if (i == 188) { return 45753; } else { return 47472; }\r\n                                } else {\r\n                                    if (i == 190) { return 28776; } else { return 26842; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (i <= 223) {\r\n                    if (i <= 207) {\r\n                        if (i <= 199) {\r\n                            if (i <= 195) {\r\n                                if (i <= 193) {\r\n                                    if (i == 192) { return 56054; } else { return 63073; }\r\n                                } else {\r\n                                    if (i == 194) { return 25060; } else { return 58619; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 197) {\r\n                                    if (i == 196) { return 64290; } else { return 8946; }\r\n                                } else {\r\n                                    if (i == 198) { return 62145; } else { return 49646; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 203) {\r\n                                if (i <= 201) {\r\n                                    if (i == 200) { return 61138; } else { return 53904; }\r\n                                } else {\r\n                                    if (i == 202) { return 36876; } else { return 3263; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 205) {\r\n                                    if (i == 204) { return 49075; } else { return 45986; }\r\n                                } else {\r\n                                    if (i == 206) { return 41713; } else { return 61777; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 215) {\r\n                            if (i <= 211) {\r\n                                if (i <= 209) {\r\n                                    if (i == 208) { return 20787; } else { return 13201; }\r\n                                } else {\r\n                                    if (i == 210) { return 37355; } else { return 60409; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 213) {\r\n                                    if (i == 212) { return 63758; } else { return 3823; }\r\n                                } else {\r\n                                    if (i == 214) { return 61291; } else { return 27441; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 219) {\r\n                                if (i <= 217) {\r\n                                    if (i == 216) { return 12736; } else { return 49366; }\r\n                                } else {\r\n                                    if (i == 218) { return 54815; } else { return 8117; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 221) {\r\n                                    if (i == 220) { return 46535; } else { return 51050; }\r\n                                } else {\r\n                                    if (i == 222) { return 27293; } else { return 40376; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (i <= 239) {\r\n                        if (i <= 231) {\r\n                            if (i <= 227) {\r\n                                if (i <= 225) {\r\n                                    if (i == 224) { return 47188; } else { return 21708; }\r\n                                } else {\r\n                                    if (i == 226) { return 52400; } else { return 45171; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 229) {\r\n                                    if (i == 228) { return 29561; } else { return 31026; }\r\n                                } else {\r\n                                    if (i == 230) { return 12845; } else { return 11647; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 235) {\r\n                                if (i <= 233) {\r\n                                    if (i == 232) { return 32516; } else { return 1174; }\r\n                                } else {\r\n                                    if (i == 234) { return 38654; } else { return 65162; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 237) {\r\n                                    if (i == 236) { return 35564; } else { return 60621; }\r\n                                } else {\r\n                                    if (i == 238) { return 52573; } else { return 24030; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 247) {\r\n                            if (i <= 243) {\r\n                                if (i <= 241) {\r\n                                    if (i == 240) { return 56946; } else { return 29251; }\r\n                                } else {\r\n                                    if (i == 242) { return 17181; } else { return 7448; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 245) {\r\n                                    if (i == 244) { return 6216; } else { return 18675; }\r\n                                } else {\r\n                                    if (i == 246) { return 62349; } else { return 36224; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 251) {\r\n                                if (i <= 249) {\r\n                                    if (i == 248) { return 32963; } else { return 49998; }\r\n                                } else {\r\n                                    if (i == 250) { return 20034; } else { return 17111; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 253) {\r\n                                    if (i == 252) { return 55101; } else { return 15772; }\r\n                                } else {\r\n                                    if (i == 254) { return 40116; } else { return 46231; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @notice Gets subsequent values in the fade table at an index. The values are encoded\r\n     *         into a single 16 bit integer with the value at the specified index being the most\r\n     *         significant 8 bits and the subsequent value being the least significant 8 bits.\r\n     *\r\n     * @param i the index in the fade table.\r\n     *\r\n     * @dev The values from the table are mapped out into a binary tree for faster lookups.\r\n     *      Looking up any value in the table in this implementation is is O(8), in\r\n     *      the implementation of sequential if statements it is O(256).\r\n     *\r\n     * @dev The body of this function is autogenerated. Check out the 'gen-ftable' script.\r\n     */\r\n    function ftable(int256 i) internal pure returns (int256) {\r\n        if (i <= 127) {\r\n            if (i <= 63) {\r\n                if (i <= 31) {\r\n                    if (i <= 15) {\r\n                        if (i <= 7) {\r\n                            if (i <= 3) {\r\n                                if (i <= 1) {\r\n                                    if (i == 0) { return 0; } else { return 0; }\r\n                                } else {\r\n                                    if (i == 2) { return 0; } else { return 0; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 5) {\r\n                                    if (i == 4) { return 0; } else { return 0; }\r\n                                } else {\r\n                                    if (i == 6) { return 0; } else { return 1; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 11) {\r\n                                if (i <= 9) {\r\n                                    if (i == 8) { return 4097; } else { return 4098; }\r\n                                } else {\r\n                                    if (i == 10) { return 8195; } else { return 12291; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 13) {\r\n                                    if (i == 12) { return 12292; } else { return 16390; }\r\n                                } else {\r\n                                    if (i == 14) { return 24583; } else { return 28681; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 23) {\r\n                            if (i <= 19) {\r\n                                if (i <= 17) {\r\n                                    if (i == 16) { return 36874; } else { return 40972; }\r\n                                } else {\r\n                                    if (i == 18) { return 49166; } else { return 57361; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 21) {\r\n                                    if (i == 20) { return 69651; } else { return 77846; }\r\n                                } else {\r\n                                    if (i == 22) { return 90137; } else { return 102429; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 27) {\r\n                                if (i <= 25) {\r\n                                    if (i == 24) { return 118816; } else { return 131108; }\r\n                                } else {\r\n                                    if (i == 26) { return 147496; } else { return 163885; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 29) {\r\n                                    if (i == 28) { return 184369; } else { return 200758; }\r\n                                } else {\r\n                                    if (i == 30) { return 221244; } else { return 245825; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (i <= 47) {\r\n                        if (i <= 39) {\r\n                            if (i <= 35) {\r\n                                if (i <= 33) {\r\n                                    if (i == 32) { return 266311; } else { return 290893; }\r\n                                } else {\r\n                                    if (i == 34) { return 315476; } else { return 344155; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 37) {\r\n                                    if (i == 36) { return 372834; } else { return 401513; }\r\n                                } else {\r\n                                    if (i == 38) { return 430193; } else { return 462969; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 43) {\r\n                                if (i <= 41) {\r\n                                    if (i == 40) { return 495746; } else { return 532619; }\r\n                                } else {\r\n                                    if (i == 42) { return 569492; } else { return 606366; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 45) {\r\n                                    if (i == 44) { return 647335; } else { return 684210; }\r\n                                } else {\r\n                                    if (i == 46) { return 729276; } else { return 770247; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 55) {\r\n                            if (i <= 51) {\r\n                                if (i <= 49) {\r\n                                    if (i == 48) { return 815315; } else { return 864478; }\r\n                                } else {\r\n                                    if (i == 50) { return 909546; } else { return 958711; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 53) {\r\n                                    if (i == 52) { return 1011971; } else { return 1061137; }\r\n                                } else {\r\n                                    if (i == 54) { return 1118494; } else { return 1171756; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 59) {\r\n                                if (i <= 57) {\r\n                                    if (i == 56) { return 1229114; } else { return 1286473; }\r\n                                } else {\r\n                                    if (i == 58) { return 1347928; } else { return 1409383; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 61) {\r\n                                    if (i == 60) { return 1470838; } else { return 1532294; }\r\n                                } else {\r\n                                    if (i == 62) { return 1597847; } else { return 1667496; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (i <= 95) {\r\n                    if (i <= 79) {\r\n                        if (i <= 71) {\r\n                            if (i <= 67) {\r\n                                if (i <= 65) {\r\n                                    if (i == 64) { return 1737145; } else { return 1806794; }\r\n                                } else {\r\n                                    if (i == 66) { return 1876444; } else { return 1950190; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 69) {\r\n                                    if (i == 68) { return 2023936; } else { return 2097683; }\r\n                                } else {\r\n                                    if (i == 70) { return 2175526; } else { return 2253370; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 75) {\r\n                                if (i <= 73) {\r\n                                    if (i == 72) { return 2335309; } else { return 2413153; }\r\n                                } else {\r\n                                    if (i == 74) { return 2495094; } else { return 2581131; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 77) {\r\n                                    if (i == 76) { return 2667168; } else { return 2753205; }\r\n                                } else {\r\n                                    if (i == 78) { return 2839243; } else { return 2929377; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 87) {\r\n                            if (i <= 83) {\r\n                                if (i <= 81) {\r\n                                    if (i == 80) { return 3019511; } else { return 3109646; }\r\n                                } else {\r\n                                    if (i == 82) { return 3203877; } else { return 3298108; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 85) {\r\n                                    if (i == 84) { return 3392339; } else { return 3486571; }\r\n                                } else {\r\n                                    if (i == 86) { return 3584899; } else { return 3683227; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 91) {\r\n                                if (i <= 89) {\r\n                                    if (i == 88) { return 3781556; } else { return 3883981; }\r\n                                } else {\r\n                                    if (i == 90) { return 3986406; } else { return 4088831; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 93) {\r\n                                    if (i == 92) { return 4191257; } else { return 4297778; }\r\n                                } else {\r\n                                    if (i == 94) { return 4400204; } else { return 4506727; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (i <= 111) {\r\n                        if (i <= 103) {\r\n                            if (i <= 99) {\r\n                                if (i <= 97) {\r\n                                    if (i == 96) { return 4617345; } else { return 4723868; }\r\n                                } else {\r\n                                    if (i == 98) { return 4834487; } else { return 4945106; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 101) {\r\n                                    if (i == 100) { return 5055725; } else { return 5166345; }\r\n                                } else {\r\n                                    if (i == 102) { return 5281060; } else { return 5391680; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 107) {\r\n                                if (i <= 105) {\r\n                                    if (i == 104) { return 5506396; } else { return 5621112; }\r\n                                } else {\r\n                                    if (i == 106) { return 5735829; } else { return 5854641; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 109) {\r\n                                    if (i == 108) { return 5969358; } else { return 6088171; }\r\n                                } else {\r\n                                    if (i == 110) { return 6206983; } else { return 6321700; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 119) {\r\n                            if (i <= 115) {\r\n                                if (i <= 113) {\r\n                                    if (i == 112) { return 6440514; } else { return 6563423; }\r\n                                } else {\r\n                                    if (i == 114) { return 6682236; } else { return 6801050; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 117) {\r\n                                    if (i == 116) { return 6923959; } else { return 7042773; }\r\n                                } else {\r\n                                    if (i == 118) { return 7165682; } else { return 7284496; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 123) {\r\n                                if (i <= 121) {\r\n                                    if (i == 120) { return 7407406; } else { return 7530316; }\r\n                                } else {\r\n                                    if (i == 122) { return 7653226; } else { return 7776136; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 125) {\r\n                                    if (i == 124) { return 7899046; } else { return 8021956; }\r\n                                } else {\r\n                                    if (i == 126) { return 8144866; } else { return 8267776; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (i <= 191) {\r\n                if (i <= 159) {\r\n                    if (i <= 143) {\r\n                        if (i <= 135) {\r\n                            if (i <= 131) {\r\n                                if (i <= 129) {\r\n                                    if (i == 128) { return 8390685; } else { return 8509499; }\r\n                                } else {\r\n                                    if (i == 130) { return 8632409; } else { return 8755319; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 133) {\r\n                                    if (i == 132) { return 8878229; } else { return 9001139; }\r\n                                } else {\r\n                                    if (i == 134) { return 9124049; } else { return 9246959; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 139) {\r\n                                if (i <= 137) {\r\n                                    if (i == 136) { return 9369869; } else { return 9492778; }\r\n                                } else {\r\n                                    if (i == 138) { return 9611592; } else { return 9734501; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 141) {\r\n                                    if (i == 140) { return 9853315; } else { return 9976224; }\r\n                                } else {\r\n                                    if (i == 142) { return 10095037; } else { return 10213851; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 151) {\r\n                            if (i <= 147) {\r\n                                if (i <= 145) {\r\n                                    if (i == 144) { return 10336760; } else { return 10455572; }\r\n                                } else {\r\n                                    if (i == 146) { return 10570289; } else { return 10689102; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 149) {\r\n                                    if (i == 148) { return 10807914; } else { return 10922631; }\r\n                                } else {\r\n                                    if (i == 150) { return 11041443; } else { return 11156159; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 155) {\r\n                                if (i <= 153) {\r\n                                    if (i == 152) { return 11270875; } else { return 11385590; }\r\n                                } else {\r\n                                    if (i == 154) { return 11496210; } else { return 11610925; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 157) {\r\n                                    if (i == 156) { return 11721544; } else { return 11832163; }\r\n                                } else {\r\n                                    if (i == 158) { return 11942782; } else { return 12053400; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (i <= 175) {\r\n                        if (i <= 167) {\r\n                            if (i <= 163) {\r\n                                if (i <= 161) {\r\n                                    if (i == 160) { return 12159923; } else { return 12270541; }\r\n                                } else {\r\n                                    if (i == 162) { return 12377062; } else { return 12479488; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 165) {\r\n                                    if (i == 164) { return 12586009; } else { return 12688434; }\r\n                                } else {\r\n                                    if (i == 166) { return 12790859; } else { return 12893284; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 171) {\r\n                                if (i <= 169) {\r\n                                    if (i == 168) { return 12995708; } else { return 13094036; }\r\n                                } else {\r\n                                    if (i == 170) { return 13192364; } else { return 13290691; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 173) {\r\n                                    if (i == 172) { return 13384922; } else { return 13479153; }\r\n                                } else {\r\n                                    if (i == 174) { return 13573384; } else { return 13667614; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 183) {\r\n                            if (i <= 179) {\r\n                                if (i <= 177) {\r\n                                    if (i == 176) { return 13757748; } else { return 13847882; }\r\n                                } else {\r\n                                    if (i == 178) { return 13938015; } else { return 14024052; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 181) {\r\n                                    if (i == 180) { return 14110089; } else { return 14196126; }\r\n                                } else {\r\n                                    if (i == 182) { return 14282162; } else { return 14364101; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 187) {\r\n                                if (i <= 185) {\r\n                                    if (i == 184) { return 14441945; } else { return 14523884; }\r\n                                } else {\r\n                                    if (i == 186) { return 14601727; } else { return 14679569; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 189) {\r\n                                    if (i == 188) { return 14753315; } else { return 14827061; }\r\n                                } else {\r\n                                    if (i == 190) { return 14900806; } else { return 14970456; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if (i <= 223) {\r\n                    if (i <= 207) {\r\n                        if (i <= 199) {\r\n                            if (i <= 195) {\r\n                                if (i <= 193) {\r\n                                    if (i == 192) { return 15044200; } else { return 15109753; }\r\n                                } else {\r\n                                    if (i == 194) { return 15179401; } else { return 15244952; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 197) {\r\n                                    if (i == 196) { return 15306407; } else { return 15367862; }\r\n                                } else {\r\n                                    if (i == 198) { return 15429317; } else { return 15490771; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 203) {\r\n                                if (i <= 201) {\r\n                                    if (i == 200) { return 15548129; } else { return 15605486; }\r\n                                } else {\r\n                                    if (i == 202) { return 15658748; } else { return 15716104; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 205) {\r\n                                    if (i == 204) { return 15765269; } else { return 15818529; }\r\n                                } else {\r\n                                    if (i == 206) { return 15867692; } else { return 15912760; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 215) {\r\n                            if (i <= 211) {\r\n                                if (i <= 209) {\r\n                                    if (i == 208) { return 15961923; } else { return 16006989; }\r\n                                } else {\r\n                                    if (i == 210) { return 16047960; } else { return 16093025; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 213) {\r\n                                    if (i == 212) { return 16129899; } else { return 16170868; }\r\n                                } else {\r\n                                    if (i == 214) { return 16207741; } else { return 16244614; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 219) {\r\n                                if (i <= 217) {\r\n                                    if (i == 216) { return 16281486; } else { return 16314262; }\r\n                                } else {\r\n                                    if (i == 218) { return 16347037; } else { return 16375716; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 221) {\r\n                                    if (i == 220) { return 16404395; } else { return 16433074; }\r\n                                } else {\r\n                                    if (i == 222) { return 16461752; } else { return 16486334; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (i <= 239) {\r\n                        if (i <= 231) {\r\n                            if (i <= 227) {\r\n                                if (i <= 225) {\r\n                                    if (i == 224) { return 16510915; } else { return 16531401; }\r\n                                } else {\r\n                                    if (i == 226) { return 16555982; } else { return 16576466; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 229) {\r\n                                    if (i == 228) { return 16592855; } else { return 16613339; }\r\n                                } else {\r\n                                    if (i == 230) { return 16629727; } else { return 16646114; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 235) {\r\n                                if (i <= 233) {\r\n                                    if (i == 232) { return 16658406; } else { return 16674793; }\r\n                                } else {\r\n                                    if (i == 234) { return 16687084; } else { return 16699374; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 237) {\r\n                                    if (i == 236) { return 16707569; } else { return 16719859; }\r\n                                } else {\r\n                                    if (i == 238) { return 16728053; } else { return 16736246; }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (i <= 247) {\r\n                            if (i <= 243) {\r\n                                if (i <= 241) {\r\n                                    if (i == 240) { return 16740344; } else { return 16748537; }\r\n                                } else {\r\n                                    if (i == 242) { return 16752635; } else { return 16760828; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 245) {\r\n                                    if (i == 244) { return 16764924; } else { return 16764925; }\r\n                                } else {\r\n                                    if (i == 246) { return 16769022; } else { return 16773118; }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (i <= 251) {\r\n                                if (i <= 249) {\r\n                                    if (i == 248) { return 16773119; } else { return 16777215; }\r\n                                } else {\r\n                                    if (i == 250) { return 16777215; } else { return 16777215; }\r\n                                }\r\n                            } else {\r\n                                if (i <= 253) {\r\n                                    if (i == 252) { return 16777215; } else { return 16777215; }\r\n                                } else {\r\n                                    if (i == 254) { return 16777215; } else { return 16777215; }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/ArmyView.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../core/assets/army/IArmy.sol\";\r\nimport \"../core/assets/era/IEra.sol\";\r\nimport \"../core/assets/IWorldAsset.sol\";\r\nimport \"../core/assets/battle/IBattle.sol\";\r\nimport \"../libraries/MathExtension.sol\";\r\n\r\n/// @title Army view contract\r\n/// @notice Contains helper functions to query army in simple read requests\r\ncontract ArmyView {\r\n    struct ArmyCombinedData {\r\n        address id;\r\n        address owner;\r\n        address ownerSettlementId;\r\n        uint64 currentPosition;\r\n        address currentPositionSettlementId;\r\n        uint64 destinationPosition;\r\n        address destinationPositionSettlementId;\r\n        uint64 secretDestinationRegionId;\r\n        bytes32 secretDestinationPosition;\r\n        uint64 maneuverBeginTime;\r\n        uint64 maneuverEndTime;\r\n        address battleId;\r\n        uint256[] units;\r\n        uint256[] besiegingUnits;\r\n        uint256 robberyPoints;\r\n        uint64 stunBeginTime;\r\n        uint64 stunEndTime;\r\n    }\r\n\r\n    /// @notice Calculates combined army data\r\n    /// @dev Provided timestamp takes into account robberyPoints, maneuver, battle, stun\r\n    /// @param armyAddress Army address\r\n    /// @param timestamp Timestamp at which army data will be calculated\r\n    /// @return armyCombinedData Army combined data\r\n    function getArmyCombinedData(address armyAddress, uint256 timestamp)\r\n        public\r\n        view\r\n        returns (ArmyCombinedData memory armyCombinedData)\r\n    {\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        IArmy army = IArmy(armyAddress);\r\n\r\n        IWorld world = IWorldAsset(armyAddress).world();\r\n        IEra era = IWorldAsset(armyAddress).era();\r\n\r\n        bytes32[] memory unitTypeIds = world.registry().getUnitTypeIds();\r\n\r\n        armyCombinedData.id = armyAddress;\r\n\r\n        armyCombinedData.currentPosition = army.currentPosition();\r\n        armyCombinedData.currentPositionSettlementId = address(era.settlementByPosition(armyCombinedData.currentPosition));\r\n\r\n        (armyCombinedData.stunBeginTime, armyCombinedData.stunEndTime) = army.stunInfo();\r\n        (\r\n            armyCombinedData.maneuverBeginTime,\r\n            armyCombinedData.maneuverEndTime,\r\n            armyCombinedData.destinationPosition,\r\n            armyCombinedData.secretDestinationRegionId,\r\n            armyCombinedData.secretDestinationPosition\r\n        ) = army.maneuverInfo();\r\n\r\n        armyCombinedData.destinationPositionSettlementId = armyCombinedData.maneuverEndTime != 0\r\n            ? address(era.settlementByPosition(armyCombinedData.destinationPosition))\r\n            : address(0);\r\n\r\n        if (armyCombinedData.maneuverEndTime != 0 && timestamp >= armyCombinedData.maneuverEndTime) {\r\n            armyCombinedData.currentPosition = armyCombinedData.destinationPosition;\r\n            armyCombinedData.currentPositionSettlementId = armyCombinedData.destinationPositionSettlementId;\r\n            armyCombinedData.destinationPosition = 0;\r\n            armyCombinedData.destinationPositionSettlementId = address(0);\r\n\r\n            uint64 maneuverDuration = armyCombinedData.maneuverEndTime - armyCombinedData.maneuverBeginTime;\r\n            uint64 maneuverStunDuration = uint64(maneuverDuration * world.registry().getManeuverDurationStunMultiplier() / 1e18);\r\n            uint64 maneuverStunBeginTime = armyCombinedData.maneuverEndTime;\r\n            uint64 maneuverStunEndTime = maneuverStunBeginTime + maneuverStunDuration;\r\n\r\n            if (maneuverStunEndTime > armyCombinedData.stunEndTime) {\r\n                armyCombinedData.stunBeginTime = maneuverStunBeginTime;\r\n                armyCombinedData.stunEndTime = maneuverStunEndTime;\r\n            }\r\n\r\n            armyCombinedData.maneuverBeginTime = 0;\r\n            armyCombinedData.maneuverEndTime = 0;\r\n        }\r\n\r\n        armyCombinedData.owner = _getArmyOwner(army);\r\n        armyCombinedData.ownerSettlementId = address(army.relatedSettlement());\r\n\r\n        armyCombinedData.units = new uint256[](unitTypeIds.length);\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            armyCombinedData.units[i] = era.units(unitTypeIds[i]).balanceOf(armyAddress);\r\n        }\r\n\r\n        armyCombinedData.battleId = address(army.battle());\r\n        if (armyCombinedData.battleId != address(0)) {\r\n            IBattle battle = IBattle(armyCombinedData.battleId);\r\n            if (_canEndBattleAtProvidedTimestamp(battle, timestamp)) {\r\n                (bool isArmyWon, uint256[] memory casualties) = battle.calculateArmyCasualties(armyAddress);\r\n                for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n                    armyCombinedData.units[i] = armyCombinedData.units[i] - casualties[i];\r\n                }\r\n\r\n                (uint64 battleBeginTime, uint64 battleDuration,) = battle.battleTimeInfo();\r\n                uint256 battleStunMultiplier = isArmyWon\r\n                    ? world.registry().getBattleDurationWinningArmyStunMultiplier()\r\n                    : world.registry().getBattleDurationLosingArmyStunMultiplier();\r\n\r\n                uint64 stunDuration = uint64(battleDuration * battleStunMultiplier / 1e18);\r\n                uint64 battleStunBeginTime = battleBeginTime + battleDuration;\r\n                uint64 battleStunEndTime = battleStunBeginTime + stunDuration;\r\n\r\n                if (battleStunEndTime > armyCombinedData.stunEndTime) {\r\n                    armyCombinedData.stunBeginTime = battleStunBeginTime;\r\n                    armyCombinedData.stunEndTime = battleStunEndTime;\r\n                }\r\n\r\n                armyCombinedData.battleId = address(0);\r\n            }\r\n        }\r\n\r\n        if (timestamp >= armyCombinedData.stunEndTime) {\r\n            armyCombinedData.stunBeginTime = 0;\r\n            armyCombinedData.stunEndTime = 0;\r\n        }\r\n\r\n        if (!_isCultistsArmy(army)) {\r\n            ISiege siegeOnCurrentPosition = ISettlement(armyCombinedData.currentPositionSettlementId).siege();\r\n            armyCombinedData.robberyPoints = siegeOnCurrentPosition.getArmyRobberyPoints(armyAddress, timestamp);\r\n            armyCombinedData.besiegingUnits = siegeOnCurrentPosition.getArmyBesiegingUnitsAmounts(armyAddress);\r\n        }\r\n    }\r\n\r\n    /// @dev Calculates army owner\r\n    function _getArmyOwner(IArmy army) internal view returns (address) {\r\n        return !_isCultistsArmy(army) ? army.relatedSettlement().getSettlementOwner() : address(0);\r\n    }\r\n\r\n    /// @dev Calculates if army owner is cultists settlement or not\r\n    function _isCultistsArmy(IArmy army) internal view returns (bool) {\r\n        return address(army.relatedSettlement()) == address(army.relatedSettlement().relatedRegion().cultistsSettlement());\r\n    }\r\n\r\n    /// @dev Calculates if battle can be ended at provided timestamp\r\n    function _canEndBattleAtProvidedTimestamp(\r\n        IBattle battle,\r\n        uint256 timestamp\r\n    ) internal view returns (bool) {\r\n        (uint64 beginTime, uint64 battleDuration, ) = battle.battleTimeInfo();\r\n        return beginTime > 0 && timestamp >= beginTime + battleDuration;\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/BattleView.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../core/assets/battle/IBattle.sol\";\r\nimport \"../core/assets/IWorldAsset.sol\";\r\n\r\n/// @title Battle view contract\r\n/// @notice Contains helper functions to query battle in simple read requests\r\ncontract BattleView {\r\n    struct BattleCombinedData {\r\n        address id;\r\n        uint64 battleBeginTime;\r\n        uint64 battleDuration;\r\n        uint64 battleEndDate;\r\n        address battleSettlementId;\r\n        uint64 battleGamePosition;\r\n        uint256[] side1Casualties;\r\n        uint256[] side2Casualties;\r\n        uint256[] side1UnitsAmount;\r\n        uint256[] side2UnitsAmount;\r\n    }\r\n\r\n    /// @notice Calculates combined battle data\r\n    /// @dev In case of very big battle, this function may not work due to array nature of battle sides\r\n    /// @param battleAddress Battle address\r\n    /// @return battleCombinedData Battle combined data\r\n    function getBattleCombinedData(address battleAddress) public view returns (BattleCombinedData memory battleCombinedData) {\r\n        IBattle battle = IBattle(battleAddress);\r\n        IWorld world = IWorldAsset(battleAddress).world();\r\n        IEra era = IWorldAsset(battleAddress).era();\r\n\r\n        bytes32[] memory unitTypeIds = world.registry().getUnitTypeIds();\r\n\r\n        uint256[] memory side1Casualties = new uint256[](unitTypeIds.length);\r\n        uint256[] memory side2Casualties = new uint256[](unitTypeIds.length);\r\n\r\n        uint256[] memory side1UnitsAmount = new uint256[](unitTypeIds.length);\r\n        uint256[] memory side2UnitsAmount = new uint256[](unitTypeIds.length);\r\n\r\n        for (uint256 i = 0; i < unitTypeIds.length; i++) {\r\n            bytes32 unitTypeId = unitTypeIds[i];\r\n\r\n            side1UnitsAmount[i] = battle.sideUnitsAmount(1, unitTypeId);\r\n            side2UnitsAmount[i] = battle.sideUnitsAmount(2, unitTypeId);\r\n\r\n            side1Casualties[i] = battle.casualties(1, unitTypeId);\r\n            side2Casualties[i] = battle.casualties(2, unitTypeId);\r\n        }\r\n\r\n        IBattle.BattleTimeInfo memory battleTimeInfo = getBattleTimeInfo(battleAddress);\r\n        uint64 position = IBattle(battleAddress).position();\r\n\r\n        return\r\n            BattleCombinedData({\r\n                id: battleAddress,\r\n                battleBeginTime: battleTimeInfo.beginTime,\r\n                battleDuration: battleTimeInfo.duration,\r\n                battleEndDate: battleTimeInfo.endTime,\r\n                battleSettlementId: address(era.settlementByPosition(position)),\r\n                battleGamePosition: position,\r\n                side1UnitsAmount: side1UnitsAmount,\r\n                side2UnitsAmount: side2UnitsAmount,\r\n                side1Casualties: side1Casualties,\r\n                side2Casualties: side2Casualties\r\n            });\r\n    }\r\n\r\n    function getBattleTimeInfo(address battleAddress) public view returns (IBattle.BattleTimeInfo memory battleTimeInfo) {\r\n        IBattle battle = IBattle(battleAddress);\r\n        (uint64 beginTime, uint64 duration, uint64 endTime) = battle.battleTimeInfo();\r\n\r\n        battleTimeInfo.beginTime = beginTime;\r\n        battleTimeInfo.duration = duration;\r\n        battleTimeInfo.endTime = endTime;\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/EraView.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../core/IWorld.sol\";\r\nimport \"../core/assets/era/IEra.sol\";\r\nimport \"../core/assets/settlement/ISettlement.sol\";\r\nimport \"../core/assets/IWorldAsset.sol\";\r\n\r\ncontract EraView {\r\n    /// @notice Returns user settlements by provided banners ids\r\n    /// @dev Useful to batch query settlement addresses by banners ids\r\n    /// @param eraAddress Era address\r\n    /// @param bannerIds Banners ids\r\n    /// @return userSettlements Settlement addresses\r\n    function getUserSettlements(\r\n        address eraAddress,\r\n        uint256[] memory bannerIds\r\n    ) public view returns (address[] memory) {\r\n        IEra era = IEra(eraAddress);\r\n\r\n        address[] memory result = new address[](bannerIds.length);\r\n\r\n        for (uint256 i = 0; i < bannerIds.length; i++) {\r\n            result[i] = address(era.settlementByBannerId(bannerIds[i]));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /// @notice If necessary activates region and restores settlement\r\n    /// @dev Activates region (if it is not activated yet) and restores settlement on position\r\n    /// @param eraAddress Era address\r\n    /// @param position Position\r\n    /// @param regionId Region id of position\r\n    function restoreSettlementWithRegionActivation(\r\n        address eraAddress,\r\n        uint64 position,\r\n        uint64 regionId\r\n    ) public {\r\n        IEra era = IEra(eraAddress);\r\n\r\n        if (address(era.regions(regionId)) == address(0)) {\r\n            era.activateRegion(regionId);\r\n        }\r\n\r\n        era.restoreUserSettlement(position);\r\n    }\r\n\r\n    /// @notice If necessary activates region and destroys settlement\r\n    /// @dev Activates region (if it is not activated yet) and destroys settlement\r\n    /// @param settlementAddress Settlement address\r\n    function destroySettlementWithRegionActivation(\r\n        address settlementAddress\r\n    ) public {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n        IWorldAsset settlementWorldAsset = IWorldAsset(settlementAddress);\r\n        IWorld world = settlementWorldAsset.world();\r\n        IEra currentlyActiveEra = world.eras(world.currentEraNumber());\r\n\r\n        uint64 regionId = settlement.relatedRegion().regionId();\r\n\r\n        if (address(currentlyActiveEra.regions(regionId)) == address(0)) {\r\n            currentlyActiveEra.activateRegion(regionId);\r\n        }\r\n\r\n        settlement.destroyRottenSettlement();\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/Multicall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/// @title Multicall3\r\n/// @notice Aggregate results from multiple function calls\r\n/// @dev Multicall & Multicall2 backwards-compatible\r\n/// @dev Aggregate methods are marked `payable` to save 24 gas per call\r\n/// @author Michael Elliot <mike@makerdao.com>\r\n/// @author Joshua Levine <joshua@makerdao.com>\r\n/// @author Nick Johnson <arachnid@notdot.net>\r\n/// @author Andreas Bigger <andreas@nascent.xyz>\r\n/// @author Matt Solomon <matt@mattsolomon.dev>\r\ncontract Multicall3 {\r\n    struct Call {\r\n        address target;\r\n        bytes callData;\r\n    }\r\n\r\n    struct Call3 {\r\n        address target;\r\n        bool allowFailure;\r\n        bytes callData;\r\n    }\r\n\r\n    struct Call3Value {\r\n        address target;\r\n        bool allowFailure;\r\n        uint256 value;\r\n        bytes callData;\r\n    }\r\n\r\n    struct Result {\r\n        bool success;\r\n        bytes returnData;\r\n    }\r\n\r\n    /// @notice Backwards-compatible call aggregation with Multicall\r\n    /// @param calls An array of Call structs\r\n    /// @return blockNumber The block number where the calls were executed\r\n    /// @return returnData An array of bytes containing the responses\r\n    function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {\r\n        blockNumber = block.number;\r\n        uint256 length = calls.length;\r\n        returnData = new bytes[](length);\r\n        Call calldata call;\r\n        for (uint256 i = 0; i < length;) {\r\n            bool success;\r\n            call = calls[i];\r\n            (success, returnData[i]) = call.target.call(call.callData);\r\n            require(success, \"Multicall3: call failed\");\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /// @notice Backwards-compatible with Multicall2\r\n    /// @notice Aggregate calls without requiring success\r\n    /// @param requireSuccess If true, require all calls to succeed\r\n    /// @param calls An array of Call structs\r\n    /// @return returnData An array of Result structs\r\n    function tryAggregate(bool requireSuccess, Call[] calldata calls) public payable returns (Result[] memory returnData) {\r\n        uint256 length = calls.length;\r\n        returnData = new Result[](length);\r\n        Call calldata call;\r\n        for (uint256 i = 0; i < length;) {\r\n            Result memory result = returnData[i];\r\n            call = calls[i];\r\n            (result.success, result.returnData) = call.target.call(call.callData);\r\n            if (requireSuccess) require(result.success, \"Multicall3: call failed\");\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /// @notice Backwards-compatible with Multicall2\r\n    /// @notice Aggregate calls and allow failures using tryAggregate\r\n    /// @param calls An array of Call structs\r\n    /// @return blockNumber The block number where the calls were executed\r\n    /// @return blockHash The hash of the block where the calls were executed\r\n    /// @return returnData An array of Result structs\r\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\r\n        blockNumber = block.number;\r\n        blockHash = blockhash(block.number);\r\n        returnData = tryAggregate(requireSuccess, calls);\r\n    }\r\n\r\n    /// @notice Backwards-compatible with Multicall2\r\n    /// @notice Aggregate calls and allow failures using tryAggregate\r\n    /// @param calls An array of Call structs\r\n    /// @return blockNumber The block number where the calls were executed\r\n    /// @return blockHash The hash of the block where the calls were executed\r\n    /// @return returnData An array of Result structs\r\n    function blockAndAggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {\r\n        (blockNumber, blockHash, returnData) = tryBlockAndAggregate(true, calls);\r\n    }\r\n\r\n    /// @notice Aggregate calls, ensuring each returns success if required\r\n    /// @param calls An array of Call3 structs\r\n    /// @return returnData An array of Result structs\r\n    function aggregate3(Call3[] calldata calls) public payable returns (Result[] memory returnData) {\r\n        uint256 length = calls.length;\r\n        returnData = new Result[](length);\r\n        Call3 calldata calli;\r\n        for (uint256 i = 0; i < length;) {\r\n            Result memory result = returnData[i];\r\n            calli = calls[i];\r\n            (result.success, result.returnData) = calli.target.call(calli.callData);\r\n            assembly {\r\n            // Revert if the call fails and failure is not allowed\r\n            // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\r\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\r\n                // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\r\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                // set data offset\r\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\r\n                // set length of revert string\r\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\r\n                // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\r\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\r\n                    revert(0x00, 0x64)\r\n                }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /// @notice Aggregate calls with a msg value\r\n    /// @notice Reverts if msg.value is less than the sum of the call values\r\n    /// @param calls An array of Call3Value structs\r\n    /// @return returnData An array of Result structs\r\n    function aggregate3Value(Call3Value[] calldata calls) public payable returns (Result[] memory returnData) {\r\n        uint256 valAccumulator;\r\n        uint256 length = calls.length;\r\n        returnData = new Result[](length);\r\n        Call3Value calldata calli;\r\n        for (uint256 i = 0; i < length;) {\r\n            Result memory result = returnData[i];\r\n            calli = calls[i];\r\n            uint256 val = calli.value;\r\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\r\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\r\n            unchecked { valAccumulator += val; }\r\n            (result.success, result.returnData) = calli.target.call{value: val}(calli.callData);\r\n            assembly {\r\n            // Revert if the call fails and failure is not allowed\r\n            // `allowFailure := calldataload(add(calli, 0x20))` and `success := mload(result)`\r\n                if iszero(or(calldataload(add(calli, 0x20)), mload(result))) {\r\n                // set \"Error(string)\" signature: bytes32(bytes4(keccak256(\"Error(string)\")))\r\n                    mstore(0x00, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                // set data offset\r\n                    mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\r\n                // set length of revert string\r\n                    mstore(0x24, 0x0000000000000000000000000000000000000000000000000000000000000017)\r\n                // set revert string: bytes32(abi.encodePacked(\"Multicall3: call failed\"))\r\n                    mstore(0x44, 0x4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000)\r\n                    revert(0x00, 0x84)\r\n                }\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\r\n        require(msg.value == valAccumulator, \"Multicall3: value mismatch\");\r\n    }\r\n\r\n    /// @notice Returns the block hash for the given block number\r\n    /// @param blockNumber The block number\r\n    function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\r\n        blockHash = blockhash(blockNumber);\r\n    }\r\n\r\n    /// @notice Returns the block number\r\n    function getBlockNumber() public view returns (uint256 blockNumber) {\r\n        blockNumber = block.number;\r\n    }\r\n\r\n    /// @notice Returns the block coinbase\r\n    function getCurrentBlockCoinbase() public view returns (address coinbase) {\r\n        coinbase = block.coinbase;\r\n    }\r\n\r\n    /// @notice Returns the block difficulty\r\n    function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\r\n        difficulty = block.difficulty;\r\n    }\r\n\r\n    /// @notice Returns the block gas limit\r\n    function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\r\n        gaslimit = block.gaslimit;\r\n    }\r\n\r\n    /// @notice Returns the block timestamp\r\n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\r\n        timestamp = block.timestamp;\r\n    }\r\n\r\n    /// @notice Returns the (ETH) balance of a given address\r\n    function getEthBalance(address addr) public view returns (uint256 balance) {\r\n        balance = addr.balance;\r\n    }\r\n\r\n    /// @notice Returns the block hash of the last block\r\n    function getLastBlockHash() public view returns (bytes32 blockHash) {\r\n        unchecked {\r\n            blockHash = blockhash(block.number - 1);\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the base fee of the given block\r\n    /// @notice Can revert if the BASEFEE opcode is not implemented by the given chain\r\n    function getBasefee() public view returns (uint256 basefee) {\r\n        basefee = block.basefee;\r\n    }\r\n\r\n    /// @notice Returns the chain id\r\n    function getChainId() public view returns (uint256 chainid) {\r\n        chainid = block.chainid;\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/ProxyReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nabstract contract ProxyReentrancyGuard {\r\n    bool private _status;\r\n\r\n    /// @notice Thrown when attempting to call function via reentrancy\r\n    error ReentrantCall();\r\n\r\n    modifier nonReentrant() {\r\n        if (_status == true) revert ReentrantCall();\r\n        _status = true;\r\n        _;\r\n        _status = false;\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/Resolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/// @title World resolver\r\n/// @notice Contains currently active world address\r\ncontract Resolver is Ownable {\r\n    /// @notice World address\r\n    /// @dev Updated when #setWorldAddress is called\r\n    address public world;\r\n\r\n    /// @notice Emitted when #setWorldAddress is called\r\n    /// @param worldAddress New world address\r\n    event NewWorldAddress(address worldAddress);\r\n\r\n    /// @notice Updates world address\r\n    /// @dev Even though this function is opened, it can only be called by contract owner\r\n    /// @param _worldAddress New world address\r\n    function setWorldAddress(address _worldAddress) public onlyOwner {\r\n        world = _worldAddress;\r\n        emit NewWorldAddress(_worldAddress);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/SettlementView.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"../core/assets/settlement/ISettlement.sol\";\r\nimport \"../core/assets/IWorldAsset.sol\";\r\nimport \"../const/GameAssetTypes.sol\";\r\n\r\n/// @title Settlement view contract\r\n/// @notice Contains helper read/write requests for interacting with settlement\r\ncontract SettlementView {\r\n    /// @notice Distributes all unharvested resources of all settlement buildings to its shareholders\r\n    /// @dev Caller may pay high amount of gas if there will be a lot of shareholders. Use with caution\r\n    /// @param settlementAddress Settlement address\r\n    function distributeAllBuildingsUnharvestedResources(\r\n        address settlementAddress\r\n    ) public {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n        settlement.buildings(FARM_TYPE_ID).distributeToAllShareholders();\r\n        settlement.buildings(LUMBERMILL_TYPE_ID).distributeToAllShareholders();\r\n        settlement.buildings(MINE_TYPE_ID).distributeToAllShareholders();\r\n        settlement.buildings(SMITHY_TYPE_ID).distributeToAllShareholders();\r\n    }\r\n\r\n    /// @notice Calculates current prosperity at specified timestamp\r\n    /// @dev Uses buildings productions to forecast amount of prosperity will settlement will have at specified time\r\n    /// @param settlementAddress Settlement address\r\n    /// @param timestamp Time at which calculate current prosperity\r\n    /// @return Amount of prosperity at specified time\r\n    function accumulatedCurrentProsperity(\r\n        address settlementAddress,\r\n        uint256 timestamp\r\n    ) public view returns (int256) {\r\n        ISettlement settlement = ISettlement(settlementAddress);\r\n        IWorldAsset worldAsset = IWorldAsset(settlementAddress);\r\n\r\n        if (timestamp == 0) {\r\n            timestamp = block.timestamp;\r\n        }\r\n\r\n        IWorld world = worldAsset.world();\r\n        IRegistry registry = worldAsset.registry();\r\n        IEra settlementEra = worldAsset.era();\r\n\r\n        uint256 spentProsperity = settlementEra.prosperity().prosperitySpent(settlementAddress);\r\n        uint256 extendedProsperityAmount = settlement.extendedProsperityAmount();\r\n\r\n        bytes32[] memory buildingTypeIds = registry.getBuildingTypeIds();\r\n\r\n        for (uint256 i = 0; i < buildingTypeIds.length; i++) {\r\n            IBuilding building = settlement.buildings(buildingTypeIds[i]);\r\n            extendedProsperityAmount += _calculateProsperityByBuilding(registry, building, timestamp);\r\n        }\r\n\r\n        return int256(extendedProsperityAmount) - int256(spentProsperity);\r\n    }\r\n\r\n    /// @dev Calculates prosperity building provides at given timestamp\r\n    function _calculateProsperityByBuilding(\r\n        IRegistry registry,\r\n        IBuilding building,\r\n        uint256 timestamp\r\n    ) internal view returns (uint256) {\r\n        return building.getTreasuryAmount(timestamp)\r\n            * registry.getResourceWeight(building.getProducingResourceTypeId())\r\n            / building.getBuildingCoefficient(building.getBuildingLevel())\r\n            / 1e18;\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/SimpleProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nstruct SimpleProxyStorage {\r\n    address implementation;\r\n    address owner;\r\n}\r\n\r\nfunction getSimpleProxyStorage() pure returns (SimpleProxyStorage storage ds) {\r\n    //keccak256(\"mithraeum.simpleproxy\") is 89ebf6b655b5bf3480fb4246b9e8786d810726f923695e3ff9668f941b26cb1a\r\n    bytes32 position = 0x89ebf6b655b5bf3480fb4246b9e8786d810726f923695e3ff9668f941b26cb1a;\r\n    assembly {\r\n        ds.slot := position\r\n    }\r\n}\r\n\r\n/// @title Simple proxy contract\r\n/// @notice User of current proxy must be aware of simplicity nature of it, in particular case naming collision is not handled in it. Proxy parameters are written as specific slot address\r\ncontract SimpleProxy {\r\n    /// @notice Emitted when #transferOwnership is called\r\n    /// @param previousOwner Previous proxy owner\r\n    /// @param newOwner New proxy owner\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Thrown when attempting to call action which can only be called by owner\r\n    error OnlyOwner();\r\n\r\n    /// @notice Thrown when attempting to transfer ownership to zero address\r\n    error UnableToTransferOwnershipToZeroAddress();\r\n\r\n    /// @dev Only owner modifier\r\n    /// @dev Modifier is calling internal function in order to reduce contract size\r\n    modifier onlyOwner() {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    /// @dev Fallback function that delegates calls to the address returned by `proxyStorage.implementation`. Will run if no other function in the contract matches the call data.\r\n    fallback() external payable {\r\n        SimpleProxyStorage storage proxyStorage = getSimpleProxyStorage();\r\n        address _impl = proxyStorage.implementation;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n\r\n            // (1) copy incoming call data\r\n            calldatacopy(ptr, 0, calldatasize())\r\n\r\n            // (2) forward call to logic contract\r\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n\r\n            // (3) retrieve return data\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            // (4) forward return data back to caller\r\n            switch result\r\n            case 0 {\r\n                revert(ptr, size)\r\n            }\r\n            default {\r\n                return(ptr, size)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Updates proxy implementation address\r\n    /// @dev Even though this function is opened, it can only be called by contract owner\r\n    /// @param _newImpl New implementation address\r\n    function setImplementation(address _newImpl) public onlyOwner {\r\n        SimpleProxyStorage storage proxyStorage = getSimpleProxyStorage();\r\n        proxyStorage.implementation = _newImpl;\r\n    }\r\n\r\n    /// @notice Renounces proxy ownership\r\n    /// @dev Even though this function is opened, it can only be called by contract owner\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /// @notice Transfers ownership to another address\r\n    /// @dev Even though this function is opened, it can only be called by contract owner\r\n    /// @param newOwner New owner address\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) revert UnableToTransferOwnershipToZeroAddress();\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /// @dev Transfers ownership to another address\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        SimpleProxyStorage storage proxyStorage = getSimpleProxyStorage();\r\n        address oldOwner = proxyStorage.owner;\r\n        proxyStorage.owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /// @dev Allows caller to be only owner\r\n    function _onlyOwner() internal view {\r\n        if (getSimpleProxyStorage().owner != msg.sender) revert OnlyOwner();\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/StubERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/// @title Stub token\r\n/// @notice Used for development deployments, where specific functions is token must be present for testing convenience. Should not be used in production\r\ncontract StubERC20 is ERC20, Ownable {\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol\r\n    ) public ERC20(name, symbol) {\r\n\r\n    }\r\n\r\n    /// @notice Mints specified amount of tokens to specified address\r\n    /// @dev Only owner can mint tokens\r\n    /// @param dstAddress An address which will receive tokens\r\n    /// @param amount Tokens amount\r\n    function mintTo(\r\n        address dstAddress,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        _mint(dstAddress, amount);\r\n    }\r\n\r\n    /// @notice Burns specified amount of tokens from specified address\r\n    /// @dev Only owner can burn tokens from address\r\n    /// @param srcAddress An address from which tokens will be burned\r\n    /// @param amount Tokens amount\r\n    function burnFrom(\r\n        address srcAddress,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        _burn(srcAddress, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/token/ERC20Int.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"./IERC20Int.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20Int is Context, IERC20Int, IERC20Metadata {\r\n    mapping(address => int256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    int256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /// @notice Thrown when attempting to decrease allowance below zero\r\n    error CannotDecreaseAllowanceBelowZero();\r\n\r\n    /// @notice Thrown when attempting to transfer from zero address\r\n    error CannotTransferFromZeroAddress();\r\n\r\n    /// @notice Thrown when attempting to transfer to zero address\r\n    error CannotTransferToZeroAddress();\r\n\r\n    /// @notice Thrown when attempting to transfer more tokens than current address has\r\n    error CannotTransferHigherThanOwnedAmountOfTokens();\r\n\r\n    /// @notice Thrown when attempting to mint to zero address\r\n    error CannotMintToZeroAddress();\r\n\r\n    /// @notice Thrown when attempting to burn from zero address\r\n    error CannotBurnFromZeroAddress();\r\n\r\n    /// @notice Thrown when attempting to approve from zero address\r\n    error CannotApproveFromZeroAddress();\r\n\r\n    /// @notice Thrown when attempting to approve to zero address\r\n    error CannotApproveToZeroAddress();\r\n\r\n    /// @notice Thrown when attempting to spend allowance more than current value\r\n    error CannotSpendMoreAllowanceThanCurrentValue();\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        if (_totalSupply < 0) {\r\n            return 0;\r\n        }\r\n        return uint256(_totalSupply);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Int-realTotalSupply}.\r\n     */\r\n    function realTotalSupply() public view virtual returns (int256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Int-realBalanceOf}.\r\n     */\r\n    function realBalanceOf(address account) public view virtual returns (int256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        if (_balances[account] < 0) {\r\n            return 0;\r\n        }\r\n        return uint256(_balances[account]);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance < subtractedValue) revert CannotDecreaseAllowanceBelowZero();\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        if (from == address(0)) revert CannotTransferFromZeroAddress();\r\n        if (to == address(0)) revert CannotTransferToZeroAddress();\r\n\r\n        int256 intAmount = int256(amount);\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        int256 fromBalance = _balances[from];\r\n        if (fromBalance < intAmount) revert CannotTransferHigherThanOwnedAmountOfTokens();\r\n        unchecked {\r\n            _balances[from] = fromBalance - intAmount;\r\n        }\r\n        _balances[to] += intAmount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        if (account == address(0)) revert CannotMintToZeroAddress();\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += int256(amount);\r\n        _balances[account] += int256(amount);\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        if (account == address(0)) revert CannotBurnFromZeroAddress();\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        int256 accountBalance = _balances[account];\r\n        unchecked {\r\n            _balances[account] = accountBalance - int256(amount);\r\n        }\r\n        _totalSupply -= int256(amount);\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        if (owner == address(0)) revert CannotApproveFromZeroAddress();\r\n        if (spender == address(0)) revert CannotApproveToZeroAddress();\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            if (currentAllowance < amount) revert CannotSpendMoreAllowanceThanCurrentValue();\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n"
    },
    "contracts/token/ERC20IntBurnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"./ERC20Int.sol\";\r\nimport \"./IERC20Burnable.sol\";\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\nabstract contract ERC20IntBurnable is Context, ERC20Int, IERC20Burnable {\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n     * allowance.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for ``accounts``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        _spendAllowance(account, _msgSender(), amount);\r\n        _burn(account, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/token/IERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\ninterface IERC20Burnable {\r\n    function burn(uint256 amount) external;\r\n\r\n    function burnFrom(address account, uint256 amount) external;\r\n}\r\n"
    },
    "contracts/token/IERC20Int.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IERC20Int is IERC20 {\r\n    function realBalanceOf(address account) external view returns (int256);\r\n\r\n    function realTotalSupply() external view returns (int256);\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 40
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}